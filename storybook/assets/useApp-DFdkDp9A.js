import{g as m,r as E,j as d,n as $,a8 as A,an as C,h as P}from"./iframe-CA0Xqitl.js";const S=m({id:"core.app-tree"}),j=m({id:"core.swappable-components"}),R=m({id:"core.icons"});class u{static create(e){return new u(e.type,new Set(e.versions))}#e;#n;constructor(e,n){this.#e=e,this.#n=n}TPublic=void 0;TInternal=void 0;isType=e=>this.#t(e);toInternal=e=>{if(!this.#t(e))throw new TypeError(`Invalid opaque type, expected '${this.#e}', but got '${this.#o(e)}'`);if(!this.#n.has(e.version)){const n=Array.from(this.#n).map(this.#r);n.length>1&&(n[n.length-1]=`or ${n[n.length-1]}`);const r=n.length>2?n.join(", "):n.join(" ");throw new TypeError(`Invalid opaque type instance, got version ${this.#r(e.version)}, expected ${r}`)}return e};createInstance(e,n){return Object.assign(n,{$$type:this.#e,...e&&{version:e}})}#t(e){return e===null||typeof e!="object"?!1:e.$$type===this.#e}#o(e){return typeof e!="object"?`<${typeof e}>`:e===null?"<null>":"$$type"in e?String(e.$$type):String(e)}#r=e=>e?`'${e}'`:"undefined"}const b=u.create({type:"@backstage/ExtensionDefinition",versions:["v1","v2"]}),h=u.create({type:"@backstage/ExtensionInput",versions:[void 0]}),T=u.create({type:"@backstage/FrontendPlugin",versions:["v1"]}),w=u.create({versions:["v1"],type:"@backstage/SwappableComponentRef"});function g(t,e,n){const r=n&&e?`${e}/${n}`:e||n;if(!r)throw new Error(`Extension must declare an explicit namespace or name as it could not be resolved from context, kind=${t} namespace=${e} name=${n}`);return t?`${t}:${r}`:r}function O(t,e){const n=r=>{if(h.isType(r)){const{context:o}=h.toInternal(r);if(!o)throw new Error("Invalid input object without a parent extension used as attachment point");return{id:g(o.kind,e,o.name),input:o.input}}if("relative"in r&&r.relative)return{id:g(r.relative.kind,e,r.relative.name),input:r.input};if("id"in r)return{id:r.id,input:r.input};throw new Error("Invalid attachment point specification")};return Array.isArray(t)?t.map(n):n(t)}function f(t,e){const n=b.toInternal(t),{name:r,kind:o,namespace:i,override:c,attachTo:s,...l}=n,a=i??e?.namespace,p=g(o,a,r);return{...l,attachTo:O(s,a),$$type:"@backstage/Extension",version:n.version,id:p,toString(){return`Extension{id=${p}}`}}}function I(t){const e=t.pluginId,n=new Array,r=new Map;for(const o of t.extensions??[]){const i=b.toInternal(o),c=f(o,{namespace:e});n.push(c),r.set(c.id,{...i,namespace:e})}if(n.length!==r.size){const o=n.map(c=>c.id),i=Array.from(new Set(o.filter((c,s)=>o.indexOf(c)!==s)));throw new Error(`Plugin '${e}' provided duplicate extensions: ${i.join(", ")}`)}return T.createInstance("v1",{id:e,routes:t.routes??{},externalRoutes:t.externalRoutes??{},featureFlags:t.featureFlags??[],extensions:n,infoOptions:t.info,async info(){throw new Error(`Attempted to load plugin info for plugin '${e}', but the plugin instance is not installed in an app`)},getExtension(o){const i=r.get(o);if(!i)throw new Error(`Attempted to get non-existent extension '${o}' from plugin '${e}'`);return i},toString(){return`Plugin{id=${e}}`},withOverrides(o){const i=new Set(o.extensions.map(s=>f(s,{namespace:e}).id)),c=(t.extensions??[]).filter(s=>!i.has(f(s,{namespace:e}).id));return I({...t,pluginId:e,extensions:[...c,...o.extensions],info:{...t.info,...o.info}})}})}const k=()=>{try{return $(j)}catch{return}};function x(t){const e=o=>d.jsx("div",{"data-testid":t.id,...o}),n=w.createInstance("v1",{id:t.id,TProps:null,TExternalProps:null,toString(){return`SwappableComponentRef{id=${t.id}}`},defaultComponent:E.lazy(async()=>({default:await t.loader?.()??e})),transformProps:t.transformProps}),r=o=>{const i=k();if(!i){const s=w.toInternal(n),l=s.defaultComponent,a=s.transformProps?.(o)??o;return d.jsx(l,{...a})}const c=i.getComponent(n);return d.jsx(c,{...o})};return Object.assign(r,{ref:n}),r}const F=x({id:"core-progress"}),q=x({id:"core-not-found-error-page"}),D=x({id:"core-error-display",loader:()=>t=>d.jsx("div",{"data-testid":"core-error-display",children:t.error.message})}),v=P("legacy-plugin-compatibility-store",()=>new WeakMap);function B(t){let e=v.get(t);if(e)return e;const n="Not implemented in legacy plugin compatibility layer",r=()=>{throw new Error(n)};return e={getId(){return t.id},get routes(){return{}},get externalRoutes(){return{}},getApis:r,getFeatureFlags:r,provide:r},v.set(t,e),e}function M(t){return I({pluginId:t.getId()})}function N(){try{return C()}catch{return}}const V=()=>{const t=N(),e=t?.get(S),n=t?.get(R),r=A("app-context"),o=E.useMemo(()=>{if(!e||!n)return;const{tree:c}=e.getTree();let s;const l=({plugin:a,...p})=>d.jsx(D,{...p,plugin:a&&M(a)});return{getPlugins(){if(s)return s;const a=new Set;for(const p of c.nodes.values()){const y=p.spec.plugin;y&&a.add(B(y))}return s=Array.from(a),s},getSystemIcon(a){return n.getIcon(a)},getSystemIcons(){return Object.fromEntries(n.listIconKeys().map(a=>[a,n.getIcon(a)]))},getComponents(){return{NotFoundErrorPage:q,BootErrorPage(){throw new Error("The BootErrorPage app component should not be accessed by plugins")},Progress:F,Router(){throw new Error("The Router app component should not be accessed by plugins")},ErrorBoundaryFallback:l}}}},[e,n]);if(o)return o;if(!r)throw new Error("App context is not available");const i=r.atVersion(1);if(!i)throw new Error("AppContext v1 not available");return i};export{V as u};
