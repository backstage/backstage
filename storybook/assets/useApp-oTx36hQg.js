import{U as m,r as I,j as d,J as A,ar as P,az as C,i as S}from"./iframe-BWaAozhM.js";const T=m({id:"core.app-tree"}),R=m({id:"core.swappable-components"}),j=m({id:"core.icons"});class u{static create(e){return new u(e.type,new Set(e.versions))}#e;#t;constructor(e,n){this.#e=e,this.#t=n}TPublic=void 0;TInternal=void 0;isType=e=>this.#n(e);toInternal=e=>{if(!this.#n(e))throw new TypeError(`Invalid opaque type, expected '${this.#e}', but got '${this.#o(e)}'`);if(!this.#t.has(e.version)){const n=Array.from(this.#t).map(this.#r);n.length>1&&(n[n.length-1]=`or ${n[n.length-1]}`);const r=n.length>2?n.join(", "):n.join(" ");throw new TypeError(`Invalid opaque type instance, got version ${this.#r(e.version)}, expected ${r}`)}return e};createInstance(e,n){return Object.assign(n,{$$type:this.#e,...e&&{version:e}})}#n(e){return e===null||typeof e!="object"?!1:e.$$type===this.#e}#o(e){return typeof e!="object"?`<${typeof e}>`:e===null?"<null>":"$$type"in e?String(e.$$type):String(e)}#r=e=>e?`'${e}'`:"undefined"}const $=u.create({type:"@backstage/ExtensionDefinition",versions:["v1","v2"]}),y=u.create({type:"@backstage/ExtensionInput",versions:[void 0]}),O=u.create({type:"@backstage/FrontendPlugin",versions:["v1"]}),w=u.create({versions:["v1"],type:"@backstage/SwappableComponentRef"});function g(t,e,n){const r=n&&e?`${e}/${n}`:e||n;if(!r)throw new Error(`Extension must declare an explicit namespace or name as it could not be resolved from context, kind=${t} namespace=${e} name=${n}`);return t?`${t}:${r}`:r}function k(t,e){const n=r=>{if(y.isType(r)){const{context:o}=y.toInternal(r);if(!o)throw new Error("Invalid input object without a parent extension used as attachment point");return{id:g(o.kind,e,o.name),input:o.input}}if("relative"in r&&r.relative)return{id:g(r.relative.kind,e,r.relative.name),input:r.input};if("id"in r)return{id:r.id,input:r.input};throw new Error("Invalid attachment point specification")};return Array.isArray(t)?t.map(n):n(t)}function f(t,e){const n=$.toInternal(t),{name:r,kind:o,namespace:i,override:a,attachTo:c,...p}=n,s=i??e?.namespace,l=g(o,s,r);return{...p,attachTo:k(c,s),$$type:"@backstage/Extension",version:n.version,id:l,toString(){return`Extension{id=${l}}`}}}const v=/^[a-z][a-z0-9]*(?:-[a-z0-9]+)*$/i;function b(t){const e=t.pluginId;v.test(e)||console.warn(`WARNING: The pluginId '${e}' will be invalid soon, please change it to match the pattern ${v} (letters, digits, and dashes only, starting with a letter)`);const n=new Array,r=new Map;for(const o of t.extensions??[]){const i=$.toInternal(o),a=f(o,{namespace:e});n.push(a),r.set(a.id,{...i,namespace:e})}if(n.length!==r.size){const o=n.map(a=>a.id),i=Array.from(new Set(o.filter((a,c)=>o.indexOf(a)!==c)));throw new Error(`Plugin '${e}' provided duplicate extensions: ${i.join(", ")}`)}return O.createInstance("v1",{pluginId:e,id:e,title:t.title,icon:t.icon,routes:t.routes??{},externalRoutes:t.externalRoutes??{},featureFlags:t.featureFlags??[],extensions:n,infoOptions:t.info,async info(){throw new Error(`Attempted to load plugin info for plugin '${e}', but the plugin instance is not installed in an app`)},getExtension(o){const i=r.get(o);if(!i)throw new Error(`Attempted to get non-existent extension '${o}' from plugin '${e}'`);return i},toString(){return`Plugin{id=${e}}`},withOverrides(o){const i=o.extensions??[],a=new Set(i.map(p=>f(p,{namespace:e}).id)),c=(t.extensions??[]).filter(p=>!a.has(f(p,{namespace:e}).id));return b({...t,pluginId:e,title:o.title??t.title,icon:o.icon??t.icon,extensions:[...c,...i],info:{...t.info,...o.info}})}})}const F=()=>{try{return A(R)}catch{return}};function h(t){const e=o=>d.jsx("div",{"data-testid":t.id,...o}),n=w.createInstance("v1",{id:t.id,TProps:null,TExternalProps:null,toString(){return`SwappableComponentRef{id=${t.id}}`},defaultComponent:I.lazy(async()=>({default:await t.loader?.()??e})),transformProps:t.transformProps}),r=o=>{const i=F();if(!i){const c=w.toInternal(n),p=c.defaultComponent,s=c.transformProps?.(o)??o;return d.jsx(p,{...s})}const a=i.getComponent(n);return d.jsx(a,{...o})};return Object.assign(r,{ref:n}),r}const D=h({id:"core-progress"}),N=h({id:"core-not-found-error-page"}),q=h({id:"core-error-display",loader:()=>t=>d.jsx("div",{"data-testid":"core-error-display",children:t.error.message})}),E=S("legacy-plugin-compatibility-store",()=>new WeakMap);function z(t){let e=E.get(t);if(e)return e;const n="Not implemented in legacy plugin compatibility layer",r=()=>{throw new Error(n)};return e={getId(){return t.pluginId??t.id},get routes(){return{}},get externalRoutes(){return{}},getApis:r,getFeatureFlags:r,provide:r},E.set(t,e),e}function B(t){return b({pluginId:t.getId()})}function M(){try{return C()}catch{return}}const V=()=>{const t=M(),e=t?.get(T),n=t?.get(j),r=P("app-context"),o=I.useMemo(()=>{if(!e||!n)return;const{tree:a}=e.getTree();let c;const p=({plugin:s,...l})=>d.jsx(q,{...l,plugin:s&&B(s)});return{getPlugins(){if(c)return c;const s=new Set;for(const l of a.nodes.values()){const x=l.spec.plugin;x&&s.add(z(x))}return c=Array.from(s),c},getSystemIcon(s){return n.getIcon(s)},getSystemIcons(){return Object.fromEntries(n.listIconKeys().map(s=>[s,n.getIcon(s)]))},getComponents(){return{NotFoundErrorPage:N,BootErrorPage(){throw new Error("The BootErrorPage app component should not be accessed by plugins")},Progress:D,Router(){throw new Error("The Router app component should not be accessed by plugins")},ErrorBoundaryFallback:p}}}},[e,n]);if(o)return o;if(!r)throw new Error("App context is not available");const i=r.atVersion(1);if(!i)throw new Error("AppContext v1 not available");return i};export{V as u};
