import{c as h}from"./ApiRef-ByCJBjX1.js";import{r as c}from"./index-D8-PC79C.js";import{O as f}from"./index-DtdSELz7.js";const w=h({id:"core.storage"});var p=typeof window<"u",b=p?c.useLayoutEffect:c.useEffect;function y(a,e){var t=c.useState(e),r=t[0],s=t[1];return b(function(){var u=a.subscribe(s);return function(){return u.unsubscribe()}},[a]),r}const n=new Map;class o{constructor(e,t){this.namespace=e,this.errorApi=t}static hasSubscribed=!1;static create(e){return new o(e.namespace??"",e.errorApi)}static addStorageEventListener(){window.addEventListener("storage",e=>{for(const[t,r]of n.entries())e.key?.startsWith(t)&&r.handleStorageChange(e.key)})}get(e){return this.snapshot(e).value}snapshot(e){let t,r="absent";try{const s=localStorage.getItem(this.getKeyName(e));s&&(t=JSON.parse(s,(u,i)=>(typeof i=="object"&&i!==null&&Object.freeze(i),i)),r="present")}catch{this.errorApi.post(new Error(`Error when parsing JSON config from storage for: ${e}`))}return{key:e,value:t,presence:r}}forBucket(e){const t=`${this.namespace}/${e}`;return n.has(t)||n.set(t,new o(t,this.errorApi)),n.get(t)}async set(e,t){localStorage.setItem(this.getKeyName(e),JSON.stringify(t)),this.notifyChanges(e)}async remove(e){localStorage.removeItem(this.getKeyName(e)),this.notifyChanges(e)}observe$(e){return o.hasSubscribed||(o.addStorageEventListener(),o.hasSubscribed=!0),this.observable.filter(({key:t})=>t===e)}handleStorageChange(e){if(!e?.startsWith(this.namespace))return;const t=e?.slice(`${this.namespace}/`.length);t.includes("/")||this.notifyChanges(decodeURIComponent(t))}getKeyName(e){return`${this.namespace}/${encodeURIComponent(e)}`}notifyChanges(e){const t=this.snapshot(e);for(const r of this.subscribers)r.next(t)}subscribers=new Set;observable=new f(e=>(this.subscribers.add(e),()=>{this.subscribers.delete(e)}))}const l={subscribe:()=>({unsubscribe:()=>{},closed:!0}),[Symbol.observable](){return this}};class v{constructor(e={}){this.options=e}errors=new Array;waiters=new Set;post(e,t){if(this.options.collect){this.errors.push({error:e,context:t});for(const r of this.waiters)r.pattern.test(e.message)&&(this.waiters.delete(r),r.resolve({error:e,context:t}));return}throw new Error(`MockErrorApi received unexpected error, ${e}`)}error$(){return l}getErrors(){return this.errors}waitForError(e,t=2e3){return new Promise((r,s)=>{setTimeout(()=>{s(new Error("Timed out waiting for error"))},t),this.waiters.add({resolve:r,pattern:e})})}}export{v as M,o as W,w as s,y as u};
