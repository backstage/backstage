import{X as m,r as I,j as d,J as A,av as P,aB as C,i as S}from"./iframe-M9O-K8SB.js";const T=m({id:"core.app-tree"}),R=m({id:"core.swappable-components"}),j=m({id:"core.icons"});class u{static create(e){return new u(e.type,new Set(e.versions))}#e;#t;constructor(e,t){this.#e=e,this.#t=t}TPublic=void 0;TInternal=void 0;isType=e=>this.#n(e);toInternal=e=>{if(!this.#n(e))throw new TypeError(`Invalid opaque type, expected '${this.#e}', but got '${this.#o(e)}'`);if(!this.#t.has(e.version)){const t=Array.from(this.#t).map(this.#r);t.length>1&&(t[t.length-1]=`or ${t[t.length-1]}`);const r=t.length>2?t.join(", "):t.join(" ");throw new TypeError(`Invalid opaque type instance, got version ${this.#r(e.version)}, expected ${r}`)}return e};createInstance(e,t){return Object.assign(t,{$$type:this.#e,...e&&{version:e}})}#n(e){return e===null||typeof e!="object"?!1:e.$$type===this.#e}#o(e){return typeof e!="object"?`<${typeof e}>`:e===null?"<null>":"$$type"in e?String(e.$$type):String(e)}#r=e=>e?`'${e}'`:"undefined"}const $=u.create({type:"@backstage/ExtensionDefinition",versions:["v1","v2"]}),y=u.create({type:"@backstage/ExtensionInput",versions:[void 0]}),O=u.create({type:"@backstage/FrontendPlugin",versions:["v1"]}),w=u.create({versions:["v1"],type:"@backstage/SwappableComponentRef"});function g(n,e,t){const r=t&&e?`${e}/${t}`:e||t;if(!r)throw new Error(`Extension must declare an explicit namespace or name as it could not be resolved from context, kind=${n} namespace=${e} name=${t}`);return n?`${n}:${r}`:r}function k(n,e){const t=r=>{if(y.isType(r)){const{context:o}=y.toInternal(r);if(!o)throw new Error("Invalid input object without a parent extension used as attachment point");return{id:g(o.kind,e,o.name),input:o.input}}if("relative"in r&&r.relative)return{id:g(r.relative.kind,e,r.relative.name),input:r.input};if("id"in r)return{id:r.id,input:r.input};throw new Error("Invalid attachment point specification")};return Array.isArray(n)?n.map(t):t(n)}function f(n,e){const t=$.toInternal(n),{name:r,kind:o,namespace:i,override:c,attachTo:s,...l}=t,a=i??e?.namespace,p=g(o,a,r);return{...l,attachTo:k(s,a),$$type:"@backstage/Extension",version:t.version,id:p,toString(){return`Extension{id=${p}}`}}}const v=/^[a-z][a-z0-9]*(?:-[a-z0-9]+)*$/i;function b(n){const e=n.pluginId;v.test(e)||console.warn(`WARNING: The pluginId '${e}' will be invalid soon, please change it to match the pattern ${v} (letters, digits, and dashes only, starting with a letter)`);const t=new Array,r=new Map;for(const o of n.extensions??[]){const i=$.toInternal(o),c=f(o,{namespace:e});t.push(c),r.set(c.id,{...i,namespace:e})}if(t.length!==r.size){const o=t.map(c=>c.id),i=Array.from(new Set(o.filter((c,s)=>o.indexOf(c)!==s)));throw new Error(`Plugin '${e}' provided duplicate extensions: ${i.join(", ")}`)}return O.createInstance("v1",{pluginId:e,id:e,routes:n.routes??{},externalRoutes:n.externalRoutes??{},featureFlags:n.featureFlags??[],extensions:t,infoOptions:n.info,async info(){throw new Error(`Attempted to load plugin info for plugin '${e}', but the plugin instance is not installed in an app`)},getExtension(o){const i=r.get(o);if(!i)throw new Error(`Attempted to get non-existent extension '${o}' from plugin '${e}'`);return i},toString(){return`Plugin{id=${e}}`},withOverrides(o){const i=new Set(o.extensions.map(s=>f(s,{namespace:e}).id)),c=(n.extensions??[]).filter(s=>!i.has(f(s,{namespace:e}).id));return b({...n,pluginId:e,extensions:[...c,...o.extensions],info:{...n.info,...o.info}})}})}const F=()=>{try{return A(R)}catch{return}};function h(n){const e=o=>d.jsx("div",{"data-testid":n.id,...o}),t=w.createInstance("v1",{id:n.id,TProps:null,TExternalProps:null,toString(){return`SwappableComponentRef{id=${n.id}}`},defaultComponent:I.lazy(async()=>({default:await n.loader?.()??e})),transformProps:n.transformProps}),r=o=>{const i=F();if(!i){const s=w.toInternal(t),l=s.defaultComponent,a=s.transformProps?.(o)??o;return d.jsx(l,{...a})}const c=i.getComponent(t);return d.jsx(c,{...o})};return Object.assign(r,{ref:t}),r}const D=h({id:"core-progress"}),N=h({id:"core-not-found-error-page"}),q=h({id:"core-error-display",loader:()=>n=>d.jsx("div",{"data-testid":"core-error-display",children:n.error.message})}),E=S("legacy-plugin-compatibility-store",()=>new WeakMap);function B(n){let e=E.get(n);if(e)return e;const t="Not implemented in legacy plugin compatibility layer",r=()=>{throw new Error(t)};return e={getId(){return n.pluginId??n.id},get routes(){return{}},get externalRoutes(){return{}},getApis:r,getFeatureFlags:r,provide:r},E.set(n,e),e}function z(n){return b({pluginId:n.getId()})}function M(){try{return C()}catch{return}}const V=()=>{const n=M(),e=n?.get(T),t=n?.get(j),r=P("app-context"),o=I.useMemo(()=>{if(!e||!t)return;const{tree:c}=e.getTree();let s;const l=({plugin:a,...p})=>d.jsx(q,{...p,plugin:a&&z(a)});return{getPlugins(){if(s)return s;const a=new Set;for(const p of c.nodes.values()){const x=p.spec.plugin;x&&a.add(B(x))}return s=Array.from(a),s},getSystemIcon(a){return t.getIcon(a)},getSystemIcons(){return Object.fromEntries(t.listIconKeys().map(a=>[a,t.getIcon(a)]))},getComponents(){return{NotFoundErrorPage:N,BootErrorPage(){throw new Error("The BootErrorPage app component should not be accessed by plugins")},Progress:D,Router(){throw new Error("The Router app component should not be accessed by plugins")},ErrorBoundaryFallback:l}}}},[e,t]);if(o)return o;if(!r)throw new Error("App context is not available");const i=r.atVersion(1);if(!i)throw new Error("AppContext v1 not available");return i};export{V as u};
