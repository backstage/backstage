## API Report File for "@backstage/frontend-plugin-api"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts
/// <reference types="react" />

import { AnyApiFactory as AnyApiFactory_2 } from '@backstage/core-plugin-api';
import { AnyApiRef as AnyApiRef_2 } from '@backstage/core-plugin-api';
import { ApiFactory as ApiFactory_2 } from '@backstage/core-plugin-api';
import { ApiHolder as ApiHolder_2 } from '@backstage/core-plugin-api';
import { ApiRef as ApiRef_2 } from '@backstage/core-plugin-api';
import { AppTheme as AppTheme_2 } from '@backstage/core-plugin-api';
import { ComponentType } from 'react';
import { Config } from '@backstage/config';
import { IconComponent as IconComponent_2 } from '@backstage/core-plugin-api';
import { JsonObject } from '@backstage/types';
import { JsonValue } from '@backstage/types';
import { JSX as JSX_2 } from 'react';
import { Observable } from '@backstage/types';
import { PropsWithChildren } from 'react';
import { default as React_2 } from 'react';
import { ReactNode } from 'react';
import { z } from 'zod';
import { ZodSchema } from 'zod';
import { ZodTypeDef } from 'zod';

// @public
export type AlertApi = {
  post(alert: AlertMessage): void;
  alert$(): Observable<AlertMessage>;
};

// @public
export const alertApiRef: ApiRef<AlertApi>;

// @public
export type AlertMessage = {
  message: string;
  severity?: 'success' | 'info' | 'warning' | 'error';
  display?: 'permanent' | 'transient';
};

// @public
export type AnyApiFactory = ApiFactory<
  unknown,
  unknown,
  {
    [key in string]: unknown;
  }
>;

// @public
export type AnyApiRef = ApiRef<unknown>;

// @public (undocumented)
export type AnyExtensionDataMap = {
  [name in string]: ExtensionDataRef<
    unknown,
    {
      optional?: true;
    }
  >;
};

// @public (undocumented)
export type AnyExtensionInputMap = {
  [inputName in string]: ExtensionInput<
    AnyExtensionDataMap,
    {
      optional: boolean;
      singleton: boolean;
    }
  >;
};

// @public (undocumented)
export type AnyExternalRoutes = {
  [name in string]: ExternalRouteRef;
};

// @public
export type AnyRouteRefParams =
  | {
      [param in string]: string;
    }
  | undefined;

// @public (undocumented)
export type AnyRoutes = {
  [name in string]: RouteRef;
};

// @public
export type ApiFactory<
  Api,
  Impl extends Api,
  Deps extends {
    [name in string]: unknown;
  },
> = {
  api: ApiRef<Api>;
  deps: TypesToApiRefs<Deps>;
  factory(deps: Deps): Impl;
};

// @public (undocumented)
export type ApiFactoryHolder = {
  get<T>(api: ApiRef<T>):
    | ApiFactory<
        T,
        T,
        {
          [key in string]: unknown;
        }
      >
    | undefined;
};

// @public
export class ApiFactoryRegistry implements ApiFactoryHolder {
  // (undocumented)
  get<T>(api: ApiRef_2<T>):
    | ApiFactory_2<
        T,
        T,
        {
          [x: string]: unknown;
        }
      >
    | undefined;
  // (undocumented)
  getAllApis(): Set<AnyApiRef_2>;
  register<
    Api,
    Impl extends Api,
    Deps extends {
      [name in string]: unknown;
    },
  >(scope: ApiFactoryScope, factory: ApiFactory_2<Api, Impl, Deps>): boolean;
}

// @public
export type ApiFactoryScope = 'default' | 'app' | 'static';

// @public
export type ApiHolder = {
  get<T>(api: ApiRef<T>): T | undefined;
};

// @public
export const ApiProvider: (
  props: PropsWithChildren<ApiProviderProps>,
) => React_2.JSX.Element;

// @public
export type ApiProviderProps = {
  apis: ApiHolder_2;
  children: ReactNode;
};

// @public
export type ApiRef<T> = {
  id: string;
  T: T;
};

// @public
export type ApiRefConfig = {
  id: string;
};

// @public
export class ApiResolver implements ApiHolder_2 {
  constructor(factories: ApiFactoryHolder);
  // (undocumented)
  get<T>(ref: ApiRef_2<T>): T | undefined;
  static validateFactories(
    factories: ApiFactoryHolder,
    apis: Iterable<AnyApiRef_2>,
  ): void;
}

// @public
export interface AppNode {
  readonly edges: AppNodeEdges;
  readonly instance?: AppNodeInstance;
  readonly spec: AppNodeSpec;
}

// @public
export interface AppNodeEdges {
  // (undocumented)
  readonly attachedTo?: {
    node: AppNode;
    input: string;
  };
  // (undocumented)
  readonly attachments: ReadonlyMap<string, AppNode[]>;
}

// @public
export interface AppNodeInstance {
  getData<T>(ref: ExtensionDataRef<T>): T | undefined;
  getDataRefs(): Iterable<ExtensionDataRef<unknown>>;
}

// @public
export interface AppNodeSpec {
  // (undocumented)
  readonly attachTo: {
    id: string;
    input: string;
  };
  // (undocumented)
  readonly config?: unknown;
  // (undocumented)
  readonly disabled: boolean;
  // (undocumented)
  readonly extension: Extension<unknown>;
  // (undocumented)
  readonly id: string;
  // (undocumented)
  readonly source?: BackstagePlugin;
}

// @public
export type AppTheme = {
  id: string;
  title: string;
  variant: 'light' | 'dark';
  icon?: React.ReactElement;
  Provider(props: { children: ReactNode }): JSX.Element | null;
};

// @public
export type AppThemeApi = {
  getInstalledThemes(): AppTheme[];
  activeThemeId$(): Observable<string | undefined>;
  getActiveThemeId(): string | undefined;
  setActiveThemeId(themeId?: string): void;
};

// @public
export const appThemeApiRef: ApiRef<AppThemeApi>;

// @public
export interface AppTree {
  readonly nodes: ReadonlyMap<string, AppNode>;
  readonly orphans: Iterable<AppNode>;
  readonly root: AppNode;
}

// @public
export interface AppTreeApi {
  getTree(): {
    tree: AppTree;
  };
}

// @public
export const appTreeApiRef: ApiRef_2<AppTreeApi>;

// @public
export const atlassianAuthApiRef: ApiRef<
  OAuthApi & ProfileInfoApi & BackstageIdentityApi & SessionApi
>;

// @public
export type AuthProviderInfo = {
  id: string;
  title: string;
  icon: IconComponent;
};

// @public
export type AuthRequestOptions = {
  optional?: boolean;
  instantPopup?: boolean;
};

// @public
export type BackstageIdentityApi = {
  getBackstageIdentity(
    options?: AuthRequestOptions,
  ): Promise<BackstageIdentityResponse | undefined>;
};

// @public
export type BackstageIdentityResponse = {
  token: string;
  expiresAt?: Date;
  identity: BackstageUserIdentity;
};

// @public (undocumented)
export interface BackstagePlugin<
  Routes extends AnyRoutes = AnyRoutes,
  ExternalRoutes extends AnyExternalRoutes = AnyExternalRoutes,
> {
  // (undocumented)
  $$type: '@backstage/BackstagePlugin';
  // (undocumented)
  extensions: Extension<unknown>[];
  // (undocumented)
  externalRoutes: ExternalRoutes;
  // (undocumented)
  id: string;
  // (undocumented)
  routes: Routes;
}

// @public
export type BackstageUserIdentity = {
  type: 'user';
  userEntityRef: string;
  ownershipEntityRefs: string[];
};

// @public
export const bitbucketAuthApiRef: ApiRef<
  OAuthApi & ProfileInfoApi & BackstageIdentityApi & SessionApi
>;

// @public
export const bitbucketServerAuthApiRef: ApiRef<
  OAuthApi & ProfileInfoApi & BackstageIdentityApi & SessionApi
>;

// @public
export type ConfigApi = Config;

// @public
export const configApiRef: ApiRef<ConfigApi>;

// @public (undocumented)
export interface ConfigurableExtensionDataRef<
  TData,
  TConfig extends {
    optional?: true;
  } = {},
> extends ExtensionDataRef<TData, TConfig> {
  // (undocumented)
  optional(): ConfigurableExtensionDataRef<
    TData,
    TData & {
      optional: true;
    }
  >;
}

// @public (undocumented)
export const coreExtensionData: {
  reactElement: ConfigurableExtensionDataRef<JSX_2.Element, {}>;
  routePath: ConfigurableExtensionDataRef<string, {}>;
  apiFactory: ConfigurableExtensionDataRef<AnyApiFactory_2, {}>;
  routeRef: ConfigurableExtensionDataRef<RouteRef<AnyRouteRefParams>, {}>;
  navTarget: ConfigurableExtensionDataRef<NavTarget, {}>;
  theme: ConfigurableExtensionDataRef<AppTheme_2, {}>;
};

// @public (undocumented)
export function createApiExtension<
  TConfig extends {},
  TInputs extends AnyExtensionInputMap,
>(
  options: (
    | {
        api: AnyApiRef_2;
        factory: (options: {
          config: TConfig;
          inputs: Expand<ExtensionInputValues<TInputs>>;
        }) => AnyApiFactory_2;
      }
    | {
        factory: AnyApiFactory_2;
      }
  ) & {
    configSchema?: PortableSchema<TConfig>;
    inputs?: TInputs;
  },
): Extension<TConfig>;

// @public
export function createApiRef<T>(config: ApiRefConfig): ApiRef<T>;

// @public (undocumented)
export function createExtension<
  TOutput extends AnyExtensionDataMap,
  TInputs extends AnyExtensionInputMap,
  TConfig = never,
>(
  options: CreateExtensionOptions<TOutput, TInputs, TConfig>,
): Extension<TConfig>;

// @public (undocumented)
export function createExtensionDataRef<TData>(
  id: string,
): ConfigurableExtensionDataRef<TData>;

// @public (undocumented)
export function createExtensionInput<
  TExtensionData extends AnyExtensionDataMap,
  TConfig extends {
    singleton?: boolean;
    optional?: boolean;
  },
>(
  extensionData: TExtensionData,
  config?: TConfig,
): ExtensionInput<
  TExtensionData,
  {
    singleton: TConfig['singleton'] extends true ? true : false;
    optional: TConfig['optional'] extends true ? true : false;
  }
>;

// @public (undocumented)
export interface CreateExtensionOptions<
  TOutput extends AnyExtensionDataMap,
  TInputs extends AnyExtensionInputMap,
  TConfig,
> {
  // (undocumented)
  attachTo: {
    id: string;
    input: string;
  };
  // (undocumented)
  configSchema?: PortableSchema<TConfig>;
  // (undocumented)
  disabled?: boolean;
  // (undocumented)
  factory(options: {
    source?: BackstagePlugin;
    config: TConfig;
    inputs: Expand<ExtensionInputValues<TInputs>>;
  }): Expand<ExtensionDataValues<TOutput>>;
  // (undocumented)
  id: string;
  // (undocumented)
  inputs?: TInputs;
  // (undocumented)
  output: TOutput;
}

// @public (undocumented)
export function createExtensionOverrides(
  options: ExtensionOverridesOptions,
): ExtensionOverrides;

// @public
export function createExternalRouteRef<
  TParams extends
    | {
        [param in TParamKeys]: string;
      }
    | undefined = undefined,
  TOptional extends boolean = false,
  TParamKeys extends string = string,
>(options?: {
  readonly params?: string extends TParamKeys
    ? (keyof TParams)[]
    : TParamKeys[];
  optional?: TOptional;
}): ExternalRouteRef<
  keyof TParams extends never
    ? undefined
    : string extends TParamKeys
    ? TParams
    : {
        [param in TParamKeys]: string;
      },
  TOptional
>;

// @public
export function createNavItemExtension(options: {
  id: string;
  routeRef: RouteRef<undefined>;
  title: string;
  icon: IconComponent_2;
}): Extension<{
  title: string;
}>;

// @public
export function createPageExtension<
  TConfig extends {
    path: string;
  },
  TInputs extends AnyExtensionInputMap,
>(
  options: (
    | {
        defaultPath: string;
      }
    | {
        configSchema: PortableSchema<TConfig>;
      }
  ) & {
    id: string;
    attachTo?: {
      id: string;
      input: string;
    };
    disabled?: boolean;
    inputs?: TInputs;
    routeRef?: RouteRef;
    loader: (options: {
      config: TConfig;
      inputs: Expand<ExtensionInputValues<TInputs>>;
    }) => Promise<JSX.Element>;
  },
): Extension<TConfig>;

// @public (undocumented)
export function createPlugin<
  Routes extends AnyRoutes = {},
  ExternalRoutes extends AnyExternalRoutes = {},
>(
  options: PluginOptions<Routes, ExternalRoutes>,
): BackstagePlugin<Routes, ExternalRoutes>;

// @public
export function createRouteRef<
  TParams extends
    | {
        [param in TParamKeys]: string;
      }
    | undefined = undefined,
  TParamKeys extends string = string,
>(config?: {
  readonly params: string extends TParamKeys ? (keyof TParams)[] : TParamKeys[];
}): RouteRef<
  keyof TParams extends never
    ? undefined
    : string extends TParamKeys
    ? TParams
    : {
        [param in TParamKeys]: string;
      }
>;

// @public (undocumented)
export function createSchemaFromZod<TOutput, TInput>(
  schemaCreator: (zImpl: typeof z) => ZodSchema<TOutput, ZodTypeDef, TInput>,
): PortableSchema<TOutput>;

// @public
export function createSubRouteRef<
  Path extends string,
  ParentParams extends AnyRouteRefParams = never,
>(config: {
  path: Path;
  parent: RouteRef<ParentParams>;
}): MakeSubRouteRef<PathParams<Path>, ParentParams>;

// @public (undocumented)
export function createThemeExtension(theme: AppTheme_2): Extension<never>;

// @public
export type DiscoveryApi = {
  getBaseUrl(pluginId: string): Promise<string>;
};

// @public
export const discoveryApiRef: ApiRef<DiscoveryApi>;

// @public
export type ErrorApi = {
  post(error: ErrorApiError, context?: ErrorApiErrorContext): void;
  error$(): Observable<{
    error: ErrorApiError;
    context?: ErrorApiErrorContext;
  }>;
};

// @public
export type ErrorApiError = {
  name: string;
  message: string;
  stack?: string;
};

// @public
export type ErrorApiErrorContext = {
  hidden?: boolean;
};

// @public
export const errorApiRef: ApiRef<ErrorApi>;

// @public (undocumented)
export interface Extension<TConfig> {
  // (undocumented)
  $$type: '@backstage/Extension';
  // (undocumented)
  attachTo: {
    id: string;
    input: string;
  };
  // (undocumented)
  configSchema?: PortableSchema<TConfig>;
  // (undocumented)
  disabled: boolean;
  // (undocumented)
  factory(options: {
    source?: BackstagePlugin;
    config: TConfig;
    inputs: Record<
      string,
      undefined | Record<string, unknown> | Array<Record<string, unknown>>
    >;
  }): ExtensionDataValues<any>;
  // (undocumented)
  id: string;
  // (undocumented)
  inputs: AnyExtensionInputMap;
  // (undocumented)
  output: AnyExtensionDataMap;
}

// @public (undocumented)
export function ExtensionBoundary(
  props: ExtensionBoundaryProps,
): React_2.JSX.Element;

// @public (undocumented)
export interface ExtensionBoundaryProps {
  // (undocumented)
  children: ReactNode;
  // (undocumented)
  id: string;
  // (undocumented)
  routable?: boolean;
  // (undocumented)
  source?: BackstagePlugin;
}

// @public (undocumented)
export type ExtensionDataRef<
  TData,
  TConfig extends {
    optional?: true;
  } = {},
> = {
  id: string;
  T: TData;
  config: TConfig;
  $$type: '@backstage/ExtensionDataRef';
};

// @public
export type ExtensionDataValues<TExtensionData extends AnyExtensionDataMap> = {
  [DataName in keyof TExtensionData as TExtensionData[DataName]['config'] extends {
    optional: true;
  }
    ? never
    : DataName]: TExtensionData[DataName]['T'];
} & {
  [DataName in keyof TExtensionData as TExtensionData[DataName]['config'] extends {
    optional: true;
  }
    ? DataName
    : never]?: TExtensionData[DataName]['T'];
};

// @public (undocumented)
export interface ExtensionInput<
  TExtensionData extends AnyExtensionDataMap,
  TConfig extends {
    singleton: boolean;
    optional: boolean;
  },
> {
  // (undocumented)
  $$type: '@backstage/ExtensionInput';
  // (undocumented)
  config: TConfig;
  // (undocumented)
  extensionData: TExtensionData;
}

// @public
export type ExtensionInputValues<
  TInputs extends {
    [name in string]: ExtensionInput<any, any>;
  },
> = {
  [InputName in keyof TInputs]: false extends TInputs[InputName]['config']['singleton']
    ? Array<Expand<ExtensionDataValues<TInputs[InputName]['extensionData']>>>
    : false extends TInputs[InputName]['config']['optional']
    ? Expand<ExtensionDataValues<TInputs[InputName]['extensionData']>>
    : Expand<
        ExtensionDataValues<TInputs[InputName]['extensionData']> | undefined
      >;
};

// @public (undocumented)
export interface ExtensionOverrides {
  // (undocumented)
  $$type: '@backstage/ExtensionOverrides';
}

// @public (undocumented)
export interface ExtensionOverridesOptions {
  // (undocumented)
  extensions: Extension<unknown>[];
}

// @public
export interface ExternalRouteRef<
  TParams extends AnyRouteRefParams = AnyRouteRefParams,
  TOptional extends boolean = boolean,
> {
  // (undocumented)
  readonly $$type: '@backstage/ExternalRouteRef';
  // (undocumented)
  readonly optional: TOptional;
  // (undocumented)
  readonly T: TParams;
}

// @public
export type FeatureFlag = {
  name: string;
  pluginId: string;
  description?: string;
};

// @public
export interface FeatureFlagsApi {
  getRegisteredFlags(): FeatureFlag[];
  isActive(name: string): boolean;
  registerFlag(flag: FeatureFlag): void;
  save(options: FeatureFlagsSaveOptions): void;
}

// @public
export const featureFlagsApiRef: ApiRef<FeatureFlagsApi>;

// @public
export type FeatureFlagsSaveOptions = {
  states: Record<string, FeatureFlagState>;
  merge?: boolean;
};

// @public
export enum FeatureFlagState {
  Active = 1,
  None = 0,
}

// @public
export type FetchApi = {
  fetch: typeof fetch;
};

// @public
export const fetchApiRef: ApiRef<FetchApi>;

// @public
export const githubAuthApiRef: ApiRef<
  OAuthApi & ProfileInfoApi & BackstageIdentityApi & SessionApi
>;

// @public
export const gitlabAuthApiRef: ApiRef<
  OAuthApi &
    OpenIdConnectApi &
    ProfileInfoApi &
    BackstageIdentityApi &
    SessionApi
>;

// @public
export const googleAuthApiRef: ApiRef<
  OAuthApi &
    OpenIdConnectApi &
    ProfileInfoApi &
    BackstageIdentityApi &
    SessionApi
>;

// @public
export type IconComponent = ComponentType<
  | {
      fontSize?: 'large' | 'small' | 'default' | 'inherit';
    }
  | {
      fontSize?: 'medium' | 'large' | 'small' | 'inherit';
    }
>;

// @public
export type IdentityApi = {
  getProfileInfo(): Promise<ProfileInfo>;
  getBackstageIdentity(): Promise<BackstageUserIdentity>;
  getCredentials(): Promise<{
    token?: string;
  }>;
  signOut(): Promise<void>;
};

// @public
export const identityApiRef: ApiRef<IdentityApi>;

// @public
export const microsoftAuthApiRef: ApiRef<
  OAuthApi &
    OpenIdConnectApi &
    ProfileInfoApi &
    BackstageIdentityApi &
    SessionApi
>;

// @public (undocumented)
export type NavTarget = {
  title: string;
  icon: IconComponent_2;
  routeRef: RouteRef<undefined>;
};

// @public
export type OAuthApi = {
  getAccessToken(
    scope?: OAuthScope,
    options?: AuthRequestOptions,
  ): Promise<string>;
};

// @public
export type OAuthRequestApi = {
  createAuthRequester<OAuthResponse>(
    options: OAuthRequesterOptions<OAuthResponse>,
  ): OAuthRequester<OAuthResponse>;
  authRequest$(): Observable<PendingOAuthRequest[]>;
};

// @public
export const oauthRequestApiRef: ApiRef<OAuthRequestApi>;

// @public
export type OAuthRequester<TAuthResponse> = (
  scopes: Set<string>,
) => Promise<TAuthResponse>;

// @public
export type OAuthRequesterOptions<TOAuthResponse> = {
  provider: AuthProviderInfo;
  onAuthRequest(scopes: Set<string>): Promise<TOAuthResponse>;
};

// @public
export type OAuthScope = string | string[];

// @public
export const oktaAuthApiRef: ApiRef<
  OAuthApi &
    OpenIdConnectApi &
    ProfileInfoApi &
    BackstageIdentityApi &
    SessionApi
>;

// @public
export const oneloginAuthApiRef: ApiRef<
  OAuthApi &
    OpenIdConnectApi &
    ProfileInfoApi &
    BackstageIdentityApi &
    SessionApi
>;

// @public
export type OpenIdConnectApi = {
  getIdToken(options?: AuthRequestOptions): Promise<string>;
};

// @public
export type PendingOAuthRequest = {
  provider: AuthProviderInfo;
  reject(): void;
  trigger(): Promise<void>;
};

// @public (undocumented)
export interface PluginOptions<
  Routes extends AnyRoutes,
  ExternalRoutes extends AnyExternalRoutes,
> {
  // (undocumented)
  extensions?: Extension<unknown>[];
  // (undocumented)
  externalRoutes?: ExternalRoutes;
  // (undocumented)
  id: string;
  // (undocumented)
  routes?: Routes;
}

// @public (undocumented)
export type PortableSchema<TOutput> = {
  parse: (input: unknown) => TOutput;
  schema: JsonObject;
};

// @public
export type ProfileInfo = {
  email?: string;
  displayName?: string;
  picture?: string;
};

// @public
export type ProfileInfoApi = {
  getProfile(options?: AuthRequestOptions): Promise<ProfileInfo | undefined>;
};

// @public
export type RouteFunc<TParams extends AnyRouteRefParams> = (
  ...[params]: TParams extends undefined
    ? readonly []
    : readonly [params: TParams]
) => string;

// @public
export interface RouteRef<
  TParams extends AnyRouteRefParams = AnyRouteRefParams,
> {
  // (undocumented)
  readonly $$type: '@backstage/RouteRef';
  // (undocumented)
  readonly T: TParams;
}

// @public
export type SessionApi = {
  signIn(): Promise<void>;
  signOut(): Promise<void>;
  sessionState$(): Observable<SessionState>;
};

// @public
export enum SessionState {
  SignedIn = 'SignedIn',
  SignedOut = 'SignedOut',
}

// @public
export interface StorageApi {
  forBucket(name: string): StorageApi;
  observe$<T extends JsonValue>(
    key: string,
  ): Observable<StorageValueSnapshot<T>>;
  remove(key: string): Promise<void>;
  set<T extends JsonValue>(key: string, data: T): Promise<void>;
  snapshot<T extends JsonValue>(key: string): StorageValueSnapshot<T>;
}

// @public
export const storageApiRef: ApiRef<StorageApi>;

// @public
export type StorageValueSnapshot<TValue extends JsonValue> =
  | {
      key: string;
      presence: 'unknown' | 'absent';
      value?: undefined;
    }
  | {
      key: string;
      presence: 'present';
      value: TValue;
    };

// @public
export interface SubRouteRef<
  TParams extends AnyRouteRefParams = AnyRouteRefParams,
> {
  // (undocumented)
  readonly $$type: '@backstage/SubRouteRef';
  // (undocumented)
  readonly path: string;
  // (undocumented)
  readonly T: TParams;
}

// @public
export type TypesToApiRefs<T> = {
  [key in keyof T]: ApiRef<T[key]>;
};

// @public
export function useRouteRef<
  TOptional extends boolean,
  TParams extends AnyRouteRefParams,
>(
  routeRef: ExternalRouteRef<TParams, TOptional>,
): TParams extends true ? RouteFunc<TParams> | undefined : RouteFunc<TParams>;

// @public
export function useRouteRef<TParams extends AnyRouteRefParams>(
  routeRef: RouteRef<TParams> | SubRouteRef<TParams>,
): RouteFunc<TParams>;

// @public
export function useRouteRefParams<Params extends AnyRouteRefParams>(
  _routeRef: RouteRef<Params> | SubRouteRef<Params>,
): Params;
```
