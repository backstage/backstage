## API Report File for "@backstage/frontend-plugin-api"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts
import { AnyRouteRefParams as AnyRouteRefParams_2 } from '@backstage/frontend-plugin-api';
import { ApiRef as ApiRef_2 } from '@backstage/frontend-plugin-api';
import { ComponentType } from 'react';
import type { Config } from '@backstage/config';
import { ConfigurableExtensionDataRef as ConfigurableExtensionDataRef_2 } from '@backstage/frontend-plugin-api';
import { Expand } from '@backstage/types';
import { ExpandRecursive } from '@backstage/types';
import { ExtensionBlueprint as ExtensionBlueprint_2 } from '@backstage/frontend-plugin-api';
import { ExtensionBlueprintParams as ExtensionBlueprintParams_2 } from '@backstage/frontend-plugin-api';
import { ExtensionDataRef as ExtensionDataRef_2 } from '@backstage/frontend-plugin-api';
import { JsonObject } from '@backstage/types';
import { JsonValue } from '@backstage/types';
import { JSX as JSX_2 } from 'react/jsx-runtime';
import { JSX as JSX_3 } from 'react';
import { Observable } from '@backstage/types';
import { PropsWithChildren } from 'react';
import { ReactNode } from 'react';
import { SwappableComponentRef as SwappableComponentRef_2 } from '@backstage/frontend-plugin-api';
import type { z } from 'zod';

// @public
export type AlertApi = {
  post(alert: AlertMessage): void;
  alert$(): Observable<AlertMessage>;
};

// @public
export const alertApiRef: ApiRef<AlertApi>;

// @public
export type AlertMessage = {
  message: string;
  severity?: 'success' | 'info' | 'warning' | 'error';
  display?: 'permanent' | 'transient';
};

// @public
export type AnalyticsApi = {
  captureEvent(event: AnalyticsEvent): void;
};

// @public
export const analyticsApiRef: ApiRef<AnalyticsApi>;

// @public
export const AnalyticsContext: (options: {
  attributes: Partial<AnalyticsContextValue>;
  children: ReactNode;
}) => JSX_2.Element;

// @public
export interface AnalyticsContextValue {
  // (undocumented)
  [key: string]: string | boolean | number | undefined;
  extensionId: string;
  pluginId: string;
}

// @public
export type AnalyticsEvent = {
  action: string;
  subject: string;
  value?: number;
  attributes?: AnalyticsEventAttributes;
  context: AnalyticsContextValue;
};

// @public
export type AnalyticsEventAttributes = {
  [attribute in string]: string | boolean | number;
};

// @public
export type AnalyticsImplementation = {
  captureEvent(event: AnalyticsEvent): void;
};

// @public
export const AnalyticsImplementationBlueprint: ExtensionBlueprint_2<{
  kind: 'analytics';
  params: <TDeps extends { [name in string]: unknown }>(
    params: AnalyticsImplementationFactory<TDeps>,
  ) => ExtensionBlueprintParams_2<AnalyticsImplementationFactory<{}>>;
  output: ExtensionDataRef_2<
    AnalyticsImplementationFactory<{}>,
    'core.analytics.factory',
    {}
  >;
  inputs: {};
  config: {};
  configInput: {};
  dataRefs: {
    factory: ConfigurableExtensionDataRef_2<
      AnalyticsImplementationFactory<{}>,
      'core.analytics.factory',
      {}
    >;
  };
}>;

// @public (undocumented)
export type AnalyticsImplementationFactory<
  Deps extends {
    [name in string]: unknown;
  } = {},
> = {
  deps: TypesToApiRefs<Deps>;
  factory(deps: Deps): AnalyticsImplementation;
};

// @public
export type AnalyticsTracker = {
  captureEvent: (
    action: string,
    subject: string,
    options?: {
      value?: number;
      attributes?: AnalyticsEventAttributes;
    },
  ) => void;
};

// @public
export type AnyApiFactory = ApiFactory<
  unknown,
  unknown,
  {
    [key in string]: unknown;
  }
>;

// @public
export type AnyApiRef = ApiRef<unknown>;

// @public @deprecated (undocumented)
export type AnyExtensionDataRef = ExtensionDataRef;

// @public
export type AnyRouteRefParams =
  | {
      [param in string]: string;
    }
  | undefined;

// @public
export const ApiBlueprint: ExtensionBlueprint_2<{
  kind: 'api';
  params: <
    TApi,
    TImpl extends TApi,
    TDeps extends { [name in string]: unknown },
  >(
    params: ApiFactory<TApi, TImpl, TDeps>,
  ) => ExtensionBlueprintParams_2<AnyApiFactory>;
  output: ExtensionDataRef_2<AnyApiFactory, 'core.api.factory', {}>;
  inputs: {};
  config: {};
  configInput: {};
  dataRefs: {
    factory: ConfigurableExtensionDataRef_2<
      AnyApiFactory,
      'core.api.factory',
      {}
    >;
  };
}>;

// @public
export type ApiFactory<
  Api,
  Impl extends Api,
  Deps extends {
    [name in string]: unknown;
  },
> = {
  api: ApiRef<Api>;
  deps: TypesToApiRefs<Deps>;
  factory(deps: Deps): Impl;
};

// @public
export type ApiHolder = {
  get<T>(api: ApiRef<T>): T | undefined;
};

// @public
export type ApiRef<T> = {
  id: string;
  T: T;
};

// @public
export type ApiRefConfig = {
  id: string;
};

// @public (undocumented)
export type AppLanguageApi = {
  getAvailableLanguages(): {
    languages: string[];
  };
  setLanguage(language?: string): void;
  getLanguage(): {
    language: string;
  };
  language$(): Observable<{
    language: string;
  }>;
};

// @public (undocumented)
export const appLanguageApiRef: ApiRef<AppLanguageApi>;

// @public
export interface AppNode {
  readonly edges: AppNodeEdges;
  readonly instance?: AppNodeInstance;
  readonly spec: AppNodeSpec;
}

// @public
export interface AppNodeEdges {
  // (undocumented)
  readonly attachedTo?: {
    node: AppNode;
    input: string;
  };
  // (undocumented)
  readonly attachments: ReadonlyMap<string, AppNode[]>;
}

// @public
export interface AppNodeInstance {
  getData<T>(ref: ExtensionDataRef<T>): T | undefined;
  getDataRefs(): Iterable<ExtensionDataRef<unknown>>;
}

// @public
export interface AppNodeSpec {
  // (undocumented)
  readonly attachTo: ExtensionAttachTo;
  // (undocumented)
  readonly config?: unknown;
  // (undocumented)
  readonly disabled: boolean;
  // (undocumented)
  readonly extension: Extension<unknown, unknown>;
  // (undocumented)
  readonly id: string;
  // (undocumented)
  readonly plugin: FrontendPlugin;
}

// @public
export const AppRootElementBlueprint: ExtensionBlueprint_2<{
  kind: 'app-root-element';
  params: {
    element: JSX.Element;
  };
  output: ExtensionDataRef_2<JSX_3, 'core.reactElement', {}>;
  inputs: {};
  config: {};
  configInput: {};
  dataRefs: never;
}>;

// @public
export type AppTheme = {
  id: string;
  title: string;
  variant: 'light' | 'dark';
  icon?: React.ReactElement;
  Provider(props: { children: ReactNode }): JSX.Element | null;
};

// @public
export type AppThemeApi = {
  getInstalledThemes(): AppTheme[];
  activeThemeId$(): Observable<string | undefined>;
  getActiveThemeId(): string | undefined;
  setActiveThemeId(themeId?: string): void;
};

// @public
export const appThemeApiRef: ApiRef<AppThemeApi>;

// @public
export interface AppTree {
  readonly nodes: ReadonlyMap<string, AppNode>;
  readonly orphans: Iterable<AppNode>;
  readonly root: AppNode;
}

// @public
export interface AppTreeApi {
  getNodesByRoutePath(routePath: string): {
    nodes: AppNode[];
  };
  getTree(): {
    tree: AppTree;
  };
}

// @public
export const appTreeApiRef: ApiRef_2<AppTreeApi>;

// @public
export const atlassianAuthApiRef: ApiRef<
  OAuthApi & ProfileInfoApi & BackstageIdentityApi & SessionApi
>;

// @public
export type AuthProviderInfo = {
  id: string;
  title: string;
  icon: IconComponent;
  message?: string;
};

// @public
export type AuthRequestOptions = {
  optional?: boolean;
  instantPopup?: boolean;
};

// @public
export type BackstageIdentityApi = {
  getBackstageIdentity(
    options?: AuthRequestOptions,
  ): Promise<BackstageIdentityResponse | undefined>;
};

// @public
export type BackstageIdentityResponse = {
  token: string;
  expiresAt?: Date;
  identity: BackstageUserIdentity;
};

// @public
export type BackstageUserIdentity = {
  type: 'user';
  userEntityRef: string;
  ownershipEntityRefs: string[];
};

// @public
export const bitbucketAuthApiRef: ApiRef<
  OAuthApi & ProfileInfoApi & BackstageIdentityApi & SessionApi
>;

// @public
export const bitbucketServerAuthApiRef: ApiRef<
  OAuthApi & ProfileInfoApi & BackstageIdentityApi & SessionApi
>;

// @public
export type ConfigApi = Config;

// @public
export const configApiRef: ApiRef<ConfigApi>;

// @public (undocumented)
export interface ConfigurableExtensionDataRef<
  TData,
  TId extends string,
  TConfig extends {
    optional?: true;
  } = {},
> extends ExtensionDataRef<TData, TId, TConfig> {
  // (undocumented)
  (t: TData): ExtensionDataValue<TData, TId>;
  // (undocumented)
  optional(): ConfigurableExtensionDataRef<
    TData,
    TId,
    TConfig & {
      optional: true;
    }
  >;
}

// @public (undocumented)
export const coreExtensionData: {
  title: ConfigurableExtensionDataRef_2<string, 'core.title', {}>;
  reactElement: ConfigurableExtensionDataRef_2<
    JSX_3.Element,
    'core.reactElement',
    {}
  >;
  routePath: ConfigurableExtensionDataRef_2<string, 'core.routing.path', {}>;
  routeRef: ConfigurableExtensionDataRef_2<
    RouteRef<AnyRouteRefParams_2>,
    'core.routing.ref',
    {}
  >;
};

// @public
export function createApiFactory<
  Api,
  Impl extends Api,
  Deps extends {
    [name in string]: unknown;
  },
>(factory: ApiFactory<Api, Impl, Deps>): ApiFactory<Api, Impl, Deps>;

// @public
export function createApiFactory<Api, Impl extends Api>(
  api: ApiRef<Api>,
  instance: Impl,
): ApiFactory<Api, Impl, {}>;

// @public
export function createApiRef<T>(config: ApiRefConfig): ApiRef<T>;

// @public
export function createExtension<
  UOutput extends ExtensionDataRef,
  TInputs extends {
    [inputName in string]: ExtensionInput;
  },
  TConfigSchema extends {
    [key: string]: (zImpl: typeof z) => z.ZodType;
  },
  UFactoryOutput extends ExtensionDataValue<any, any>,
  const TKind extends string | undefined = undefined,
  const TName extends string | undefined = undefined,
  UParentInputs extends ExtensionDataRef = ExtensionDataRef,
>(
  options: CreateExtensionOptions<
    TKind,
    TName,
    UOutput,
    TInputs,
    TConfigSchema,
    UFactoryOutput,
    UParentInputs
  >,
): OverridableExtensionDefinition<{
  config: string extends keyof TConfigSchema
    ? {}
    : {
        [key in keyof TConfigSchema]: z.infer<ReturnType<TConfigSchema[key]>>;
      };
  configInput: string extends keyof TConfigSchema
    ? {}
    : z.input<
        z.ZodObject<{
          [key in keyof TConfigSchema]: ReturnType<TConfigSchema[key]>;
        }>
      >;
  output: UOutput extends ExtensionDataRef<
    infer IData,
    infer IId,
    infer IConfig
  >
    ? ExtensionDataRef<IData, IId, IConfig>
    : never;
  inputs: TInputs;
  params: never;
  kind: string | undefined extends TKind ? undefined : TKind;
  name: string | undefined extends TName ? undefined : TName;
}>;

// @public
export function createExtensionBlueprint<
  TParams extends object | ExtensionBlueprintDefineParams,
  UOutput extends ExtensionDataRef,
  TInputs extends {
    [inputName in string]: ExtensionInput;
  },
  TConfigSchema extends {
    [key in string]: (zImpl: typeof z) => z.ZodType;
  },
  UFactoryOutput extends ExtensionDataValue<any, any>,
  TKind extends string,
  UParentInputs extends ExtensionDataRef,
  TDataRefs extends {
    [name in string]: ExtensionDataRef;
  } = never,
>(
  options: CreateExtensionBlueprintOptions<
    TKind,
    TParams,
    UOutput,
    TInputs,
    TConfigSchema,
    UFactoryOutput,
    TDataRefs,
    UParentInputs
  >,
): ExtensionBlueprint<{
  kind: TKind;
  params: TParams;
  output: UOutput extends ExtensionDataRef<
    infer IData,
    infer IId,
    infer IConfig
  >
    ? ExtensionDataRef<IData, IId, IConfig>
    : never;
  inputs: string extends keyof TInputs ? {} : TInputs;
  config: string extends keyof TConfigSchema
    ? {}
    : {
        [key in keyof TConfigSchema]: z.infer<ReturnType<TConfigSchema[key]>>;
      };
  configInput: string extends keyof TConfigSchema
    ? {}
    : z.input<
        z.ZodObject<{
          [key in keyof TConfigSchema]: ReturnType<TConfigSchema[key]>;
        }>
      >;
  dataRefs: TDataRefs;
}>;

// @public (undocumented)
export type CreateExtensionBlueprintOptions<
  TKind extends string,
  TParams extends object | ExtensionBlueprintDefineParams,
  UOutput extends ExtensionDataRef,
  TInputs extends {
    [inputName in string]: ExtensionInput;
  },
  TConfigSchema extends {
    [key in string]: (zImpl: typeof z) => z.ZodType;
  },
  UFactoryOutput extends ExtensionDataValue<any, any>,
  TDataRefs extends {
    [name in string]: ExtensionDataRef;
  },
  UParentInputs extends ExtensionDataRef,
> = {
  kind: TKind;
  attachTo: ExtensionDefinitionAttachTo<UParentInputs> &
    VerifyExtensionAttachTo<UOutput, UParentInputs>;
  disabled?: boolean;
  inputs?: TInputs;
  output: Array<UOutput>;
  config?: {
    schema: TConfigSchema;
  };
  defineParams?: TParams extends ExtensionBlueprintDefineParams
    ? TParams
    : 'The defineParams option must be a function if provided, see the docs for details';
  factory(
    params: TParams extends ExtensionBlueprintDefineParams
      ? ReturnType<TParams>['T']
      : TParams,
    context: {
      node: AppNode;
      apis: ApiHolder;
      config: {
        [key in keyof TConfigSchema]: z.infer<ReturnType<TConfigSchema[key]>>;
      };
      inputs: Expand<ResolvedExtensionInputs<TInputs>>;
    },
  ): Iterable<UFactoryOutput>;
  dataRefs?: TDataRefs;
} & VerifyExtensionFactoryOutput<UOutput, UFactoryOutput>;

// @public
export function createExtensionBlueprintParams<T extends object = object>(
  params: T,
): ExtensionBlueprintParams<T>;

// @public (undocumented)
export function createExtensionDataRef<TData>(): {
  with<TId extends string>(options: {
    id: TId;
  }): ConfigurableExtensionDataRef<TData, TId>;
};

// @public
export function createExtensionInput<
  UExtensionData extends ExtensionDataRef<
    unknown,
    string,
    {
      optional?: true;
    }
  >,
  TConfig extends {
    singleton?: boolean;
    optional?: boolean;
    internal?: boolean;
  },
>(
  extensionData: Array<UExtensionData>,
  config?: TConfig & {
    replaces?: Array<{
      id: string;
      input: string;
    }>;
  },
): ExtensionInput<
  UExtensionData,
  {
    singleton: TConfig['singleton'] extends true ? true : false;
    optional: TConfig['optional'] extends true ? true : false;
    internal: TConfig['internal'] extends true ? true : false;
  }
>;

// @public (undocumented)
export type CreateExtensionOptions<
  TKind extends string | undefined,
  TName extends string | undefined,
  UOutput extends ExtensionDataRef,
  TInputs extends {
    [inputName in string]: ExtensionInput;
  },
  TConfigSchema extends {
    [key: string]: (zImpl: typeof z) => z.ZodType;
  },
  UFactoryOutput extends ExtensionDataValue<any, any>,
  UParentInputs extends ExtensionDataRef,
> = {
  kind?: TKind;
  name?: TName;
  attachTo: ExtensionDefinitionAttachTo<UParentInputs> &
    VerifyExtensionAttachTo<UOutput, UParentInputs>;
  disabled?: boolean;
  inputs?: TInputs;
  output: Array<UOutput>;
  config?: {
    schema: TConfigSchema;
  };
  factory(context: {
    node: AppNode;
    apis: ApiHolder;
    config: {
      [key in keyof TConfigSchema]: z.infer<ReturnType<TConfigSchema[key]>>;
    };
    inputs: Expand<ResolvedExtensionInputs<TInputs>>;
  }): Iterable<UFactoryOutput>;
} & VerifyExtensionFactoryOutput<UOutput, UFactoryOutput>;

// @public
export function createExternalRouteRef<
  TParams extends
    | {
        [param in TParamKeys]: string;
      }
    | undefined = undefined,
  TParamKeys extends string = string,
>(config?: {
  readonly params?: string extends TParamKeys
    ? (keyof TParams)[]
    : TParamKeys[];
  defaultTarget?: string;
}): ExternalRouteRef<
  keyof TParams extends never
    ? undefined
    : string extends TParamKeys
    ? TParams
    : {
        [param in TParamKeys]: string;
      }
>;

// @public (undocumented)
export function createFrontendFeatureLoader(
  options: CreateFrontendFeatureLoaderOptions,
): FrontendFeatureLoader;

// @public (undocumented)
export interface CreateFrontendFeatureLoaderOptions {
  // (undocumented)
  loader(deps: { config: ConfigApi }):
    | Iterable<
        | FrontendFeature
        | FrontendFeatureLoader
        | Promise<{
            default: FrontendFeature | FrontendFeatureLoader;
          }>
      >
    | Promise<
        Iterable<
          | FrontendFeature
          | FrontendFeatureLoader
          | Promise<{
              default: FrontendFeature | FrontendFeatureLoader;
            }>
        >
      >
    | AsyncIterable<
        | FrontendFeature
        | FrontendFeatureLoader
        | {
            default: FrontendFeature | FrontendFeatureLoader;
          }
      >;
}

// @public
export function createFrontendModule<
  TId extends string,
  TExtensions extends readonly ExtensionDefinition[],
>(options: CreateFrontendModuleOptions<TId, TExtensions>): FrontendModule;

// @public (undocumented)
export interface CreateFrontendModuleOptions<
  TPluginId extends string,
  TExtensions extends readonly ExtensionDefinition[],
> {
  // (undocumented)
  extensions?: TExtensions;
  // (undocumented)
  featureFlags?: FeatureFlagConfig[];
  // (undocumented)
  pluginId: TPluginId;
}

// @public
export function createFrontendPlugin<
  TId extends string,
  TExtensions extends readonly ExtensionDefinition[],
  TRoutes extends {
    [name in string]: RouteRef | SubRouteRef;
  } = {},
  TExternalRoutes extends {
    [name in string]: ExternalRouteRef;
  } = {},
>(
  options: PluginOptions<TId, TRoutes, TExternalRoutes, TExtensions>,
): OverridableFrontendPlugin<
  TRoutes,
  TExternalRoutes,
  MakeSortedExtensionsMap<TExtensions[number], TId>
>;

// @public
export function createRouteRef<
  TParams extends
    | {
        [param in TParamKeys]: string;
      }
    | undefined = undefined,
  TParamKeys extends string = string,
>(config?: {
  readonly params?: string extends TParamKeys
    ? (keyof TParams)[]
    : TParamKeys[];
  aliasFor?: string;
}): RouteRef<
  keyof TParams extends never
    ? undefined
    : string extends TParamKeys
    ? TParams
    : {
        [param in TParamKeys]: string;
      }
>;

// @public
export function createSubRouteRef<
  Path extends string,
  ParentParams extends AnyRouteRefParams = never,
>(config: {
  path: Path;
  parent: RouteRef<ParentParams>;
}): MakeSubRouteRef<PathParams<Path>, ParentParams>;

// @public
export function createSwappableComponent<
  TInnerComponentProps extends {},
  TExternalComponentProps extends {} = TInnerComponentProps,
>(
  options: CreateSwappableComponentOptions<
    TInnerComponentProps,
    TExternalComponentProps
  >,
): {
  (props: TExternalComponentProps): JSX.Element | null;
  ref: SwappableComponentRef<TInnerComponentProps, TExternalComponentProps>;
};

// @public
export type CreateSwappableComponentOptions<
  TInnerComponentProps extends {},
  TExternalComponentProps extends {} = TInnerComponentProps,
> = {
  id: string;
  loader?:
    | (() => (props: TInnerComponentProps) => JSX.Element | null)
    | (() => Promise<(props: TInnerComponentProps) => JSX.Element | null>);
  transformProps?: (props: TExternalComponentProps) => TInnerComponentProps;
};

// @public
export function createTranslationMessages<
  TId extends string,
  TMessages extends {
    [key in string]: string;
  },
  TFull extends boolean,
>(
  options: TranslationMessagesOptions<TId, TMessages, TFull>,
): TranslationMessages<TId, TMessages, TFull>;

// @public (undocumented)
export function createTranslationRef<
  TId extends string,
  const TNestedMessages extends AnyNestedMessages,
  TTranslations extends {
    [language in string]: () => Promise<{
      default: {
        [key in keyof FlattenedMessages<TNestedMessages>]: string | null;
      };
    }>;
  },
>(
  config: TranslationRefOptions<TId, TNestedMessages, TTranslations>,
): TranslationRef<TId, FlattenedMessages<TNestedMessages>>;

// @public (undocumented)
export function createTranslationResource<
  TId extends string,
  TMessages extends {
    [key in string]: string;
  },
  TTranslations extends {
    [language in string]: () => Promise<{
      default:
        | TranslationMessages<TId>
        | {
            [key in keyof TMessages]: string | null;
          };
    }>;
  },
>(
  options: TranslationResourceOptions<TId, TMessages, TTranslations>,
): TranslationResource<TId>;

// @public
export interface DialogApi {
  show<TResult = void>(
    elementOrComponent:
      | JSX.Element
      | ((props: {
          dialog: DialogApiDialog<TResult | undefined>;
        }) => JSX.Element),
  ): DialogApiDialog<TResult | undefined>;
  showModal<TResult = void>(
    elementOrComponent:
      | JSX.Element
      | ((props: { dialog: DialogApiDialog<TResult> }) => JSX.Element),
  ): DialogApiDialog<TResult>;
}

// @public
export interface DialogApiDialog<TResult = void> {
  close(
    ...args: undefined extends TResult ? [result?: TResult] : [result: TResult]
  ): void;
  result(): Promise<TResult>;
  update(
    elementOrComponent:
      | React.JSX.Element
      | ((props: { dialog: DialogApiDialog<TResult> }) => JSX.Element),
  ): void;
}

// @public
export const dialogApiRef: ApiRef_2<DialogApi>;

// @public
export type DiscoveryApi = {
  getBaseUrl(pluginId: string): Promise<string>;
};

// @public
export const discoveryApiRef: ApiRef<DiscoveryApi>;

// @public
export type ErrorApi = {
  post(error: ErrorApiError, context?: ErrorApiErrorContext): void;
  error$(): Observable<{
    error: ErrorApiError;
    context?: ErrorApiErrorContext;
  }>;
};

// @public
export type ErrorApiError = {
  name: string;
  message: string;
  stack?: string;
};

// @public
export type ErrorApiErrorContext = {
  hidden?: boolean;
};

// @public
export const errorApiRef: ApiRef<ErrorApi>;

// @public (undocumented)
export const ErrorDisplay: {
  (props: ErrorDisplayProps): JSX.Element | null;
  ref: SwappableComponentRef_2<ErrorDisplayProps, ErrorDisplayProps>;
};

// @public (undocumented)
export type ErrorDisplayProps = {
  plugin?: FrontendPlugin;
  error: Error;
  resetError: () => void;
};

// @public (undocumented)
export interface Extension<TConfig, TConfigInput = TConfig> {
  // (undocumented)
  $$type: '@backstage/Extension';
  // (undocumented)
  readonly attachTo: ExtensionAttachToSpec;
  // (undocumented)
  readonly configSchema?: PortableSchema<TConfig, TConfigInput>;
  // (undocumented)
  readonly disabled: boolean;
  // (undocumented)
  readonly id: string;
}

// @public (undocumented)
export type ExtensionAttachTo =
  | {
      id: string;
      input: string;
    }
  | Array<{
      id: string;
      input: string;
    }>;

// @public @deprecated (undocumented)
export type ExtensionAttachToSpec = ExtensionAttachTo;

// @public (undocumented)
export interface ExtensionBlueprint<
  T extends ExtensionBlueprintParameters = ExtensionBlueprintParameters,
> {
  // (undocumented)
  dataRefs: T['dataRefs'];
  // (undocumented)
  make<
    TName extends string | undefined,
    TParamsInput extends AnyParamsInput_2<NonNullable<T['params']>>,
    UParentInputs extends ExtensionDataRef,
  >(args: {
    name?: TName;
    attachTo?: ExtensionDefinitionAttachTo<UParentInputs> &
      VerifyExtensionAttachTo<NonNullable<T['output']>, UParentInputs>;
    disabled?: boolean;
    params: TParamsInput extends ExtensionBlueprintDefineParams
      ? TParamsInput
      : T['params'] extends ExtensionBlueprintDefineParams
      ? 'Error: This blueprint uses advanced parameter types and requires you to pass parameters as using the following callback syntax: `<blueprint>.make({ params: defineParams => defineParams(<params>) })`'
      : T['params'];
  }): OverridableExtensionDefinition<{
    kind: T['kind'];
    name: string | undefined extends TName ? undefined : TName;
    config: T['config'];
    configInput: T['configInput'];
    output: T['output'];
    inputs: T['inputs'];
    params: T['params'];
  }>;
  makeWithOverrides<
    TName extends string | undefined,
    TExtensionConfigSchema extends {
      [key in string]: (zImpl: typeof z) => z.ZodType;
    },
    UFactoryOutput extends ExtensionDataValue<any, any>,
    UNewOutput extends ExtensionDataRef,
    UParentInputs extends ExtensionDataRef,
    TExtraInputs extends {
      [inputName in string]: ExtensionInput;
    } = {},
  >(args: {
    name?: TName;
    attachTo?: ExtensionDefinitionAttachTo<UParentInputs> &
      VerifyExtensionAttachTo<
        ExtensionDataRef extends UNewOutput
          ? NonNullable<T['output']>
          : UNewOutput,
        UParentInputs
      >;
    disabled?: boolean;
    inputs?: TExtraInputs & {
      [KName in keyof T['inputs']]?: `Error: Input '${KName &
        string}' is already defined in parent definition`;
    };
    output?: Array<UNewOutput>;
    config?: {
      schema: TExtensionConfigSchema & {
        [KName in keyof T['config']]?: `Error: Config key '${KName &
          string}' is already defined in parent schema`;
      };
    };
    factory(
      originalFactory: <
        TParamsInput extends AnyParamsInput_2<NonNullable<T['params']>>,
      >(
        params: TParamsInput extends ExtensionBlueprintDefineParams
          ? TParamsInput
          : T['params'] extends ExtensionBlueprintDefineParams
          ? 'Error: This blueprint uses advanced parameter types and requires you to pass parameters as using the following callback syntax: `originalFactory(defineParams => defineParams(<params>))`'
          : T['params'],
        context?: {
          config?: T['config'];
          inputs?: ResolvedInputValueOverrides<NonNullable<T['inputs']>>;
        },
      ) => ExtensionDataContainer<NonNullable<T['output']>>,
      context: {
        node: AppNode;
        apis: ApiHolder;
        config: T['config'] & {
          [key in keyof TExtensionConfigSchema]: z.infer<
            ReturnType<TExtensionConfigSchema[key]>
          >;
        };
        inputs: Expand<ResolvedExtensionInputs<T['inputs'] & TExtraInputs>>;
      },
    ): Iterable<UFactoryOutput> &
      VerifyExtensionFactoryOutput<
        ExtensionDataRef extends UNewOutput
          ? NonNullable<T['output']>
          : UNewOutput,
        UFactoryOutput
      >;
  }): OverridableExtensionDefinition<{
    config: Expand<
      (string extends keyof TExtensionConfigSchema
        ? {}
        : {
            [key in keyof TExtensionConfigSchema]: z.infer<
              ReturnType<TExtensionConfigSchema[key]>
            >;
          }) &
        T['config']
    >;
    configInput: Expand<
      (string extends keyof TExtensionConfigSchema
        ? {}
        : z.input<
            z.ZodObject<{
              [key in keyof TExtensionConfigSchema]: ReturnType<
                TExtensionConfigSchema[key]
              >;
            }>
          >) &
        T['configInput']
    >;
    output: ExtensionDataRef extends UNewOutput ? T['output'] : UNewOutput;
    inputs: Expand<T['inputs'] & TExtraInputs>;
    kind: T['kind'];
    name: string | undefined extends TName ? undefined : TName;
    params: T['params'];
  }>;
}

// @public
export type ExtensionBlueprintDefineParams<
  TParams extends object = object,
  TInput = any,
> = (params: TInput) => ExtensionBlueprintParams<TParams>;

// @public (undocumented)
export type ExtensionBlueprintParameters = {
  kind: string;
  params?: object | ExtensionBlueprintDefineParams;
  configInput?: {
    [K in string]: any;
  };
  config?: {
    [K in string]: any;
  };
  output?: ExtensionDataRef;
  inputs?: {
    [KName in string]: ExtensionInput;
  };
  dataRefs?: {
    [name in string]: ExtensionDataRef;
  };
};

// @public
export type ExtensionBlueprintParams<T extends object = object> = {
  $$type: '@backstage/BlueprintParams';
  T: T;
};

// @public (undocumented)
export function ExtensionBoundary(props: ExtensionBoundaryProps): JSX_2.Element;

// @public (undocumented)
export namespace ExtensionBoundary {
  // (undocumented)
  export function lazy(
    appNode: AppNode,
    loader: () => Promise<JSX.Element>,
  ): JSX.Element;
  // (undocumented)
  export function lazyComponent<TProps extends {}>(
    appNode: AppNode,
    loader: () => Promise<(props: TProps) => JSX.Element>,
  ): (props: TProps) => JSX.Element;
}

// @public (undocumented)
export interface ExtensionBoundaryProps {
  // (undocumented)
  children: ReactNode;
  // (undocumented)
  errorPresentation?: 'error-api' | 'error-display';
  // (undocumented)
  node: AppNode;
}

// @public (undocumented)
export type ExtensionDataContainer<UExtensionData extends ExtensionDataRef> =
  Iterable<
    UExtensionData extends ExtensionDataRef<
      infer IData,
      infer IId,
      infer IConfig
    >
      ? IConfig['optional'] extends true
        ? never
        : ExtensionDataValue<IData, IId>
      : never
  > & {
    get<TId extends UExtensionData['id']>(
      ref: ExtensionDataRef<any, TId, any>,
    ): UExtensionData extends ExtensionDataRef<infer IData, TId, infer IConfig>
      ? IConfig['optional'] extends true
        ? IData | undefined
        : IData
      : never;
  };

// @public (undocumented)
export type ExtensionDataRef<
  TData = unknown,
  TId extends string = string,
  TConfig extends {
    optional?: true;
  } = {
    optional?: true;
  },
> = {
  readonly $$type: '@backstage/ExtensionDataRef';
  readonly id: TId;
  readonly T: TData;
  readonly config: TConfig;
};

// @public (undocumented)
export type ExtensionDataRefToValue<TDataRef extends AnyExtensionDataRef> =
  TDataRef extends ExtensionDataRef<infer IData, infer IId, any>
    ? ExtensionDataValue<IData, IId>
    : never;

// @public (undocumented)
export type ExtensionDataValue<TData, TId extends string> = {
  readonly $$type: '@backstage/ExtensionDataValue';
  readonly id: TId;
  readonly value: TData;
};

// @public (undocumented)
export interface ExtensionDefinition<
  TParams extends ExtensionDefinitionParameters = ExtensionDefinitionParameters,
> {
  // (undocumented)
  $$type: '@backstage/ExtensionDefinition';
  // (undocumented)
  readonly T: TParams;
}

// @public
export type ExtensionDefinitionAttachTo<
  UParentInputs extends ExtensionDataRef = ExtensionDataRef,
> =
  | {
      id: string;
      input: string;
      relative?: never;
    }
  | {
      relative: {
        kind?: string;
        name?: string;
      };
      input: string;
      id?: never;
    }
  | ExtensionInput<UParentInputs>;

// @public (undocumented)
export type ExtensionDefinitionParameters = {
  kind?: string;
  name?: string;
  configInput?: {
    [K in string]: any;
  };
  config?: {
    [K in string]: any;
  };
  output?: ExtensionDataRef;
  inputs?: {
    [KName in string]: ExtensionInput;
  };
  params?: object | ExtensionBlueprintDefineParams;
};

// @public (undocumented)
export type ExtensionFactoryMiddleware = (
  originalFactory: (contextOverrides?: {
    config?: JsonObject;
  }) => ExtensionDataContainer<ExtensionDataRef>,
  context: {
    node: AppNode;
    apis: ApiHolder;
    config?: JsonObject;
  },
) => Iterable<ExtensionDataValue<any, any>>;

// @public (undocumented)
export interface ExtensionInput<
  UExtensionData extends ExtensionDataRef<
    unknown,
    string,
    {
      optional?: true;
    }
  > = ExtensionDataRef,
  TConfig extends {
    singleton: boolean;
    optional: boolean;
    internal?: boolean;
  } = {
    singleton: boolean;
    optional: boolean;
    internal?: boolean;
  },
> {
  // (undocumented)
  readonly $$type: '@backstage/ExtensionInput';
  // (undocumented)
  readonly config: TConfig;
  // (undocumented)
  readonly extensionData: Array<UExtensionData>;
  // (undocumented)
  readonly replaces?: Array<{
    id: string;
    input: string;
  }>;
}

// @public
export interface ExternalRouteRef<
  TParams extends AnyRouteRefParams = AnyRouteRefParams,
> {
  // (undocumented)
  readonly $$type: '@backstage/ExternalRouteRef';
  // (undocumented)
  readonly T: TParams;
}

// @public
export type FeatureFlag = {
  name: string;
  pluginId: string;
  description?: string;
};

// @public
export type FeatureFlagConfig = {
  name: string;
};

// @public
export interface FeatureFlagsApi {
  getRegisteredFlags(): FeatureFlag[];
  isActive(name: string): boolean;
  registerFlag(flag: FeatureFlag): void;
  save(options: FeatureFlagsSaveOptions): void;
}

// @public
export const featureFlagsApiRef: ApiRef<FeatureFlagsApi>;

// @public
export type FeatureFlagsSaveOptions = {
  states: Record<string, FeatureFlagState>;
  merge?: boolean;
};

// @public
export const FeatureFlagState: {
  readonly None: 0;
  readonly Active: 1;
};

// @public (undocumented)
export type FeatureFlagState =
  (typeof FeatureFlagState)[keyof typeof FeatureFlagState];

// @public (undocumented)
export namespace FeatureFlagState {
  // (undocumented)
  export type Active = typeof FeatureFlagState.Active;
  // (undocumented)
  export type None = typeof FeatureFlagState.None;
}

// @public
export type FetchApi = {
  fetch: typeof fetch;
};

// @public
export const fetchApiRef: ApiRef<FetchApi>;

// @public (undocumented)
export type FrontendFeature = FrontendPlugin | FrontendModule;

// @public (undocumented)
export interface FrontendFeatureLoader {
  // (undocumented)
  readonly $$type: '@backstage/FrontendFeatureLoader';
}

// @public (undocumented)
export interface FrontendModule {
  // (undocumented)
  readonly $$type: '@backstage/FrontendModule';
  // (undocumented)
  readonly pluginId: string;
}

// @public (undocumented)
export interface FrontendPlugin<
  TRoutes extends {
    [name in string]: RouteRef | SubRouteRef;
  } = {
    [name in string]: RouteRef | SubRouteRef;
  },
  TExternalRoutes extends {
    [name in string]: ExternalRouteRef;
  } = {
    [name in string]: ExternalRouteRef;
  },
> {
  // (undocumented)
  readonly $$type: '@backstage/FrontendPlugin';
  // (undocumented)
  readonly externalRoutes: TExternalRoutes;
  // @deprecated
  readonly id: string;
  info(): Promise<FrontendPluginInfo>;
  readonly pluginId: string;
  // (undocumented)
  readonly routes: TRoutes;
}

// @public
export interface FrontendPluginInfo {
  description?: string;
  links?: Array<{
    title: string;
    url: string;
  }>;
  ownerEntityRefs?: string[];
  packageName?: string;
  version?: string;
}

// @public
export type FrontendPluginInfoOptions = {
  packageJson?: () => Promise<
    {
      name: string;
    } & JsonObject
  >;
  manifest?: () => Promise<JsonObject>;
};

// @public
export const githubAuthApiRef: ApiRef<
  OAuthApi & ProfileInfoApi & BackstageIdentityApi & SessionApi
>;

// @public
export const gitlabAuthApiRef: ApiRef<
  OAuthApi &
    OpenIdConnectApi &
    ProfileInfoApi &
    BackstageIdentityApi &
    SessionApi
>;

// @public
export const googleAuthApiRef: ApiRef<
  OAuthApi &
    OpenIdConnectApi &
    ProfileInfoApi &
    BackstageIdentityApi &
    SessionApi
>;

// @public
export type IconComponent = ComponentType<{
  fontSize?: 'medium' | 'large' | 'small' | 'inherit';
}>;

// @public
export interface IconsApi {
  // (undocumented)
  getIcon(key: string): IconComponent | undefined;
  // (undocumented)
  listIconKeys(): string[];
}

// @public
export const iconsApiRef: ApiRef_2<IconsApi>;

// @public
export type IdentityApi = {
  getProfileInfo(): Promise<ProfileInfo>;
  getBackstageIdentity(): Promise<BackstageUserIdentity>;
  getCredentials(): Promise<{
    token?: string;
  }>;
  signOut(): Promise<void>;
};

// @public
export const identityApiRef: ApiRef<IdentityApi>;

// @public
export const microsoftAuthApiRef: ApiRef<
  OAuthApi &
    OpenIdConnectApi &
    ProfileInfoApi &
    BackstageIdentityApi &
    SessionApi
>;

// @public
export const NavItemBlueprint: ExtensionBlueprint_2<{
  kind: 'nav-item';
  params: {
    title: string;
    icon: IconComponent;
    routeRef: RouteRef<undefined>;
  };
  output: ExtensionDataRef_2<
    {
      title: string;
      icon: IconComponent;
      routeRef: RouteRef<undefined>;
    },
    'core.nav-item.target',
    {}
  >;
  inputs: {};
  config: {};
  configInput: {};
  dataRefs: {
    target: ConfigurableExtensionDataRef_2<
      {
        title: string;
        icon: IconComponent;
        routeRef: RouteRef<undefined>;
      },
      'core.nav-item.target',
      {}
    >;
  };
}>;

// @public (undocumented)
export const NotFoundErrorPage: {
  (props: NotFoundErrorPageProps): JSX.Element | null;
  ref: SwappableComponentRef_2<NotFoundErrorPageProps, NotFoundErrorPageProps>;
};

// @public (undocumented)
export type NotFoundErrorPageProps = {
  children?: ReactNode;
};

// @public
export type OAuthApi = {
  getAccessToken(
    scope?: OAuthScope,
    options?: AuthRequestOptions,
  ): Promise<string>;
};

// @public
export type OAuthRequestApi = {
  createAuthRequester<OAuthResponse>(
    options: OAuthRequesterOptions<OAuthResponse>,
  ): OAuthRequester<OAuthResponse>;
  authRequest$(): Observable<PendingOAuthRequest[]>;
};

// @public
export const oauthRequestApiRef: ApiRef<OAuthRequestApi>;

// @public
export type OAuthRequester<TAuthResponse> = (
  scopes: Set<string>,
) => Promise<TAuthResponse>;

// @public
export type OAuthRequesterOptions<TOAuthResponse> = {
  provider: AuthProviderInfo;
  onAuthRequest(scopes: Set<string>): Promise<TOAuthResponse>;
};

// @public
export type OAuthScope = string | string[];

// @public
export const oktaAuthApiRef: ApiRef<
  OAuthApi &
    OpenIdConnectApi &
    ProfileInfoApi &
    BackstageIdentityApi &
    SessionApi
>;

// @public
export const oneloginAuthApiRef: ApiRef<
  OAuthApi &
    OpenIdConnectApi &
    ProfileInfoApi &
    BackstageIdentityApi &
    SessionApi
>;

// @public
export type OpenIdConnectApi = {
  getIdToken(options?: AuthRequestOptions): Promise<string>;
};

// @public
export const openshiftAuthApiRef: ApiRef<
  OAuthApi & ProfileInfoApi & BackstageIdentityApi & SessionApi
>;

// @public (undocumented)
export interface OverridableExtensionDefinition<
  T extends ExtensionDefinitionParameters = ExtensionDefinitionParameters,
> extends ExtensionDefinition<T> {
  readonly inputs: {
    [K in keyof T['inputs']]: ExtensionInput<
      T['inputs'][K] extends ExtensionInput<infer IData> ? IData : never
    >;
  };
  // (undocumented)
  override<
    TExtensionConfigSchema extends {
      [key in string]: (zImpl: typeof z) => z.ZodType;
    },
    UFactoryOutput extends ExtensionDataValue<any, any>,
    UNewOutput extends ExtensionDataRef,
    TExtraInputs extends {
      [inputName in string]: ExtensionInput;
    },
    TParamsInput extends AnyParamsInput<NonNullable<T['params']>>,
    UParentInputs extends ExtensionDataRef,
  >(
    args: Expand<
      {
        attachTo?: ExtensionDefinitionAttachTo<UParentInputs> &
          VerifyExtensionAttachTo<
            ExtensionDataRef extends UNewOutput
              ? NonNullable<T['output']>
              : UNewOutput,
            UParentInputs
          >;
        disabled?: boolean;
        inputs?: TExtraInputs & {
          [KName in keyof T['inputs']]?: `Error: Input '${KName &
            string}' is already defined in parent definition`;
        };
        output?: Array<UNewOutput>;
        config?: {
          schema: TExtensionConfigSchema & {
            [KName in keyof T['config']]?: `Error: Config key '${KName &
              string}' is already defined in parent schema`;
          };
        };
        factory?(
          originalFactory: <
            TFactoryParamsReturn extends AnyParamsInput<
              NonNullable<T['params']>
            >,
          >(
            context?: Expand<
              {
                config?: T['config'];
                inputs?: ResolvedInputValueOverrides<NonNullable<T['inputs']>>;
              } & ([T['params']] extends [never]
                ? {}
                : {
                    params?: TFactoryParamsReturn extends ExtensionBlueprintDefineParams
                      ? TFactoryParamsReturn
                      : T['params'] extends ExtensionBlueprintDefineParams
                      ? 'Error: This blueprint uses advanced parameter types and requires you to pass parameters as using the following callback syntax: `originalFactory(defineParams => defineParams(<params>))`'
                      : Partial<T['params']>;
                  })
            >,
          ) => ExtensionDataContainer<NonNullable<T['output']>>,
          context: {
            node: AppNode;
            apis: ApiHolder;
            config: T['config'] & {
              [key in keyof TExtensionConfigSchema]: z.infer<
                ReturnType<TExtensionConfigSchema[key]>
              >;
            };
            inputs: Expand<ResolvedExtensionInputs<T['inputs'] & TExtraInputs>>;
          },
        ): Iterable<UFactoryOutput>;
      } & ([T['params']] extends [never]
        ? {}
        : {
            params?: TParamsInput extends ExtensionBlueprintDefineParams
              ? TParamsInput
              : T['params'] extends ExtensionBlueprintDefineParams
              ? 'Error: This blueprint uses advanced parameter types and requires you to pass parameters as using the following callback syntax: `originalFactory(defineParams => defineParams(<params>))`'
              : Partial<T['params']>;
          })
    > &
      VerifyExtensionFactoryOutput<
        ExtensionDataRef extends UNewOutput
          ? NonNullable<T['output']>
          : UNewOutput,
        UFactoryOutput
      >,
  ): OverridableExtensionDefinition<{
    kind: T['kind'];
    name: T['name'];
    output: ExtensionDataRef extends UNewOutput ? T['output'] : UNewOutput;
    inputs: T['inputs'] & TExtraInputs;
    config: T['config'] & {
      [key in keyof TExtensionConfigSchema]: z.infer<
        ReturnType<TExtensionConfigSchema[key]>
      >;
    };
    configInput: T['configInput'] &
      z.input<
        z.ZodObject<{
          [key in keyof TExtensionConfigSchema]: ReturnType<
            TExtensionConfigSchema[key]
          >;
        }>
      >;
  }>;
}

// @public
export interface OverridableFrontendPlugin<
  TRoutes extends {
    [name in string]: RouteRef | SubRouteRef;
  } = {
    [name in string]: RouteRef | SubRouteRef;
  },
  TExternalRoutes extends {
    [name in string]: ExternalRouteRef;
  } = {
    [name in string]: ExternalRouteRef;
  },
  TExtensionMap extends {
    [id in string]: ExtensionDefinition;
  } = {
    [id in string]: ExtensionDefinition;
  },
> extends FrontendPlugin<TRoutes, TExternalRoutes> {
  // (undocumented)
  getExtension<TId extends keyof TExtensionMap>(
    id: TId,
  ): OverridableExtensionDefinition<TExtensionMap[TId]['T']>;
  // (undocumented)
  withOverrides(options: {
    extensions: Array<ExtensionDefinition>;
    info?: FrontendPluginInfoOptions;
  }): OverridableFrontendPlugin<TRoutes, TExternalRoutes, TExtensionMap>;
}

// @public
export const PageBlueprint: ExtensionBlueprint_2<{
  kind: 'page';
  params: {
    defaultPath?: [Error: `Use the 'path' param instead`];
    path: string;
    loader: () => Promise<JSX.Element>;
    routeRef?: RouteRef;
  };
  output:
    | ExtensionDataRef_2<string, 'core.routing.path', {}>
    | ExtensionDataRef_2<JSX_3, 'core.reactElement', {}>
    | ExtensionDataRef_2<
        RouteRef<AnyRouteRefParams_2>,
        'core.routing.ref',
        {
          optional: true;
        }
      >;
  inputs: {};
  config: {
    path: string | undefined;
  };
  configInput: {
    path?: string | undefined;
  };
  dataRefs: never;
}>;

// @public
export type PendingOAuthRequest = {
  provider: AuthProviderInfo;
  reject(): void;
  trigger(): Promise<void>;
};

// @public (undocumented)
export interface PluginOptions<
  TId extends string,
  TRoutes extends {
    [name in string]: RouteRef | SubRouteRef;
  },
  TExternalRoutes extends {
    [name in string]: ExternalRouteRef;
  },
  TExtensions extends readonly ExtensionDefinition[],
> {
  // (undocumented)
  extensions?: TExtensions;
  // (undocumented)
  externalRoutes?: TExternalRoutes;
  // (undocumented)
  featureFlags?: FeatureFlagConfig[];
  // (undocumented)
  info?: FrontendPluginInfoOptions;
  // (undocumented)
  pluginId: TId;
  // (undocumented)
  routes?: TRoutes;
}

// @public (undocumented)
export type PortableSchema<TOutput, TInput = TOutput> = {
  parse: (input: TInput) => TOutput;
  schema: JsonObject;
};

// @public
export type ProfileInfo = {
  email?: string;
  displayName?: string;
  picture?: string;
};

// @public
export type ProfileInfoApi = {
  getProfile(options?: AuthRequestOptions): Promise<ProfileInfo | undefined>;
};

// @public (undocumented)
export const Progress: {
  (props: ProgressProps): JSX.Element | null;
  ref: SwappableComponentRef_2<ProgressProps, ProgressProps>;
};

// @public (undocumented)
export type ProgressProps = {};

// @public
export type ResolvedExtensionInput<TExtensionInput extends ExtensionInput> =
  TExtensionInput['extensionData'] extends Array<ExtensionDataRef>
    ? {
        node: AppNode;
      } & ExtensionDataContainer<TExtensionInput['extensionData'][number]>
    : never;

// @public
export type ResolvedExtensionInputs<
  TInputs extends {
    [name in string]: ExtensionInput;
  },
> = {
  [InputName in keyof TInputs]: false extends TInputs[InputName]['config']['singleton']
    ? Array<Expand<ResolvedExtensionInput<TInputs[InputName]>>>
    : false extends TInputs[InputName]['config']['optional']
    ? Expand<ResolvedExtensionInput<TInputs[InputName]>>
    : Expand<ResolvedExtensionInput<TInputs[InputName]> | undefined>;
};

// @public
export type RouteFunc<TParams extends AnyRouteRefParams> = (
  ...[params]: TParams extends undefined
    ? readonly []
    : readonly [params: TParams]
) => string;

// @public
export interface RouteRef<
  TParams extends AnyRouteRefParams = AnyRouteRefParams,
> {
  // (undocumented)
  readonly $$type: '@backstage/RouteRef';
  // (undocumented)
  readonly T: TParams;
}

// @public (undocumented)
export interface RouteResolutionApi {
  // (undocumented)
  resolve<TParams extends AnyRouteRefParams>(
    anyRouteRef:
      | RouteRef<TParams>
      | SubRouteRef<TParams>
      | ExternalRouteRef<TParams>,
    options?: {
      sourcePath?: string;
    },
  ): RouteFunc<TParams> | undefined;
}

// @public
export const routeResolutionApiRef: ApiRef_2<RouteResolutionApi>;

// @public
export type SessionApi = {
  signIn(): Promise<void>;
  signOut(): Promise<void>;
  sessionState$(): Observable<SessionState>;
};

// @public
export const SessionState: {
  readonly SignedIn: 'SignedIn';
  readonly SignedOut: 'SignedOut';
};

// @public (undocumented)
export type SessionState = (typeof SessionState)[keyof typeof SessionState];

// @public (undocumented)
export namespace SessionState {
  // (undocumented)
  export type SignedIn = typeof SessionState.SignedIn;
  // (undocumented)
  export type SignedOut = typeof SessionState.SignedOut;
}

// @public
export interface StorageApi {
  forBucket(name: string): StorageApi;
  observe$<T extends JsonValue>(
    key: string,
  ): Observable<StorageValueSnapshot<T>>;
  remove(key: string): Promise<void>;
  set<T extends JsonValue>(key: string, data: T): Promise<void>;
  snapshot<T extends JsonValue>(key: string): StorageValueSnapshot<T>;
}

// @public
export const storageApiRef: ApiRef<StorageApi>;

// @public
export type StorageValueSnapshot<TValue extends JsonValue> =
  | {
      key: string;
      presence: 'unknown' | 'absent';
      value?: undefined;
    }
  | {
      key: string;
      presence: 'present';
      value: TValue;
    };

// @public
export interface SubRouteRef<
  TParams extends AnyRouteRefParams = AnyRouteRefParams,
> {
  // (undocumented)
  readonly $$type: '@backstage/SubRouteRef';
  // (undocumented)
  readonly path: string;
  // (undocumented)
  readonly T: TParams;
}

// @public (undocumented)
export type SwappableComponentRef<
  TInnerComponentProps extends {} = {},
  TExternalComponentProps extends {} = TInnerComponentProps,
> = {
  id: string;
  TProps: TInnerComponentProps;
  TExternalProps: TExternalComponentProps;
  $$type: '@backstage/SwappableComponentRef';
};

// @public
export interface SwappableComponentsApi {
  // (undocumented)
  getComponent<
    TInnerComponentProps extends {},
    TExternalComponentProps extends {} = TInnerComponentProps,
  >(
    ref: SwappableComponentRef<TInnerComponentProps, TExternalComponentProps>,
  ): (props: TInnerComponentProps) => JSX.Element | null;
}

// @public
export const swappableComponentsApiRef: ApiRef_2<SwappableComponentsApi>;

// @public (undocumented)
export type TranslationApi = {
  getTranslation<
    TMessages extends {
      [key in string]: string;
    },
  >(
    translationRef: TranslationRef<string, TMessages>,
  ): TranslationSnapshot<TMessages>;
  translation$<
    TMessages extends {
      [key in string]: string;
    },
  >(
    translationRef: TranslationRef<string, TMessages>,
  ): Observable<TranslationSnapshot<TMessages>>;
};

// @public (undocumented)
export const translationApiRef: ApiRef<TranslationApi>;

// @public (undocumented)
export type TranslationFunction<
  TMessages extends {
    [key in string]: string;
  },
> = CollapsedMessages<TMessages> extends infer IMessages extends {
  [key in string]: string;
}
  ? {
      <TKey extends keyof IMessages>(
        key: TKey,
        ...[args]: TranslationFunctionOptions<
          NestedMessageKeys<TKey, IMessages>,
          PluralKeys<TMessages>,
          IMessages,
          string
        >
      ): IMessages[TKey];
      <TKey extends keyof IMessages>(
        key: TKey,
        ...[args]: TranslationFunctionOptions<
          NestedMessageKeys<TKey, IMessages>,
          PluralKeys<TMessages>,
          IMessages,
          string | JSX_3.Element
        >
      ): JSX_3.Element;
    }
  : never;

// @public
export interface TranslationMessages<
  TId extends string = string,
  TMessages extends {
    [key in string]: string;
  } = {
    [key in string]: string;
  },
  TFull extends boolean = boolean,
> {
  // (undocumented)
  $$type: '@backstage/TranslationMessages';
  full: TFull;
  id: TId;
  messages: TMessages;
}

// @public
export interface TranslationMessagesOptions<
  TId extends string,
  TMessages extends {
    [key in string]: string;
  },
  TFull extends boolean,
> {
  // (undocumented)
  full?: TFull;
  // (undocumented)
  messages: false extends TFull
    ? {
        [key in keyof TMessages]?: string | null;
      }
    : {
        [key in keyof TMessages]: string | null;
      };
  // (undocumented)
  ref: TranslationRef<TId, TMessages>;
}

// @public (undocumented)
export interface TranslationRef<
  TId extends string = string,
  TMessages extends {
    [key in string]: string;
  } = {
    [key in string]: string;
  },
> {
  // (undocumented)
  $$type: '@backstage/TranslationRef';
  // (undocumented)
  id: TId;
  // (undocumented)
  T: TMessages;
}

// @public (undocumented)
export interface TranslationRefOptions<
  TId extends string,
  TNestedMessages extends AnyNestedMessages,
  TTranslations extends {
    [language in string]: () => Promise<{
      default: {
        [key in keyof FlattenedMessages<TNestedMessages>]: string | null;
      };
    }>;
  },
> {
  // (undocumented)
  id: TId;
  // (undocumented)
  messages: TNestedMessages;
  // (undocumented)
  translations?: TTranslations;
}

// @public (undocumented)
export interface TranslationResource<TId extends string = string> {
  // (undocumented)
  $$type: '@backstage/TranslationResource';
  // (undocumented)
  id: TId;
}

// @public (undocumented)
export interface TranslationResourceOptions<
  TId extends string,
  TMessages extends {
    [key in string]: string;
  },
  TTranslations extends {
    [language in string]: () => Promise<{
      default:
        | TranslationMessages<TId>
        | {
            [key in keyof TMessages]: string | null;
          };
    }>;
  },
> {
  // (undocumented)
  ref: TranslationRef<TId, TMessages>;
  // (undocumented)
  translations: TTranslations;
}

// @public (undocumented)
export type TranslationSnapshot<
  TMessages extends {
    [key in string]: string;
  },
> =
  | {
      ready: false;
    }
  | {
      ready: true;
      t: TranslationFunction<TMessages>;
    };

// @public
export type TypesToApiRefs<T> = {
  [key in keyof T]: ApiRef<T[key]>;
};

// @public
export function useAnalytics(): AnalyticsTracker;

// @public
export function useApi<T>(apiRef: ApiRef<T>): T;

// @public
export function useApiHolder(): ApiHolder;

// @public
export function useAppNode(): AppNode | undefined;

// @public
export function useRouteRef<TParams extends AnyRouteRefParams>(
  routeRef:
    | RouteRef<TParams>
    | SubRouteRef<TParams>
    | ExternalRouteRef<TParams>,
): RouteFunc<TParams> | undefined;

// @public
export function useRouteRefParams<Params extends AnyRouteRefParams>(
  _routeRef: RouteRef<Params> | SubRouteRef<Params>,
): Params;

// @public (undocumented)
export const useTranslationRef: <TMessages extends { [key in string]: string }>(
  translationRef: TranslationRef<string, TMessages>,
) => {
  t: TranslationFunction<TMessages>;
};

// @public
export const vmwareCloudAuthApiRef: ApiRef<
  OAuthApi &
    OpenIdConnectApi &
    ProfileInfoApi &
    BackstageIdentityApi &
    SessionApi
>;

// @public
export function withApis<T extends {}>(
  apis: TypesToApiRefs<T>,
): <TProps extends T>(
  WrappedComponent: ComponentType<TProps>,
) => {
  (props: PropsWithChildren<Omit<TProps, keyof T>>): JSX_2.Element;
  displayName: string;
};
```
