## API Report File for "@backstage/frontend-plugin-api"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts
import { AlertApi } from '@backstage/core-plugin-api';
import { alertApiRef } from '@backstage/core-plugin-api';
import { AlertMessage } from '@backstage/core-plugin-api';
import { AnyApiFactory } from '@backstage/core-plugin-api';
import { AnyApiRef } from '@backstage/core-plugin-api';
import { ApiFactory } from '@backstage/core-plugin-api';
import { ApiHolder } from '@backstage/core-plugin-api';
import { ApiRef } from '@backstage/core-plugin-api';
import { ApiRefConfig } from '@backstage/core-plugin-api';
import { AppTheme } from '@backstage/core-plugin-api';
import { AppThemeApi } from '@backstage/core-plugin-api';
import { appThemeApiRef } from '@backstage/core-plugin-api';
import { atlassianAuthApiRef } from '@backstage/core-plugin-api';
import { AuthProviderInfo } from '@backstage/core-plugin-api';
import { AuthRequestOptions } from '@backstage/core-plugin-api';
import { BackstageIdentityApi } from '@backstage/core-plugin-api';
import { BackstageIdentityResponse } from '@backstage/core-plugin-api';
import { BackstageUserIdentity } from '@backstage/core-plugin-api';
import { bitbucketAuthApiRef } from '@backstage/core-plugin-api';
import { bitbucketServerAuthApiRef } from '@backstage/core-plugin-api';
import { ComponentType } from 'react';
import { ConfigApi } from '@backstage/core-plugin-api';
import { configApiRef } from '@backstage/core-plugin-api';
import { createApiFactory } from '@backstage/core-plugin-api';
import { createApiRef } from '@backstage/core-plugin-api';
import { createTranslationMessages } from '@backstage/core-plugin-api/alpha';
import { createTranslationRef } from '@backstage/core-plugin-api/alpha';
import { createTranslationResource } from '@backstage/core-plugin-api/alpha';
import { DiscoveryApi } from '@backstage/core-plugin-api';
import { discoveryApiRef } from '@backstage/core-plugin-api';
import { ErrorApi } from '@backstage/core-plugin-api';
import { ErrorApiError } from '@backstage/core-plugin-api';
import { ErrorApiErrorContext } from '@backstage/core-plugin-api';
import { errorApiRef } from '@backstage/core-plugin-api';
import { Expand } from '@backstage/types';
import { FeatureFlag } from '@backstage/core-plugin-api';
import { FeatureFlagsApi } from '@backstage/core-plugin-api';
import { featureFlagsApiRef } from '@backstage/core-plugin-api';
import { FeatureFlagsSaveOptions } from '@backstage/core-plugin-api';
import { FeatureFlagState } from '@backstage/core-plugin-api';
import { FetchApi } from '@backstage/core-plugin-api';
import { fetchApiRef } from '@backstage/core-plugin-api';
import { githubAuthApiRef } from '@backstage/core-plugin-api';
import { gitlabAuthApiRef } from '@backstage/core-plugin-api';
import { googleAuthApiRef } from '@backstage/core-plugin-api';
import { IconComponent as IconComponent_2 } from '@backstage/core-plugin-api';
import { IdentityApi } from '@backstage/core-plugin-api';
import { identityApiRef } from '@backstage/core-plugin-api';
import { JsonObject } from '@backstage/types';
import { JSX as JSX_2 } from 'react';
import { microsoftAuthApiRef } from '@backstage/core-plugin-api';
import { OAuthApi } from '@backstage/core-plugin-api';
import { OAuthRequestApi } from '@backstage/core-plugin-api';
import { oauthRequestApiRef } from '@backstage/core-plugin-api';
import { OAuthRequester } from '@backstage/core-plugin-api';
import { OAuthRequesterOptions } from '@backstage/core-plugin-api';
import { OAuthScope } from '@backstage/core-plugin-api';
import { oktaAuthApiRef } from '@backstage/core-plugin-api';
import { oneloginAuthApiRef } from '@backstage/core-plugin-api';
import { OpenIdConnectApi } from '@backstage/core-plugin-api';
import { PendingOAuthRequest } from '@backstage/core-plugin-api';
import { ProfileInfo } from '@backstage/core-plugin-api';
import { ProfileInfoApi } from '@backstage/core-plugin-api';
import { PropsWithChildren } from 'react';
import { default as React_2 } from 'react';
import { ReactNode } from 'react';
import { SessionApi } from '@backstage/core-plugin-api';
import { SessionState } from '@backstage/core-plugin-api';
import { SignInPageProps } from '@backstage/core-plugin-api';
import { StorageApi } from '@backstage/core-plugin-api';
import { storageApiRef } from '@backstage/core-plugin-api';
import { StorageValueSnapshot } from '@backstage/core-plugin-api';
import { TranslationMessages } from '@backstage/core-plugin-api/alpha';
import { TranslationMessagesOptions } from '@backstage/core-plugin-api/alpha';
import { TranslationRef } from '@backstage/core-plugin-api/alpha';
import { TranslationRefOptions } from '@backstage/core-plugin-api/alpha';
import { TranslationResource } from '@backstage/core-plugin-api/alpha';
import { TranslationResourceOptions } from '@backstage/core-plugin-api/alpha';
import { TypesToApiRefs } from '@backstage/core-plugin-api';
import { useApi } from '@backstage/core-plugin-api';
import { useApiHolder } from '@backstage/core-plugin-api';
import { useTranslationRef } from '@backstage/core-plugin-api/alpha';
import { vmwareCloudAuthApiRef } from '@backstage/core-plugin-api';
import { withApis } from '@backstage/core-plugin-api';
import { z } from 'zod';

export { AlertApi };

export { alertApiRef };

export { AlertMessage };

// @public
export type AnalyticsApi = {
  captureEvent(event: AnalyticsEvent): void;
};

// @public
export const analyticsApiRef: ApiRef<AnalyticsApi>;

// @public
export const AnalyticsContext: (options: {
  attributes: Partial<AnalyticsContextValue>;
  children: ReactNode;
}) => React_2.JSX.Element;

// @public
export type AnalyticsContextValue = CommonAnalyticsContext & {
  [param in string]: string | boolean | number | undefined;
};

// @public
export type AnalyticsEvent = {
  action: string;
  subject: string;
  value?: number;
  attributes?: AnalyticsEventAttributes;
  context: AnalyticsContextValue;
};

// @public
export type AnalyticsEventAttributes = {
  [attribute in string]: string | boolean | number;
};

// @public
export type AnalyticsTracker = {
  captureEvent: (
    action: string,
    subject: string,
    options?: {
      value?: number;
      attributes?: AnalyticsEventAttributes;
    },
  ) => void;
};

export { AnyApiFactory };

export { AnyApiRef };

// @public (undocumented)
export type AnyExtensionDataRef = ExtensionDataRef<
  unknown,
  string,
  {
    optional?: true;
  }
>;

// @public (undocumented)
export type AnyExternalRoutes = {
  [name in string]: ExternalRouteRef;
};

// @public
export type AnyRouteRefParams =
  | {
      [param in string]: string;
    }
  | undefined;

// @public (undocumented)
export type AnyRoutes = {
  [name in string]: RouteRef | SubRouteRef;
};

// @public
export const ApiBlueprint: ExtensionBlueprint<{
  kind: 'api';
  name: undefined;
  params: {
    factory: AnyApiFactory;
  };
  output: ConfigurableExtensionDataRef<AnyApiFactory, 'core.api.factory', {}>;
  inputs: {};
  config: {};
  configInput: {};
  dataRefs: {
    factory: ConfigurableExtensionDataRef<
      AnyApiFactory,
      'core.api.factory',
      {}
    >;
  };
}>;

export { ApiFactory };

export { ApiHolder };

export { ApiRef };

export { ApiRefConfig };

// @public
export interface AppNode {
  readonly edges: AppNodeEdges;
  readonly instance?: AppNodeInstance;
  readonly spec: AppNodeSpec;
}

// @public
export interface AppNodeEdges {
  // (undocumented)
  readonly attachedTo?: {
    node: AppNode;
    input: string;
  };
  // (undocumented)
  readonly attachments: ReadonlyMap<string, AppNode[]>;
}

// @public
export interface AppNodeInstance {
  getData<T>(ref: ExtensionDataRef<T>): T | undefined;
  getDataRefs(): Iterable<ExtensionDataRef<unknown>>;
}

// @public
export interface AppNodeSpec {
  // (undocumented)
  readonly attachTo: ExtensionAttachToSpec;
  // (undocumented)
  readonly config?: unknown;
  // (undocumented)
  readonly disabled: boolean;
  // (undocumented)
  readonly extension: Extension<unknown, unknown>;
  // (undocumented)
  readonly id: string;
  // (undocumented)
  readonly source?: FrontendPlugin;
}

// @public
export const AppRootElementBlueprint: ExtensionBlueprint<{
  kind: 'app-root-element';
  name: undefined;
  params: {
    element: JSX.Element | (() => JSX.Element);
  };
  output: ConfigurableExtensionDataRef<JSX_2.Element, 'core.reactElement', {}>;
  inputs: {};
  config: {};
  configInput: {};
  dataRefs: never;
}>;

// @public
export const AppRootWrapperBlueprint: ExtensionBlueprint<{
  kind: 'app-root-wrapper';
  name: undefined;
  params: {
    Component: ComponentType<PropsWithChildren<{}>>;
  };
  output: ConfigurableExtensionDataRef<
    React_2.ComponentType<{
      children?: React_2.ReactNode | undefined;
    }>,
    'app.root.wrapper',
    {}
  >;
  inputs: {};
  config: {};
  configInput: {};
  dataRefs: {
    component: ConfigurableExtensionDataRef<
      React_2.ComponentType<{
        children?: React_2.ReactNode | undefined;
      }>,
      'app.root.wrapper',
      {}
    >;
  };
}>;

export { AppTheme };

export { AppThemeApi };

export { appThemeApiRef };

// @public
export interface AppTree {
  readonly nodes: ReadonlyMap<string, AppNode>;
  readonly orphans: Iterable<AppNode>;
  readonly root: AppNode;
}

// @public
export interface AppTreeApi {
  getNodesByRoutePath(sourcePath: string): {
    nodes: AppNode[];
  };
  getTree(): {
    tree: AppTree;
  };
}

// @public
export const appTreeApiRef: ApiRef<AppTreeApi>;

export { atlassianAuthApiRef };

export { AuthProviderInfo };

export { AuthRequestOptions };

export { BackstageIdentityApi };

export { BackstageIdentityResponse };

export { BackstageUserIdentity };

export { bitbucketAuthApiRef };

export { bitbucketServerAuthApiRef };

// @public
export type CommonAnalyticsContext = {
  pluginId: string;
  extensionId: string;
};

// @public (undocumented)
export type ComponentRef<T extends {} = {}> = {
  id: string;
  T: T;
};

// @public
export interface ComponentsApi {
  // (undocumented)
  getComponent<T extends {}>(ref: ComponentRef<T>): ComponentType<T>;
}

// @public
export const componentsApiRef: ApiRef<ComponentsApi>;

export { ConfigApi };

export { configApiRef };

// @public (undocumented)
export interface ConfigurableExtensionDataRef<
  TData,
  TId extends string,
  TConfig extends {
    optional?: true;
  } = {},
> extends ExtensionDataRef<TData, TId, TConfig> {
  // (undocumented)
  (t: TData): ExtensionDataValue<TData, TId>;
  // (undocumented)
  optional(): ConfigurableExtensionDataRef<
    TData,
    TId,
    TConfig & {
      optional: true;
    }
  >;
}

// @public (undocumented)
export const coreComponentRefs: {
  progress: ComponentRef<CoreProgressProps>;
  notFoundErrorPage: ComponentRef<CoreNotFoundErrorPageProps>;
  errorBoundaryFallback: ComponentRef<CoreErrorBoundaryFallbackProps>;
};

// @public (undocumented)
export type CoreErrorBoundaryFallbackProps = {
  plugin?: FrontendPlugin;
  error: Error;
  resetError: () => void;
};

// @public (undocumented)
export const coreExtensionData: {
  reactElement: ConfigurableExtensionDataRef<
    JSX_2.Element,
    'core.reactElement',
    {}
  >;
  routePath: ConfigurableExtensionDataRef<string, 'core.routing.path', {}>;
  routeRef: ConfigurableExtensionDataRef<
    RouteRef<AnyRouteRefParams>,
    'core.routing.ref',
    {}
  >;
};

// @public (undocumented)
export type CoreNotFoundErrorPageProps = {
  children?: ReactNode;
};

// @public (undocumented)
export type CoreProgressProps = {};

export { createApiFactory };

export { createApiRef };

// @public (undocumented)
export function createComponentExtension<TProps extends {}>(options: {
  ref: ComponentRef<TProps>;
  name?: string;
  disabled?: boolean;
  loader:
    | {
        lazy: () => Promise<ComponentType<TProps>>;
      }
    | {
        sync: () => ComponentType<TProps>;
      };
}): ExtensionDefinition<{
  config: {};
  configInput: {};
  output: ConfigurableExtensionDataRef<
    {
      ref: ComponentRef;
      impl: ComponentType;
    },
    'core.component.component',
    {}
  >;
  inputs: {
    [x: string]: ExtensionInput<
      AnyExtensionDataRef,
      {
        optional: boolean;
        singleton: boolean;
      }
    >;
  };
  params: never;
  kind: 'component';
  name: string;
}>;

// @public (undocumented)
export namespace createComponentExtension {
  const // (undocumented)
    componentDataRef: ConfigurableExtensionDataRef<
      {
        ref: ComponentRef;
        impl: ComponentType;
      },
      'core.component.component',
      {}
    >;
}

// @public (undocumented)
export function createComponentRef<T extends {} = {}>(options: {
  id: string;
}): ComponentRef<T>;

// @public (undocumented)
export function createExtension<
  UOutput extends AnyExtensionDataRef,
  TInputs extends {
    [inputName in string]: ExtensionInput<
      AnyExtensionDataRef,
      {
        optional: boolean;
        singleton: boolean;
      }
    >;
  },
  TConfigSchema extends {
    [key: string]: (zImpl: typeof z) => z.ZodType;
  },
  UFactoryOutput extends ExtensionDataValue<any, any>,
  const TKind extends string | undefined = undefined,
  const TName extends string | undefined = undefined,
>(
  options: CreateExtensionOptions<
    TKind,
    TName,
    UOutput,
    TInputs,
    TConfigSchema,
    UFactoryOutput
  >,
): ExtensionDefinition<{
  config: string extends keyof TConfigSchema
    ? {}
    : {
        [key in keyof TConfigSchema]: z.infer<ReturnType<TConfigSchema[key]>>;
      };
  configInput: string extends keyof TConfigSchema
    ? {}
    : z.input<
        z.ZodObject<{
          [key in keyof TConfigSchema]: ReturnType<TConfigSchema[key]>;
        }>
      >;
  output: UOutput;
  inputs: TInputs;
  params: never;
  kind: string | undefined extends TKind ? undefined : TKind;
  name: string | undefined extends TName ? undefined : TName;
}>;

// @public
export function createExtensionBlueprint<
  TParams extends object,
  UOutput extends AnyExtensionDataRef,
  TInputs extends {
    [inputName in string]: ExtensionInput<
      AnyExtensionDataRef,
      {
        optional: boolean;
        singleton: boolean;
      }
    >;
  },
  TConfigSchema extends {
    [key in string]: (zImpl: typeof z) => z.ZodType;
  },
  UFactoryOutput extends ExtensionDataValue<any, any>,
  TKind extends string,
  TName extends string | undefined = undefined,
  TDataRefs extends {
    [name in string]: AnyExtensionDataRef;
  } = never,
>(
  options: CreateExtensionBlueprintOptions<
    TKind,
    TName,
    TParams,
    UOutput,
    TInputs,
    TConfigSchema,
    UFactoryOutput,
    TDataRefs
  >,
): ExtensionBlueprint<{
  kind: TKind;
  name: TName;
  params: TParams;
  output: UOutput;
  inputs: string extends keyof TInputs ? {} : TInputs;
  config: string extends keyof TConfigSchema
    ? {}
    : {
        [key in keyof TConfigSchema]: z.infer<ReturnType<TConfigSchema[key]>>;
      };
  configInput: string extends keyof TConfigSchema
    ? {}
    : z.input<
        z.ZodObject<{
          [key in keyof TConfigSchema]: ReturnType<TConfigSchema[key]>;
        }>
      >;
  dataRefs: TDataRefs;
}>;

// @public (undocumented)
export type CreateExtensionBlueprintOptions<
  TKind extends string,
  TName extends string | undefined,
  TParams,
  UOutput extends AnyExtensionDataRef,
  TInputs extends {
    [inputName in string]: ExtensionInput<
      AnyExtensionDataRef,
      {
        optional: boolean;
        singleton: boolean;
      }
    >;
  },
  TConfigSchema extends {
    [key in string]: (zImpl: typeof z) => z.ZodType;
  },
  UFactoryOutput extends ExtensionDataValue<any, any>,
  TDataRefs extends {
    [name in string]: AnyExtensionDataRef;
  },
> = {
  kind: TKind;
  attachTo: ExtensionAttachToSpec;
  disabled?: boolean;
  inputs?: TInputs;
  output: Array<UOutput>;
  name?: TName;
  config?: {
    schema: TConfigSchema;
  };
  factory(
    params: TParams,
    context: {
      node: AppNode;
      apis: ApiHolder;
      config: {
        [key in keyof TConfigSchema]: z.infer<ReturnType<TConfigSchema[key]>>;
      };
      inputs: Expand<ResolvedExtensionInputs<TInputs>>;
    },
  ): Iterable<UFactoryOutput>;
  dataRefs?: TDataRefs;
} & VerifyExtensionFactoryOutput<UOutput, UFactoryOutput>;

// @public (undocumented)
export function createExtensionDataRef<TData>(): {
  with<TId extends string>(options: {
    id: TId;
  }): ConfigurableExtensionDataRef<TData, TId>;
};

// @public (undocumented)
export function createExtensionInput<
  UExtensionData extends ExtensionDataRef<
    unknown,
    string,
    {
      optional?: true;
    }
  >,
  TConfig extends {
    singleton?: boolean;
    optional?: boolean;
  },
>(
  extensionData: Array<UExtensionData>,
  config?: TConfig & {
    replaces?: Array<{
      id: string;
      input: string;
    }>;
  },
): ExtensionInput<
  UExtensionData,
  {
    singleton: TConfig['singleton'] extends true ? true : false;
    optional: TConfig['optional'] extends true ? true : false;
  }
>;

// @public (undocumented)
export type CreateExtensionOptions<
  TKind extends string | undefined,
  TName extends string | undefined,
  UOutput extends AnyExtensionDataRef,
  TInputs extends {
    [inputName in string]: ExtensionInput<
      AnyExtensionDataRef,
      {
        optional: boolean;
        singleton: boolean;
      }
    >;
  },
  TConfigSchema extends {
    [key: string]: (zImpl: typeof z) => z.ZodType;
  },
  UFactoryOutput extends ExtensionDataValue<any, any>,
> = {
  kind?: TKind;
  name?: TName;
  attachTo: ExtensionAttachToSpec;
  disabled?: boolean;
  inputs?: TInputs;
  output: Array<UOutput>;
  config?: {
    schema: TConfigSchema;
  };
  factory(context: {
    node: AppNode;
    apis: ApiHolder;
    config: {
      [key in keyof TConfigSchema]: z.infer<ReturnType<TConfigSchema[key]>>;
    };
    inputs: Expand<ResolvedExtensionInputs<TInputs>>;
  }): Iterable<UFactoryOutput>;
} & VerifyExtensionFactoryOutput<UOutput, UFactoryOutput>;

// @public
export function createExternalRouteRef<
  TParams extends
    | {
        [param in TParamKeys]: string;
      }
    | undefined = undefined,
  TParamKeys extends string = string,
>(options?: {
  readonly params?: string extends TParamKeys
    ? (keyof TParams)[]
    : TParamKeys[];
  defaultTarget?: string;
}): ExternalRouteRef<
  keyof TParams extends never
    ? undefined
    : string extends TParamKeys
    ? TParams
    : {
        [param in TParamKeys]: string;
      }
>;

// @public (undocumented)
export function createFrontendFeatureLoader(
  options: CreateFrontendFeatureLoaderOptions,
): FrontendFeatureLoader;

// @public (undocumented)
export interface CreateFrontendFeatureLoaderOptions {
  // (undocumented)
  loader(deps: { config: ConfigApi }):
    | Iterable<
        | FrontendFeature
        | FrontendFeatureLoader
        | Promise<{
            default: FrontendFeature | FrontendFeatureLoader;
          }>
      >
    | Promise<
        Iterable<
          | FrontendFeature
          | FrontendFeatureLoader
          | Promise<{
              default: FrontendFeature | FrontendFeatureLoader;
            }>
        >
      >
    | AsyncIterable<
        | FrontendFeature
        | FrontendFeatureLoader
        | {
            default: FrontendFeature | FrontendFeatureLoader;
          }
      >;
}

// @public (undocumented)
export function createFrontendModule<
  TId extends string,
  TExtensions extends readonly ExtensionDefinition[] = [],
>(options: CreateFrontendModuleOptions<TId, TExtensions>): FrontendModule;

// @public (undocumented)
export interface CreateFrontendModuleOptions<
  TPluginId extends string,
  TExtensions extends readonly ExtensionDefinition[],
> {
  // (undocumented)
  extensions?: TExtensions;
  // (undocumented)
  featureFlags?: FeatureFlagConfig[];
  // (undocumented)
  pluginId: TPluginId;
}

// @public (undocumented)
export function createFrontendPlugin<
  TId extends string,
  TRoutes extends AnyRoutes = {},
  TExternalRoutes extends AnyExternalRoutes = {},
  TExtensions extends readonly ExtensionDefinition[] = [],
>(
  options: PluginOptions<TId, TRoutes, TExternalRoutes, TExtensions>,
): FrontendPlugin<
  TRoutes,
  TExternalRoutes,
  MakeSortedExtensionsMap<TExtensions[number], TId>
>;

// @public
export function createRouteRef<
  TParams extends
    | {
        [param in TParamKeys]: string;
      }
    | undefined = undefined,
  TParamKeys extends string = string,
>(config?: {
  readonly params: string extends TParamKeys ? (keyof TParams)[] : TParamKeys[];
}): RouteRef<
  keyof TParams extends never
    ? undefined
    : string extends TParamKeys
    ? TParams
    : {
        [param in TParamKeys]: string;
      }
>;

// @public
export function createSubRouteRef<
  Path extends string,
  ParentParams extends AnyRouteRefParams = never,
>(config: {
  path: Path;
  parent: RouteRef<ParentParams>;
}): MakeSubRouteRef<PathParams<Path>, ParentParams>;

export { createTranslationMessages };

export { createTranslationRef };

export { createTranslationResource };

// @public
export interface DialogApi {
  show<TResult = {}>(
    elementOrComponent:
      | JSX.Element
      | ((props: {
          dialog: DialogApiDialog<TResult | undefined>;
        }) => JSX.Element),
  ): DialogApiDialog<TResult | undefined>;
  showModal<TResult = {}>(
    elementOrComponent:
      | JSX.Element
      | ((props: { dialog: DialogApiDialog<TResult> }) => JSX.Element),
  ): DialogApiDialog<TResult>;
}

// @public
export interface DialogApiDialog<TResult = unknown> {
  close(
    ...args: undefined extends TResult ? [result?: TResult] : [result: TResult]
  ): void;
  result(): Promise<TResult>;
  update(
    elementOrComponent:
      | React.JSX.Element
      | ((props: { dialog: DialogApiDialog<TResult> }) => JSX.Element),
  ): void;
}

// @public
export const dialogApiRef: ApiRef<DialogApi>;

export { DiscoveryApi };

export { discoveryApiRef };

export { ErrorApi };

export { ErrorApiError };

export { ErrorApiErrorContext };

export { errorApiRef };

// @public (undocumented)
export interface Extension<TConfig, TConfigInput = TConfig> {
  // (undocumented)
  $$type: '@backstage/Extension';
  // (undocumented)
  readonly attachTo: ExtensionAttachToSpec;
  // (undocumented)
  readonly configSchema?: PortableSchema<TConfig, TConfigInput>;
  // (undocumented)
  readonly disabled: boolean;
  // (undocumented)
  readonly id: string;
}

// @public (undocumented)
export type ExtensionAttachToSpec =
  | {
      id: string;
      input: string;
    }
  | Array<{
      id: string;
      input: string;
    }>;

// @public (undocumented)
export interface ExtensionBlueprint<
  T extends ExtensionBlueprintParameters = ExtensionBlueprintParameters,
> {
  // (undocumented)
  dataRefs: T['dataRefs'];
  // (undocumented)
  make<TNewName extends string | undefined>(args: {
    name?: TNewName;
    attachTo?: ExtensionAttachToSpec;
    disabled?: boolean;
    params: T['params'];
  }): ExtensionDefinition<{
    kind: T['kind'];
    name: string | undefined extends TNewName ? T['name'] : TNewName;
    config: T['config'];
    configInput: T['configInput'];
    output: T['output'];
    inputs: T['inputs'];
    params: T['params'];
  }>;
  makeWithOverrides<
    TNewName extends string | undefined,
    TExtensionConfigSchema extends {
      [key in string]: (zImpl: typeof z) => z.ZodType;
    },
    UFactoryOutput extends ExtensionDataValue<any, any>,
    UNewOutput extends AnyExtensionDataRef,
    TExtraInputs extends {
      [inputName in string]: ExtensionInput<
        AnyExtensionDataRef,
        {
          optional: boolean;
          singleton: boolean;
        }
      >;
    },
  >(args: {
    name?: TNewName;
    attachTo?: ExtensionAttachToSpec;
    disabled?: boolean;
    inputs?: TExtraInputs & {
      [KName in keyof T['inputs']]?: `Error: Input '${KName &
        string}' is already defined in parent definition`;
    };
    output?: Array<UNewOutput>;
    config?: {
      schema: TExtensionConfigSchema & {
        [KName in keyof T['config']]?: `Error: Config key '${KName &
          string}' is already defined in parent schema`;
      };
    };
    factory(
      originalFactory: (
        params: T['params'],
        context?: {
          config?: T['config'];
          inputs?: ResolveInputValueOverrides<NonNullable<T['inputs']>>;
        },
      ) => ExtensionDataContainer<NonNullable<T['output']>>,
      context: {
        node: AppNode;
        apis: ApiHolder;
        config: T['config'] & {
          [key in keyof TExtensionConfigSchema]: z.infer<
            ReturnType<TExtensionConfigSchema[key]>
          >;
        };
        inputs: Expand<ResolvedExtensionInputs<T['inputs'] & TExtraInputs>>;
      },
    ): Iterable<UFactoryOutput> &
      VerifyExtensionFactoryOutput<
        AnyExtensionDataRef extends UNewOutput
          ? NonNullable<T['output']>
          : UNewOutput,
        UFactoryOutput
      >;
  }): ExtensionDefinition<{
    config: (string extends keyof TExtensionConfigSchema
      ? {}
      : {
          [key in keyof TExtensionConfigSchema]: z.infer<
            ReturnType<TExtensionConfigSchema[key]>
          >;
        }) &
      T['config'];
    configInput: (string extends keyof TExtensionConfigSchema
      ? {}
      : z.input<
          z.ZodObject<{
            [key in keyof TExtensionConfigSchema]: ReturnType<
              TExtensionConfigSchema[key]
            >;
          }>
        >) &
      T['configInput'];
    output: AnyExtensionDataRef extends UNewOutput ? T['output'] : UNewOutput;
    inputs: T['inputs'] & TExtraInputs;
    kind: T['kind'];
    name: string | undefined extends TNewName ? T['name'] : TNewName;
    params: T['params'];
  }>;
}

// @public (undocumented)
export type ExtensionBlueprintParameters = {
  kind: string;
  name?: string;
  params?: object;
  configInput?: {
    [K in string]: any;
  };
  config?: {
    [K in string]: any;
  };
  output?: AnyExtensionDataRef;
  inputs?: {
    [KName in string]: ExtensionInput<
      AnyExtensionDataRef,
      {
        optional: boolean;
        singleton: boolean;
      }
    >;
  };
  dataRefs?: {
    [name in string]: AnyExtensionDataRef;
  };
};

// @public (undocumented)
export function ExtensionBoundary(
  props: ExtensionBoundaryProps,
): React_2.JSX.Element;

// @public (undocumented)
export namespace ExtensionBoundary {
  // (undocumented)
  export function lazy(
    appNode: AppNode,
    loader: () => Promise<JSX.Element>,
  ): JSX.Element;
  // (undocumented)
  export function lazyComponent<TProps extends {}>(
    appNode: AppNode,
    loader: () => Promise<(props: TProps) => JSX.Element>,
  ): (props: TProps) => JSX.Element;
}

// @public (undocumented)
export interface ExtensionBoundaryProps {
  // (undocumented)
  children: ReactNode;
  // (undocumented)
  node: AppNode;
  routable?: boolean;
}

// @public (undocumented)
export type ExtensionDataContainer<UExtensionData extends AnyExtensionDataRef> =
  Iterable<
    UExtensionData extends ExtensionDataRef<
      infer IData,
      infer IId,
      infer IConfig
    >
      ? IConfig['optional'] extends true
        ? never
        : ExtensionDataValue<IData, IId>
      : never
  > & {
    get<TId extends UExtensionData['id']>(
      ref: ExtensionDataRef<any, TId, any>,
    ): UExtensionData extends ExtensionDataRef<infer IData, TId, infer IConfig>
      ? IConfig['optional'] extends true
        ? IData | undefined
        : IData
      : never;
  };

// @public (undocumented)
export type ExtensionDataRef<
  TData,
  TId extends string = string,
  TConfig extends {
    optional?: true;
  } = {},
> = {
  readonly $$type: '@backstage/ExtensionDataRef';
  readonly id: TId;
  readonly T: TData;
  readonly config: TConfig;
};

// @public (undocumented)
export type ExtensionDataRefToValue<TDataRef extends AnyExtensionDataRef> =
  TDataRef extends ExtensionDataRef<infer IData, infer IId, any>
    ? ExtensionDataValue<IData, IId>
    : never;

// @public (undocumented)
export type ExtensionDataValue<TData, TId extends string> = {
  readonly $$type: '@backstage/ExtensionDataValue';
  readonly id: TId;
  readonly value: TData;
};

// @public (undocumented)
export type ExtensionDefinition<
  T extends ExtensionDefinitionParameters = ExtensionDefinitionParameters,
> = {
  $$type: '@backstage/ExtensionDefinition';
  readonly T: T;
  override<
    TExtensionConfigSchema extends {
      [key in string]: (zImpl: typeof z) => z.ZodType;
    },
    UFactoryOutput extends ExtensionDataValue<any, any>,
    UNewOutput extends AnyExtensionDataRef,
    TExtraInputs extends {
      [inputName in string]: ExtensionInput<
        AnyExtensionDataRef,
        {
          optional: boolean;
          singleton: boolean;
        }
      >;
    },
  >(
    args: Expand<
      {
        attachTo?: ExtensionAttachToSpec;
        disabled?: boolean;
        inputs?: TExtraInputs & {
          [KName in keyof T['inputs']]?: `Error: Input '${KName &
            string}' is already defined in parent definition`;
        };
        output?: Array<UNewOutput>;
        config?: {
          schema: TExtensionConfigSchema & {
            [KName in keyof T['config']]?: `Error: Config key '${KName &
              string}' is already defined in parent schema`;
          };
        };
        factory?(
          originalFactory: (
            context?: Expand<
              {
                config?: T['config'];
                inputs?: ResolveInputValueOverrides<NonNullable<T['inputs']>>;
              } & ([T['params']] extends [never]
                ? {}
                : {
                    params?: Partial<T['params']>;
                  })
            >,
          ) => ExtensionDataContainer<NonNullable<T['output']>>,
          context: {
            node: AppNode;
            apis: ApiHolder;
            config: T['config'] & {
              [key in keyof TExtensionConfigSchema]: z.infer<
                ReturnType<TExtensionConfigSchema[key]>
              >;
            };
            inputs: Expand<ResolvedExtensionInputs<T['inputs'] & TExtraInputs>>;
          },
        ): Iterable<UFactoryOutput>;
      } & ([T['params']] extends [never]
        ? {}
        : {
            params?: Partial<T['params']>;
          })
    > &
      VerifyExtensionFactoryOutput<
        AnyExtensionDataRef extends UNewOutput
          ? NonNullable<T['output']>
          : UNewOutput,
        UFactoryOutput
      >,
  ): ExtensionDefinition<{
    kind: T['kind'];
    name: T['name'];
    output: AnyExtensionDataRef extends UNewOutput ? T['output'] : UNewOutput;
    inputs: T['inputs'] & TExtraInputs;
    config: T['config'] & {
      [key in keyof TExtensionConfigSchema]: z.infer<
        ReturnType<TExtensionConfigSchema[key]>
      >;
    };
    configInput: T['configInput'] &
      z.input<
        z.ZodObject<{
          [key in keyof TExtensionConfigSchema]: ReturnType<
            TExtensionConfigSchema[key]
          >;
        }>
      >;
  }>;
};

// @public (undocumented)
export type ExtensionDefinitionParameters = {
  kind?: string;
  name?: string;
  configInput?: {
    [K in string]: any;
  };
  config?: {
    [K in string]: any;
  };
  output?: AnyExtensionDataRef;
  inputs?: {
    [KName in string]: ExtensionInput<
      AnyExtensionDataRef,
      {
        optional: boolean;
        singleton: boolean;
      }
    >;
  };
  params?: object;
};

// @public (undocumented)
export type ExtensionFactoryMiddleware = (
  originalFactory: (contextOverrides?: {
    config?: JsonObject;
  }) => ExtensionDataContainer<AnyExtensionDataRef>,
  context: {
    node: AppNode;
    apis: ApiHolder;
    config?: JsonObject;
  },
) => Iterable<ExtensionDataValue<any, any>>;

// @public (undocumented)
export interface ExtensionInput<
  UExtensionData extends ExtensionDataRef<
    unknown,
    string,
    {
      optional?: true;
    }
  >,
  TConfig extends {
    singleton: boolean;
    optional: boolean;
  },
> {
  // (undocumented)
  $$type: '@backstage/ExtensionInput';
  // (undocumented)
  config: TConfig;
  // (undocumented)
  extensionData: Array<UExtensionData>;
  // (undocumented)
  replaces?: Array<{
    id: string;
    input: string;
  }>;
}

// @public
export interface ExternalRouteRef<
  TParams extends AnyRouteRefParams = AnyRouteRefParams,
> {
  // (undocumented)
  readonly $$type: '@backstage/ExternalRouteRef';
  // (undocumented)
  readonly T: TParams;
}

export { FeatureFlag };

// @public
export type FeatureFlagConfig = {
  name: string;
};

export { FeatureFlagsApi };

export { featureFlagsApiRef };

export { FeatureFlagsSaveOptions };

export { FeatureFlagState };

export { FetchApi };

export { fetchApiRef };

// @public (undocumented)
export type FrontendFeature = FrontendPlugin | FrontendModule;

// @public (undocumented)
export interface FrontendFeatureLoader {
  // (undocumented)
  readonly $$type: '@backstage/FrontendFeatureLoader';
}

// @public (undocumented)
export interface FrontendModule {
  // (undocumented)
  readonly $$type: '@backstage/FrontendModule';
  // (undocumented)
  readonly pluginId: string;
}

// @public (undocumented)
export interface FrontendPlugin<
  TRoutes extends AnyRoutes = AnyRoutes,
  TExternalRoutes extends AnyExternalRoutes = AnyExternalRoutes,
  TExtensionMap extends {
    [id in string]: ExtensionDefinition;
  } = {
    [id in string]: ExtensionDefinition;
  },
> {
  // (undocumented)
  readonly $$type: '@backstage/FrontendPlugin';
  // (undocumented)
  readonly externalRoutes: TExternalRoutes;
  // (undocumented)
  getExtension<TId extends keyof TExtensionMap>(id: TId): TExtensionMap[TId];
  // (undocumented)
  readonly id: string;
  // (undocumented)
  readonly routes: TRoutes;
  // (undocumented)
  withOverrides(options: {
    extensions: Array<ExtensionDefinition>;
  }): FrontendPlugin<TRoutes, TExternalRoutes, TExtensionMap>;
}

export { githubAuthApiRef };

export { gitlabAuthApiRef };

export { googleAuthApiRef };

// @public (undocumented)
export const IconBundleBlueprint: ExtensionBlueprint<{
  kind: 'icon-bundle';
  name: undefined;
  params: {
    icons: { [key in string]: IconComponent };
  };
  output: ConfigurableExtensionDataRef<
    {
      [x: string]: IconComponent;
    },
    'core.icons',
    {}
  >;
  inputs: {};
  config: {};
  configInput: {};
  dataRefs: {
    icons: ConfigurableExtensionDataRef<
      {
        [x: string]: IconComponent;
      },
      'core.icons',
      {}
    >;
  };
}>;

// @public
export type IconComponent = ComponentType<{
  fontSize?: 'medium' | 'large' | 'small' | 'inherit';
}>;

// @public
export interface IconsApi {
  // (undocumented)
  getIcon(key: string): IconComponent | undefined;
  // (undocumented)
  listIconKeys(): string[];
}

// @public
export const iconsApiRef: ApiRef<IconsApi>;

export { IdentityApi };

export { identityApiRef };

export { microsoftAuthApiRef };

// @public
export const NavItemBlueprint: ExtensionBlueprint<{
  kind: 'nav-item';
  name: undefined;
  params: {
    title: string;
    icon: IconComponent_2;
    routeRef: RouteRef<undefined>;
  };
  output: ConfigurableExtensionDataRef<
    {
      title: string;
      icon: IconComponent_2;
      routeRef: RouteRef<undefined>;
    },
    'core.nav-item.target',
    {}
  >;
  inputs: {};
  config: {};
  configInput: {};
  dataRefs: {
    target: ConfigurableExtensionDataRef<
      {
        title: string;
        icon: IconComponent_2;
        routeRef: RouteRef<undefined>;
      },
      'core.nav-item.target',
      {}
    >;
  };
}>;

// @public
export const NavLogoBlueprint: ExtensionBlueprint<{
  kind: 'nav-logo';
  name: undefined;
  params: {
    logoIcon: JSX.Element;
    logoFull: JSX.Element;
  };
  output: ConfigurableExtensionDataRef<
    {
      logoIcon?: JSX.Element;
      logoFull?: JSX.Element;
    },
    'core.nav-logo.logo-elements',
    {}
  >;
  inputs: {};
  config: {};
  configInput: {};
  dataRefs: {
    logoElements: ConfigurableExtensionDataRef<
      {
        logoIcon?: JSX.Element;
        logoFull?: JSX.Element;
      },
      'core.nav-logo.logo-elements',
      {}
    >;
  };
}>;

export { OAuthApi };

export { OAuthRequestApi };

export { oauthRequestApiRef };

export { OAuthRequester };

export { OAuthRequesterOptions };

export { OAuthScope };

export { oktaAuthApiRef };

export { oneloginAuthApiRef };

export { OpenIdConnectApi };

// @public
export const PageBlueprint: ExtensionBlueprint<{
  kind: 'page';
  name: undefined;
  params: {
    defaultPath: string;
    loader: () => Promise<JSX.Element>;
    routeRef?: RouteRef;
  };
  output:
    | ConfigurableExtensionDataRef<JSX_2.Element, 'core.reactElement', {}>
    | ConfigurableExtensionDataRef<string, 'core.routing.path', {}>
    | ConfigurableExtensionDataRef<
        RouteRef<AnyRouteRefParams>,
        'core.routing.ref',
        {
          optional: true;
        }
      >;
  inputs: {};
  config: {
    path: string | undefined;
  };
  configInput: {
    path?: string | undefined;
  };
  dataRefs: never;
}>;

export { PendingOAuthRequest };

// @public (undocumented)
export interface PluginOptions<
  TId extends string,
  TRoutes extends AnyRoutes,
  TExternalRoutes extends AnyExternalRoutes,
  TExtensions extends readonly ExtensionDefinition[],
> {
  // (undocumented)
  extensions?: TExtensions;
  // (undocumented)
  externalRoutes?: TExternalRoutes;
  // (undocumented)
  featureFlags?: FeatureFlagConfig[];
  // (undocumented)
  id: TId;
  // (undocumented)
  routes?: TRoutes;
}

// @public (undocumented)
export type PortableSchema<TOutput, TInput = TOutput> = {
  parse: (input: TInput) => TOutput;
  schema: JsonObject;
};

export { ProfileInfo };

export { ProfileInfoApi };

// @public
export type ResolvedExtensionInput<
  TExtensionInput extends ExtensionInput<any, any>,
> = TExtensionInput['extensionData'] extends Array<AnyExtensionDataRef>
  ? {
      node: AppNode;
    } & ExtensionDataContainer<TExtensionInput['extensionData'][number]>
  : never;

// @public
export type ResolvedExtensionInputs<
  TInputs extends {
    [name in string]: ExtensionInput<any, any>;
  },
> = {
  [InputName in keyof TInputs]: false extends TInputs[InputName]['config']['singleton']
    ? Array<Expand<ResolvedExtensionInput<TInputs[InputName]>>>
    : false extends TInputs[InputName]['config']['optional']
    ? Expand<ResolvedExtensionInput<TInputs[InputName]>>
    : Expand<ResolvedExtensionInput<TInputs[InputName]> | undefined>;
};

// @public (undocumented)
export type ResolveInputValueOverrides<
  TInputs extends {
    [inputName in string]: ExtensionInput<
      AnyExtensionDataRef,
      {
        optional: boolean;
        singleton: boolean;
      }
    >;
  } = {
    [inputName in string]: ExtensionInput<
      AnyExtensionDataRef,
      {
        optional: boolean;
        singleton: boolean;
      }
    >;
  },
> = Expand<
  {
    [KName in keyof TInputs as TInputs[KName] extends ExtensionInput<
      any,
      {
        optional: infer IOptional extends boolean;
        singleton: boolean;
      }
    >
      ? IOptional extends true
        ? never
        : KName
      : never]: TInputs[KName] extends ExtensionInput<
      infer IDataRefs,
      {
        optional: boolean;
        singleton: infer ISingleton extends boolean;
      }
    >
      ? ISingleton extends true
        ? Iterable<ExtensionDataRefToValue<IDataRefs>>
        : Array<Iterable<ExtensionDataRefToValue<IDataRefs>>>
      : never;
  } & {
    [KName in keyof TInputs as TInputs[KName] extends ExtensionInput<
      any,
      {
        optional: infer IOptional extends boolean;
        singleton: boolean;
      }
    >
      ? IOptional extends true
        ? KName
        : never
      : never]?: TInputs[KName] extends ExtensionInput<
      infer IDataRefs,
      {
        optional: boolean;
        singleton: infer ISingleton extends boolean;
      }
    >
      ? ISingleton extends true
        ? Iterable<ExtensionDataRefToValue<IDataRefs>>
        : Array<Iterable<ExtensionDataRefToValue<IDataRefs>>>
      : never;
  }
>;

// @public
export type RouteFunc<TParams extends AnyRouteRefParams> = (
  ...[params]: TParams extends undefined
    ? readonly []
    : readonly [params: TParams]
) => string;

// @public (undocumented)
export const RouterBlueprint: ExtensionBlueprint<{
  kind: 'app-router-component';
  name: undefined;
  params: {
    Component: ComponentType<PropsWithChildren<{}>>;
  };
  output: ConfigurableExtensionDataRef<
    ComponentType<{
      children?: ReactNode | undefined;
    }>,
    'app.router.wrapper',
    {}
  >;
  inputs: {};
  config: {};
  configInput: {};
  dataRefs: {
    component: ConfigurableExtensionDataRef<
      ComponentType<{
        children?: ReactNode | undefined;
      }>,
      'app.router.wrapper',
      {}
    >;
  };
}>;

// @public
export interface RouteRef<
  TParams extends AnyRouteRefParams = AnyRouteRefParams,
> {
  // (undocumented)
  readonly $$type: '@backstage/RouteRef';
  // (undocumented)
  readonly T: TParams;
}

// @public (undocumented)
export interface RouteResolutionApi {
  // (undocumented)
  resolve<TParams extends AnyRouteRefParams>(
    anyRouteRef:
      | RouteRef<TParams>
      | SubRouteRef<TParams>
      | ExternalRouteRef<TParams>,
    options?: RouteResolutionApiResolveOptions,
  ): RouteFunc<TParams> | undefined;
}

// @public
export const routeResolutionApiRef: ApiRef<RouteResolutionApi>;

// @public (undocumented)
export type RouteResolutionApiResolveOptions = {
  sourcePath?: string;
};

export { SessionApi };

export { SessionState };

// @public
export const SignInPageBlueprint: ExtensionBlueprint<{
  kind: 'sign-in-page';
  name: undefined;
  params: {
    loader: () => Promise<ComponentType<SignInPageProps>>;
  };
  output: ConfigurableExtensionDataRef<
    React_2.ComponentType<SignInPageProps>,
    'core.sign-in-page.component',
    {}
  >;
  inputs: {};
  config: {};
  configInput: {};
  dataRefs: {
    component: ConfigurableExtensionDataRef<
      React_2.ComponentType<SignInPageProps>,
      'core.sign-in-page.component',
      {}
    >;
  };
}>;

export { StorageApi };

export { storageApiRef };

export { StorageValueSnapshot };

// @public
export interface SubRouteRef<
  TParams extends AnyRouteRefParams = AnyRouteRefParams,
> {
  // (undocumented)
  readonly $$type: '@backstage/SubRouteRef';
  // (undocumented)
  readonly path: string;
  // (undocumented)
  readonly T: TParams;
}

// @public
export const ThemeBlueprint: ExtensionBlueprint<{
  kind: 'theme';
  name: undefined;
  params: {
    theme: AppTheme;
  };
  output: ConfigurableExtensionDataRef<AppTheme, 'core.theme.theme', {}>;
  inputs: {};
  config: {};
  configInput: {};
  dataRefs: {
    theme: ConfigurableExtensionDataRef<AppTheme, 'core.theme.theme', {}>;
  };
}>;

// @public
export const TranslationBlueprint: ExtensionBlueprint<{
  kind: 'translation';
  name: undefined;
  params: {
    resource: TranslationResource | TranslationMessages;
  };
  output: ConfigurableExtensionDataRef<
    | TranslationResource<string>
    | TranslationMessages<
        string,
        {
          [x: string]: string;
        },
        boolean
      >,
    'core.translation.translation',
    {}
  >;
  inputs: {};
  config: {};
  configInput: {};
  dataRefs: {
    translation: ConfigurableExtensionDataRef<
      | TranslationResource<string>
      | TranslationMessages<
          string,
          {
            [x: string]: string;
          },
          boolean
        >,
      'core.translation.translation',
      {}
    >;
  };
}>;

export { TranslationMessages };

export { TranslationMessagesOptions };

export { TranslationRef };

export { TranslationRefOptions };

export { TranslationResource };

export { TranslationResourceOptions };

export { TypesToApiRefs };

// @public
export function useAnalytics(): AnalyticsTracker;

export { useApi };

export { useApiHolder };

// @public
export function useComponentRef<T extends {}>(
  ref: ComponentRef<T>,
): ComponentType<T>;

// @public
export function useRouteRef<TParams extends AnyRouteRefParams>(
  routeRef:
    | RouteRef<TParams>
    | SubRouteRef<TParams>
    | ExternalRouteRef<TParams>,
): RouteFunc<TParams> | undefined;

// @public
export function useRouteRefParams<Params extends AnyRouteRefParams>(
  _routeRef: RouteRef<Params> | SubRouteRef<Params>,
): Params;

export { useTranslationRef };

export { vmwareCloudAuthApiRef };

export { withApis };
```
