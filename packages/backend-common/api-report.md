## API Report File for "@backstage/backend-common"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts
/// <reference types="node" />
/// <reference types="webpack-env" />

import { AbortController as AbortController_2 } from 'node-abort-controller';
import { AbortSignal as AbortSignal_2 } from 'node-abort-controller';
import { AwsS3Integration } from '@backstage/integration';
import { AzureIntegration } from '@backstage/integration';
import { BitbucketCloudIntegration } from '@backstage/integration';
import { BitbucketIntegration } from '@backstage/integration';
import { BitbucketServerIntegration } from '@backstage/integration';
import { Config } from '@backstage/config';
import cors from 'cors';
import Docker from 'dockerode';
import { Duration } from 'luxon';
import { ErrorRequestHandler } from 'express';
import express from 'express';
import { GerritIntegration } from '@backstage/integration';
import { GithubCredentialsProvider } from '@backstage/integration';
import { GitHubIntegration } from '@backstage/integration';
import { GitLabIntegration } from '@backstage/integration';
import { isChildPath } from '@backstage/cli-common';
import { JsonValue } from '@backstage/types';
import { Knex } from 'knex';
import { LoadConfigOptionsRemote } from '@backstage/config-loader';
import { Logger } from 'winston';
import { MergeResult } from 'isomorphic-git';
import { PushResult } from 'isomorphic-git';
import { Readable } from 'stream';
import { ReadCommitResult } from 'isomorphic-git';
import { RequestHandler } from 'express';
import { Router } from 'express';
import { S3 } from 'aws-sdk';
import { Server } from 'http';
import * as winston from 'winston';
import { Writable } from 'stream';

// @public
export class AwsS3UrlReader implements UrlReader {
  constructor(
    integration: AwsS3Integration,
    deps: {
      s3: S3;
      treeResponseFactory: ReadTreeResponseFactory;
    },
  );
  // (undocumented)
  static factory: ReaderFactory;
  // (undocumented)
  read(url: string): Promise<Buffer>;
  // (undocumented)
  readTree(url: string, options?: ReadTreeOptions): Promise<ReadTreeResponse>;
  // (undocumented)
  readUrl(url: string, options?: ReadUrlOptions): Promise<ReadUrlResponse>;
  // (undocumented)
  search(): Promise<SearchResponse>;
  // (undocumented)
  toString(): string;
}

// @public
export class AzureUrlReader implements UrlReader {
  constructor(
    integration: AzureIntegration,
    deps: {
      treeResponseFactory: ReadTreeResponseFactory;
    },
  );
  // (undocumented)
  static factory: ReaderFactory;
  // (undocumented)
  read(url: string): Promise<Buffer>;
  // (undocumented)
  readTree(url: string, options?: ReadTreeOptions): Promise<ReadTreeResponse>;
  // (undocumented)
  readUrl(url: string, options?: ReadUrlOptions): Promise<ReadUrlResponse>;
  // (undocumented)
  search(url: string, options?: SearchOptions): Promise<SearchResponse>;
  // (undocumented)
  toString(): string;
}

// @public
export class BitbucketCloudUrlReader implements UrlReader {
  constructor(
    integration: BitbucketCloudIntegration,
    deps: {
      treeResponseFactory: ReadTreeResponseFactory;
    },
  );
  // (undocumented)
  static factory: ReaderFactory;
  // (undocumented)
  read(url: string): Promise<Buffer>;
  // (undocumented)
  readTree(url: string, options?: ReadTreeOptions): Promise<ReadTreeResponse>;
  // (undocumented)
  readUrl(url: string, options?: ReadUrlOptions): Promise<ReadUrlResponse>;
  // (undocumented)
  search(url: string, options?: SearchOptions): Promise<SearchResponse>;
  // (undocumented)
  toString(): string;
}

// @public
export class BitbucketServerUrlReader implements UrlReader {
  constructor(
    integration: BitbucketServerIntegration,
    deps: {
      treeResponseFactory: ReadTreeResponseFactory;
    },
  );
  // (undocumented)
  static factory: ReaderFactory;
  // (undocumented)
  read(url: string): Promise<Buffer>;
  // (undocumented)
  readTree(url: string, options?: ReadTreeOptions): Promise<ReadTreeResponse>;
  // (undocumented)
  readUrl(url: string, options?: ReadUrlOptions): Promise<ReadUrlResponse>;
  // (undocumented)
  search(url: string, options?: SearchOptions): Promise<SearchResponse>;
  // (undocumented)
  toString(): string;
}

// @public @deprecated
export class BitbucketUrlReader implements UrlReader {
  constructor(
    integration: BitbucketIntegration,
    logger: Logger,
    deps: {
      treeResponseFactory: ReadTreeResponseFactory;
    },
  );
  // (undocumented)
  static factory: ReaderFactory;
  // (undocumented)
  read(url: string): Promise<Buffer>;
  // (undocumented)
  readTree(url: string, options?: ReadTreeOptions): Promise<ReadTreeResponse>;
  // (undocumented)
  readUrl(url: string, options?: ReadUrlOptions): Promise<ReadUrlResponse>;
  // (undocumented)
  search(url: string, options?: SearchOptions): Promise<SearchResponse>;
  // (undocumented)
  toString(): string;
}

// @public
export interface CacheClient {
  delete(key: string): Promise<void>;
  get(key: string): Promise<JsonValue | undefined>;
  set(
    key: string,
    value: JsonValue,
    options?: CacheClientSetOptions,
  ): Promise<void>;
}

// @public
export type CacheClientOptions = {
  defaultTtl?: number;
};

// @public
export type CacheClientSetOptions = {
  ttl?: number;
};

// @public
export class CacheManager {
  forPlugin(pluginId: string): PluginCacheManager;
  static fromConfig(
    config: Config,
    options?: CacheManagerOptions,
  ): CacheManager;
}

// @public
export type CacheManagerOptions = {
  logger?: Logger;
  onError?: (err: Error) => void;
};

// @public
export const coloredFormat: winston.Logform.Format;

// @public
export interface ContainerRunner {
  runContainer(opts: RunContainerOptions): Promise<void>;
}

// @alpha
export interface Context {
  readonly abortSignal: AbortSignal_2;
  readonly deadline: Date | undefined;
  value<T = unknown>(key: string): T | undefined;
}

// @alpha
export class Contexts {
  static root(): Context;
  static withAbort(
    parentCtx: Context,
    source: AbortController_2 | AbortSignal_2,
  ): Context;
  static withTimeoutDuration(parentCtx: Context, timeout: Duration): Context;
  static withTimeoutMillis(parentCtx: Context, timeout: number): Context;
  static withValue(
    parentCtx: Context,
    key: string,
    value: unknown | ((previous: unknown | undefined) => unknown),
  ): Context;
}

// @public
export function createDatabaseClient(
  dbConfig: Config,
  overrides?: Partial<Knex.Config>,
): Knex<any, any[]>;

// @public
export function createRootLogger(
  options?: winston.LoggerOptions,
  env?: NodeJS.ProcessEnv,
): winston.Logger;

// @public
export function createServiceBuilder(_module: NodeModule): ServiceBuilder;

// @public
export function createStatusCheckRouter(options: {
  logger: Logger;
  path?: string;
  statusCheck?: StatusCheck;
}): Promise<express.Router>;

// @public
export class DatabaseManager {
  forPlugin(pluginId: string): PluginDatabaseManager;
  static fromConfig(
    config: Config,
    options?: DatabaseManagerOptions,
  ): DatabaseManager;
}

// @public
export type DatabaseManagerOptions = {
  migrations?: PluginDatabaseManager['migrations'];
};

// @public
export class DockerContainerRunner implements ContainerRunner {
  constructor(options: { dockerClient: Docker });
  // (undocumented)
  runContainer(options: RunContainerOptions): Promise<void>;
}

// @public
export function ensureDatabaseExists(
  dbConfig: Config,
  ...databases: Array<string>
): Promise<void>;

// @public
export function errorHandler(
  options?: ErrorHandlerOptions,
): ErrorRequestHandler;

// @public
export type ErrorHandlerOptions = {
  showStackTraces?: boolean;
  logger?: Logger;
  logClientErrors?: boolean;
};

// @public
export class FetchUrlReader implements UrlReader {
  static factory: ReaderFactory;
  // (undocumented)
  read(url: string): Promise<Buffer>;
  // (undocumented)
  readTree(): Promise<ReadTreeResponse>;
  // (undocumented)
  readUrl(url: string, options?: ReadUrlOptions): Promise<ReadUrlResponse>;
  // (undocumented)
  search(): Promise<SearchResponse>;
  // (undocumented)
  toString(): string;
}

// @public
export type FromReadableArrayOptions = Array<{
  data: Readable;
  path: string;
}>;

// @public
export class GerritUrlReader implements UrlReader {
  constructor(
    integration: GerritIntegration,
    deps: {
      treeResponseFactory: ReadTreeResponseFactory;
    },
    workDir: string,
  );
  // (undocumented)
  static factory: ReaderFactory;
  // (undocumented)
  read(url: string): Promise<Buffer>;
  // (undocumented)
  readTree(url: string, options?: ReadTreeOptions): Promise<ReadTreeResponse>;
  // (undocumented)
  readUrl(url: string, options?: ReadUrlOptions): Promise<ReadUrlResponse>;
  // (undocumented)
  search(): Promise<SearchResponse>;
  // (undocumented)
  toString(): string;
}

// @public
export function getRootLogger(): winston.Logger;

// @public
export function getVoidLogger(): winston.Logger;

// @public
export class Git {
  // (undocumented)
  add(options: { dir: string; filepath: string }): Promise<void>;
  // (undocumented)
  addRemote(options: {
    dir: string;
    remote: string;
    url: string;
  }): Promise<void>;
  clone(options: {
    url: string;
    dir: string;
    ref?: string;
    depth?: number;
    noCheckout?: boolean;
  }): Promise<void>;
  // (undocumented)
  commit(options: {
    dir: string;
    message: string;
    author: {
      name: string;
      email: string;
    };
    committer: {
      name: string;
      email: string;
    };
  }): Promise<string>;
  currentBranch(options: {
    dir: string;
    fullName?: boolean;
  }): Promise<string | undefined>;
  fetch(options: { dir: string; remote?: string }): Promise<void>;
  // (undocumented)
  static fromAuth: (options: {
    username?: string;
    password?: string;
    logger?: Logger;
  }) => Git;
  // (undocumented)
  init(options: { dir: string; defaultBranch?: string }): Promise<void>;
  log(options: { dir: string; ref?: string }): Promise<ReadCommitResult[]>;
  merge(options: {
    dir: string;
    theirs: string;
    ours?: string;
    author: {
      name: string;
      email: string;
    };
    committer: {
      name: string;
      email: string;
    };
  }): Promise<MergeResult>;
  // (undocumented)
  push(options: { dir: string; remote: string }): Promise<PushResult>;
  readCommit(options: { dir: string; sha: string }): Promise<ReadCommitResult>;
  resolveRef(options: { dir: string; ref: string }): Promise<string>;
}

// @public
export class GithubUrlReader implements UrlReader {
  constructor(
    integration: GitHubIntegration,
    deps: {
      treeResponseFactory: ReadTreeResponseFactory;
      credentialsProvider: GithubCredentialsProvider;
    },
  );
  // (undocumented)
  static factory: ReaderFactory;
  // (undocumented)
  read(url: string): Promise<Buffer>;
  // (undocumented)
  readTree(url: string, options?: ReadTreeOptions): Promise<ReadTreeResponse>;
  // (undocumented)
  readUrl(url: string, options?: ReadUrlOptions): Promise<ReadUrlResponse>;
  // (undocumented)
  search(url: string, options?: SearchOptions): Promise<SearchResponse>;
  // (undocumented)
  toString(): string;
}

// @public
export class GitlabUrlReader implements UrlReader {
  constructor(
    integration: GitLabIntegration,
    deps: {
      treeResponseFactory: ReadTreeResponseFactory;
    },
  );
  // (undocumented)
  static factory: ReaderFactory;
  // (undocumented)
  read(url: string): Promise<Buffer>;
  // (undocumented)
  readTree(url: string, options?: ReadTreeOptions): Promise<ReadTreeResponse>;
  // (undocumented)
  readUrl(url: string, options?: ReadUrlOptions): Promise<ReadUrlResponse>;
  // (undocumented)
  search(url: string, options?: SearchOptions): Promise<SearchResponse>;
  // (undocumented)
  toString(): string;
}

export { isChildPath };

// @public
export function isDatabaseConflictError(e: unknown): boolean;

// @public
export function loadBackendConfig(options: {
  logger: Logger;
  remote?: LoadConfigOptionsRemote;
  argv: string[];
}): Promise<Config>;

// @public
export function notFoundHandler(): RequestHandler;

// @public
export type PluginCacheManager = {
  getClient: (options?: CacheClientOptions) => CacheClient;
};

// @public
export interface PluginDatabaseManager {
  getClient(): Promise<Knex>;
  migrations?: {
    skip?: boolean;
  };
}

// @public
export type PluginEndpointDiscovery = {
  getBaseUrl(pluginId: string): Promise<string>;
  getExternalBaseUrl(pluginId: string): Promise<string>;
};

// @public
export type ReaderFactory = (options: {
  config: Config;
  logger: Logger;
  treeResponseFactory: ReadTreeResponseFactory;
}) => UrlReaderPredicateTuple[];

// @public
export type ReadTreeOptions = {
  filter?(
    path: string,
    info?: {
      size: number;
    },
  ): boolean;
  etag?: string;
  signal?: AbortSignal_2;
};

// @public
export type ReadTreeResponse = {
  files(): Promise<ReadTreeResponseFile[]>;
  archive(): Promise<NodeJS.ReadableStream>;
  dir(options?: ReadTreeResponseDirOptions): Promise<string>;
  etag: string;
};

// @public
export type ReadTreeResponseDirOptions = {
  targetDir?: string;
};

// @public
export interface ReadTreeResponseFactory {
  // (undocumented)
  fromReadableArray(
    options: FromReadableArrayOptions,
  ): Promise<ReadTreeResponse>;
  // (undocumented)
  fromTarArchive(
    options: ReadTreeResponseFactoryOptions,
  ): Promise<ReadTreeResponse>;
  // (undocumented)
  fromZipArchive(
    options: ReadTreeResponseFactoryOptions,
  ): Promise<ReadTreeResponse>;
}

// @public
export type ReadTreeResponseFactoryOptions = {
  stream: Readable;
  subpath?: string;
  etag: string;
  filter?: (
    path: string,
    info?: {
      size: number;
    },
  ) => boolean;
};

// @public
export type ReadTreeResponseFile = {
  path: string;
  content(): Promise<Buffer>;
};

// @public
export type ReadUrlOptions = {
  etag?: string;
  signal?: AbortSignal_2;
};

// @public
export type ReadUrlResponse = {
  buffer(): Promise<Buffer>;
  stream?(): Readable;
  etag?: string;
};

// @public
export class ReadUrlResponseFactory {
  static fromNodeJSReadable(
    oldStyleStream: NodeJS.ReadableStream,
    options?: ReadUrlResponseFactoryFromStreamOptions,
  ): Promise<ReadUrlResponse>;
  static fromReadable(
    stream: Readable,
    options?: ReadUrlResponseFactoryFromStreamOptions,
  ): Promise<ReadUrlResponse>;
}

// @public
export type ReadUrlResponseFactoryFromStreamOptions = {
  etag?: string;
};

// @public
export function requestLoggingHandler(logger?: Logger): RequestHandler;

// @public
export type RequestLoggingHandlerFactory = (logger?: Logger) => RequestHandler;

// @public
export function resolvePackagePath(name: string, ...paths: string[]): string;

// @public
export function resolveSafeChildPath(base: string, path: string): string;

// @public
export type RunContainerOptions = {
  imageName: string;
  command?: string | string[];
  args: string[];
  logStream?: Writable;
  mountDirs?: Record<string, string>;
  workingDir?: string;
  envVars?: Record<string, string>;
  pullImage?: boolean;
};

// @public
export type SearchOptions = {
  etag?: string;
  signal?: AbortSignal_2;
};

// @public
export type SearchResponse = {
  files: SearchResponseFile[];
  etag: string;
};

// @public
export type SearchResponseFile = {
  url: string;
  content(): Promise<Buffer>;
};

// @public
export class ServerTokenManager implements TokenManager {
  // (undocumented)
  authenticate(token: string): Promise<void>;
  // (undocumented)
  static fromConfig(
    config: Config,
    options: {
      logger: Logger;
    },
  ): ServerTokenManager;
  // (undocumented)
  getToken(): Promise<{
    token: string;
  }>;
  // (undocumented)
  static noop(): TokenManager;
}

// @public
export type ServiceBuilder = {
  loadConfig(config: Config): ServiceBuilder;
  setPort(port: number): ServiceBuilder;
  setHost(host: string): ServiceBuilder;
  setLogger(logger: Logger): ServiceBuilder;
  enableCors(options: cors.CorsOptions): ServiceBuilder;
  setHttpsSettings(settings: {
    certificate:
      | {
          key: string;
          cert: string;
        }
      | {
          hostname: string;
        };
  }): ServiceBuilder;
  addRouter(root: string, router: Router | RequestHandler): ServiceBuilder;
  setRequestLoggingHandler(
    requestLoggingHandler: RequestLoggingHandlerFactory,
  ): ServiceBuilder;
  setErrorHandler(errorHandler: ErrorRequestHandler): ServiceBuilder;
  disableDefaultErrorHandler(): ServiceBuilder;
  start(): Promise<Server>;
};

// @public
export function setRootLogger(newLogger: winston.Logger): void;

// @public
export class SingleHostDiscovery implements PluginEndpointDiscovery {
  static fromConfig(
    config: Config,
    options?: {
      basePath?: string;
    },
  ): SingleHostDiscovery;
  // (undocumented)
  getBaseUrl(pluginId: string): Promise<string>;
  // (undocumented)
  getExternalBaseUrl(pluginId: string): Promise<string>;
}

// @public
export type StatusCheck = () => Promise<any>;

// @public
export function statusCheckHandler(
  options?: StatusCheckHandlerOptions,
): Promise<RequestHandler>;

// @public
export interface StatusCheckHandlerOptions {
  statusCheck?: StatusCheck;
}

// @public
export interface TokenManager {
  // (undocumented)
  authenticate: (token: string) => Promise<void>;
  // (undocumented)
  getToken: () => Promise<{
    token: string;
  }>;
}

// @public
export type UrlReader = {
  read(url: string): Promise<Buffer>;
  readUrl?(url: string, options?: ReadUrlOptions): Promise<ReadUrlResponse>;
  readTree(url: string, options?: ReadTreeOptions): Promise<ReadTreeResponse>;
  search(url: string, options?: SearchOptions): Promise<SearchResponse>;
};

// @public
export type UrlReaderPredicateTuple = {
  predicate: (url: URL) => boolean;
  reader: UrlReader;
};

// @public
export class UrlReaders {
  static create(options: UrlReadersOptions): UrlReader;
  static default(options: UrlReadersOptions): UrlReader;
}

// @public
export type UrlReadersOptions = {
  config: Config;
  logger: Logger;
  factories?: ReaderFactory[];
};

// @public
export function useHotCleanup(
  _module: NodeModule,
  cancelEffect: () => void,
): void;

// @public
export function useHotMemoize<T>(_module: NodeModule, valueFactory: () => T): T;
```
