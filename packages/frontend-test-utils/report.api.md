## API Report File for "@backstage/frontend-test-utils"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts
import { AlertApi } from '@backstage/frontend-plugin-api';
import { AlertMessage } from '@backstage/frontend-plugin-api';
import { AnalyticsApi } from '@backstage/frontend-plugin-api';
import { AnalyticsEvent } from '@backstage/frontend-plugin-api';
import { ApiFactory } from '@backstage/frontend-plugin-api';
import { ApiHolder } from '@backstage/frontend-plugin-api';
import { ApiRef } from '@backstage/frontend-plugin-api';
import { AppNode } from '@backstage/frontend-plugin-api';
import { AppNodeInstance } from '@backstage/frontend-plugin-api';
import { ErrorWithContext } from '@backstage/test-utils';
import { ExtensionDataRef } from '@backstage/frontend-plugin-api';
import { ExtensionDefinition } from '@backstage/frontend-plugin-api';
import { ExtensionDefinitionParameters } from '@backstage/frontend-plugin-api';
import { FeatureFlag } from '@backstage/frontend-plugin-api';
import { FeatureFlagsApi } from '@backstage/frontend-plugin-api';
import { FeatureFlagsSaveOptions } from '@backstage/frontend-plugin-api';
import { FeatureFlagState } from '@backstage/frontend-plugin-api';
import { FrontendFeature } from '@backstage/frontend-plugin-api';
import { JsonObject } from '@backstage/types';
import { JSX as JSX_2 } from 'react/jsx-runtime';
import { mockApis as mockApis_2 } from '@backstage/test-utils';
import { MockConfigApi } from '@backstage/test-utils';
import { MockErrorApi } from '@backstage/test-utils';
import { MockErrorApiOptions } from '@backstage/test-utils';
import { MockFetchApi } from '@backstage/test-utils';
import { MockFetchApiOptions } from '@backstage/test-utils';
import { MockPermissionApi } from '@backstage/test-utils';
import { MockStorageApi } from '@backstage/test-utils';
import { MockStorageBucket } from '@backstage/test-utils';
import { Observable } from '@backstage/types';
import { ReactNode } from 'react';
import { registerMswTestHooks } from '@backstage/test-utils';
import { RenderResult } from '@testing-library/react';
import { RouteRef } from '@backstage/frontend-plugin-api';
import { testingLibraryDomTypesQueries } from '@testing-library/dom/types/queries';
import { withLogCollector } from '@backstage/test-utils';

// @public
export type ApiMock<TApi> = {
  factory: ApiFactory<TApi, TApi, {}>;
  [mockApiFactorySymbol]: ApiFactory<TApi, TApi, {}>;
} & {
  [Key in keyof TApi]: TApi[Key] extends (...args: infer Args) => infer Return
    ? TApi[Key] & jest.MockInstance<Return, Args>
    : TApi[Key];
};

// @public (undocumented)
export function createExtensionTester<
  T extends ExtensionDefinitionParameters,
  TApiPairs extends any[] = any[],
>(
  subject: ExtensionDefinition<T>,
  options?: {
    config?: T['configInput'];
    apis?: readonly [...TestApiPairs<TApiPairs>];
  },
): ExtensionTester<NonNullable<T['output']>>;

export { ErrorWithContext };

// @public (undocumented)
export class ExtensionQuery<UOutput extends ExtensionDataRef> {
  constructor(node: AppNode);
  // (undocumented)
  get<TId extends UOutput['id']>(
    ref: ExtensionDataRef<any, TId, any>,
  ): UOutput extends ExtensionDataRef<infer IData, TId, infer IConfig>
    ? IConfig['optional'] extends true
      ? IData | undefined
      : IData
    : never;
  // (undocumented)
  get instance(): AppNodeInstance;
  // (undocumented)
  get node(): AppNode;
}

// @public
export interface ExtensionSnapshotNode {
  children?: Record<string, ExtensionSnapshotNode[]>;
  disabled?: true;
  id: string;
  outputs?: string[];
}

// @public (undocumented)
export class ExtensionTester<UOutput extends ExtensionDataRef> {
  // (undocumented)
  add<T extends ExtensionDefinitionParameters>(
    extension: ExtensionDefinition<T>,
    options?: {
      config?: T['configInput'];
    },
  ): ExtensionTester<UOutput>;
  // (undocumented)
  get<TId extends UOutput['id']>(
    ref: ExtensionDataRef<any, TId, any>,
  ): UOutput extends ExtensionDataRef<infer IData, TId, infer IConfig>
    ? IConfig['optional'] extends true
      ? IData | undefined
      : IData
    : never;
  // (undocumented)
  query<T extends ExtensionDefinitionParameters>(
    extension: ExtensionDefinition<T>,
  ): ExtensionQuery<NonNullable<T['output']>>;
  // (undocumented)
  reactElement(): JSX.Element;
  snapshot(): ExtensionSnapshotNode;
}

// @public
export class MockAlertApi implements AlertApi {
  // (undocumented)
  alert$(): Observable<AlertMessage>;
  clearAlerts(): void;
  getAlerts(): AlertMessage[];
  // (undocumented)
  post(alert: AlertMessage): void;
  waitForAlert(
    predicate: (alert: AlertMessage) => boolean,
    timeoutMs?: number,
  ): Promise<AlertMessage>;
}

// @public
export class MockAnalyticsApi implements AnalyticsApi {
  // (undocumented)
  captureEvent(event: AnalyticsEvent): void;
  // (undocumented)
  getEvents(): AnalyticsEvent[];
}

// @public
export type MockApiFactorySymbol = typeof mockApiFactorySymbol;

// @public
export const mockApiFactorySymbol: unique symbol;

// @public
export namespace mockApis {
  export function alert(): MockWithApiFactory<MockAlertApi>;
  export namespace alert {
    const factory: () => any;
    const mock: (
      partialImpl?:
        | Partial<{
            post: jest.Mock<any, any, any>;
            alert$: jest.Mock<any, any, any>;
          }>
        | undefined,
    ) => ApiMock<{
      post: jest.Mock<any, any, any>;
      alert$: jest.Mock<any, any, any>;
    }>;
  }
  export function featureFlags(
    options?: MockFeatureFlagsApiOptions,
  ): MockWithApiFactory<MockFeatureFlagsApi>;
  export namespace featureFlags {
    const factory: (options?: MockFeatureFlagsApiOptions | undefined) => any;
    const mock: (
      partialImpl?:
        | Partial<{
            registerFlag: jest.Mock<any, any, any>;
            getRegisteredFlags: jest.Mock<any, any, any>;
            isActive: jest.Mock<any, any, any>;
            save: jest.Mock<any, any, any>;
          }>
        | undefined,
    ) => ApiMock<{
      registerFlag: jest.Mock<any, any, any>;
      getRegisteredFlags: jest.Mock<any, any, any>;
      isActive: jest.Mock<any, any, any>;
      save: jest.Mock<any, any, any>;
    }>;
  }
  const // (undocumented)
    analytics: typeof mockApis_2.analytics;
  const // (undocumented)
    config: typeof mockApis_2.config;
  const // (undocumented)
    discovery: typeof mockApis_2.discovery;
  const // (undocumented)
    identity: typeof mockApis_2.identity;
  const // (undocumented)
    permission: typeof mockApis_2.permission;
  const // (undocumented)
    storage: typeof mockApis_2.storage;
  const // (undocumented)
    translation: typeof mockApis_2.translation;
}

export { MockConfigApi };

export { MockErrorApi };

export { MockErrorApiOptions };

// @public
export class MockFeatureFlagsApi implements FeatureFlagsApi {
  constructor(options?: MockFeatureFlagsApiOptions);
  clearState(): void;
  // (undocumented)
  getRegisteredFlags(): FeatureFlag[];
  getState(): Record<string, FeatureFlagState>;
  // (undocumented)
  isActive(name: string): boolean;
  // (undocumented)
  registerFlag(flag: FeatureFlag): void;
  // (undocumented)
  save(options: FeatureFlagsSaveOptions): void;
  setState(states: Record<string, FeatureFlagState>): void;
}

// @public
export interface MockFeatureFlagsApiOptions {
  initialStates?: Record<string, FeatureFlagState>;
}

export { MockFetchApi };

export { MockFetchApiOptions };

export { MockPermissionApi };

export { MockStorageApi };

export { MockStorageBucket };

// @public
export type MockWithApiFactory<TApi> = TApi & {
  [mockApiFactorySymbol]: ApiFactory<TApi, TApi, {}>;
};

export { registerMswTestHooks };

// @public
export function renderInTestApp<TApiPairs extends any[] = any[]>(
  element: JSX.Element,
  options?: TestAppOptions<TApiPairs>,
): RenderResult;

// @public
export function renderTestApp<TApiPairs extends any[] = any[]>(
  options: RenderTestAppOptions<TApiPairs>,
): RenderResult<testingLibraryDomTypesQueries, HTMLElement, HTMLElement>;

// @public
export type RenderTestAppOptions<TApiPairs extends any[] = any[]> = {
  config?: JsonObject;
  extensions?: ExtensionDefinition<any>[];
  features?: FrontendFeature[];
  initialRouteEntries?: string[];
  mountedRoutes?: {
    [path: string]: RouteRef;
  };
  apis?: readonly [...TestApiPairs<TApiPairs>];
};

// @public
export type TestApiPairs<TApiPairs> = TestApiProviderPropsApiPairs<TApiPairs>;

// @public
export const TestApiProvider: <T extends any[]>(
  props: TestApiProviderProps<T>,
) => JSX_2.Element;

// @public
export type TestApiProviderEntry =
  | readonly [ApiRef<any>, any]
  | MockWithApiFactory<any>;

// @public
export type TestApiProviderProps<TApiPairs extends any[]> = {
  apis: readonly [
    ...(TestApiProviderPropsApiPairs<TApiPairs> | MockWithApiFactory<any>[]),
  ];
  children: ReactNode;
};

// @public
export type TestApiProviderPropsApiPair<TApi> = TApi extends infer TImpl
  ? readonly [ApiRef<TApi>, Partial<TImpl>]
  : never;

// @public
export type TestApiProviderPropsApiPairs<TApiPairs> = {
  [TIndex in keyof TApiPairs]: TestApiProviderPropsApiPair<TApiPairs[TIndex]>;
};

// @public
export class TestApiRegistry implements ApiHolder {
  static from(...apis: readonly TestApiProviderEntry[]): TestApiRegistry;
  get<T>(api: ApiRef<T>): T | undefined;
}

// @public
export type TestAppOptions<TApiPairs extends any[] = any[]> = {
  mountedRoutes?: {
    [path: string]: RouteRef;
  };
  config?: JsonObject;
  features?: FrontendFeature[];
  initialRouteEntries?: string[];
  apis?: readonly [...TestApiPairs<TApiPairs>];
};

export { withLogCollector };
```
