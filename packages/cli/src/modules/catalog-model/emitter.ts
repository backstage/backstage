/*
 * Copyright 2024 The Backstage Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import type { ZodTypeAny, ZodObject } from 'zod/v4';
import { zodToTs, printNode, createAuxiliaryTypeStore } from 'zod-to-ts';
import type { CatalogModelRegistry } from '@backstage/catalog-model-extensions';

/**
 * Generates TypeScript source from a resolved CatalogModelRegistry.
 * Uses zod-to-ts for schema-to-type conversion.
 */
export function emitTypeScript(registry: CatalogModelRegistry): string {
  const kindNames = registry.getKindNames();
  const lines: string[] = [];

  lines.push('// Auto-generated by backstage-cli repo catalog-model generate');
  lines.push('// Do not edit manually.');
  lines.push('');

  lines.push(emitBaseEntityTypes());
  lines.push('');

  for (const kindName of kindNames) {
    const metadata = registry.getKindMetadata(kindName)!;
    const specSchema = registry.getSpecSchema(kindName)!;
    const metadataSchema = registry.getMetadataSchema(kindName)!;

    lines.push(emitSpecInterface(kindName, specSchema));
    lines.push('');

    const annotationInterface = emitAnnotationInterface(
      kindName,
      metadataSchema,
    );
    if (annotationInterface) {
      lines.push(annotationInterface);
      lines.push('');
    }

    lines.push(
      emitEntityInterface(kindName, metadata, annotationInterface !== null),
    );
    lines.push('');

    lines.push(emitTypeGuard(kindName, metadata));
    lines.push('');
  }

  lines.push(emitTypeRegistry(kindNames, registry));
  lines.push('');
  lines.push(emitEntityUnion(kindNames));

  return lines.join('\n');
}

function emitBaseEntityTypes(): string {
  return `export type { Entity, EntityMeta } from '@backstage/catalog-model';
import type { Entity, EntityMeta } from '@backstage/catalog-model';`;
}

function schemaToTypeString(schema: ZodTypeAny): string {
  const store = createAuxiliaryTypeStore();
  const { node } = zodToTs(schema, { auxiliaryTypeStore: store });
  return printNode(node);
}

function emitSpecInterface(
  kindName: string,
  specSchema: ZodObject<any>,
): string {
  const typeStr = schemaToTypeString(specSchema);
  return `export type ${kindName}EntitySpec = ${typeStr};`;
}

function emitAnnotationInterface(
  kindName: string,
  metadataSchema: ZodObject<any>,
): string | null {
  const shape = metadataSchema.shape as Record<string, ZodTypeAny>;
  const annotationsField = shape.annotations;
  if (!annotationsField) return null;

  const innerSchema = unwrapOptional(annotationsField);
  const def = (innerSchema as any)?._zod?.def;
  if (def?.type !== 'object') return null;

  const annotationShape = (innerSchema as ZodObject<any>).shape as Record<
    string,
    ZodTypeAny
  >;
  if (Object.keys(annotationShape).length === 0) return null;

  const typeStr = schemaToTypeString(innerSchema);
  return `export type ${kindName}EntityAnnotations = ${typeStr};`;
}

function emitEntityInterface(
  kindName: string,
  metadata: { apiVersion: string },
  hasAnnotations: boolean,
): string {
  const lines: string[] = [];
  lines.push(`export type ${kindName}Entity = Entity & {`);
  lines.push(`  apiVersion: '${metadata.apiVersion}';`);
  lines.push(`  kind: '${kindName}';`);

  if (hasAnnotations) {
    lines.push(`  metadata: EntityMeta & {`);
    lines.push(`    annotations?: ${kindName}EntityAnnotations;`);
    lines.push(`  };`);
  }

  lines.push(`  spec: ${kindName}EntitySpec;`);
  lines.push('};');
  return lines.join('\n');
}

function emitTypeGuard(
  kindName: string,
  metadata: { apiVersion: string },
): string {
  return `export function is${kindName}Entity(entity: Entity): entity is ${kindName}Entity {
  return entity.apiVersion === '${metadata.apiVersion}' && entity.kind === '${kindName}';
}`;
}

function emitTypeRegistry(
  kindNames: string[],
  registry: CatalogModelRegistry,
): string {
  const lines: string[] = [];
  lines.push('export interface CatalogEntityTypeRegistry {');
  for (const kindName of kindNames) {
    const metadata = registry.getKindMetadata(kindName)!;
    lines.push(`  '${metadata.names.kind}': ${kindName}Entity;`);
  }
  lines.push('}');
  return lines.join('\n');
}

function emitEntityUnion(kindNames: string[]): string {
  const types = kindNames.map(k => `${k}Entity`);
  return `export type CatalogEntity = ${types.join(' | ')};`;
}

function unwrapOptional(schema: ZodTypeAny): ZodTypeAny {
  const def = (schema as any)?._zod?.def;
  if (def?.type === 'optional' || def?.type === 'default') {
    return def.innerType ?? schema;
  }
  return schema;
}
