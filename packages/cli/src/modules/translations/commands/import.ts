/*
 * Copyright 2026 The Backstage Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { paths } from '../../../lib/paths';
import fs from 'fs-extra';
import { resolve as resolvePath, relative as relativePath } from 'node:path';
import { readTargetPackage } from '../lib/discoverPackages';

interface ImportOptions {
  input: string;
  output: string;
}

interface ManifestRefEntry {
  package: string;
  exportPath: string;
  exportName: string;
}

interface Manifest {
  refs: Record<string, ManifestRefEntry>;
}

export default async (options: ImportOptions) => {
  await readTargetPackage(paths.targetDir, paths.targetRoot);

  const inputDir = resolvePath(paths.targetDir, options.input);
  const messagesDir = resolvePath(inputDir, 'messages');
  const manifestPath = resolvePath(inputDir, 'manifest.json');
  const outputPath = resolvePath(paths.targetDir, options.output);

  if (!(await fs.pathExists(manifestPath))) {
    throw new Error(
      `No manifest.json found at ${manifestPath}. ` +
        'Run "backstage-cli translations export" first.',
    );
  }

  if (!(await fs.pathExists(messagesDir))) {
    throw new Error(
      `No messages directory found at ${messagesDir}. ` +
        'Run "backstage-cli translations export" first.',
    );
  }

  const manifest: Manifest = await fs.readJson(manifestPath);

  // Find all translated (non-English) message files
  const files = await fs.readdir(messagesDir);
  const translatedFiles = files.filter(
    f => f.endsWith('.json') && !f.endsWith('.en.json'),
  );

  if (translatedFiles.length === 0) {
    console.log('No translated message files found.');
    console.log(
      'Add translated files as <ref-id>.<language>.json in the messages/ directory.',
    );
    return;
  }

  // Group translations by ref ID
  const translationsByRef = new Map<string, string[]>();
  for (const file of translatedFiles) {
    // Expected format: <ref-id>.<language>.json
    const match = file.match(/^(.+)\.([a-z]{2}(?:-[A-Z]{2})?)\.json$/);
    if (!match) {
      console.warn(`  Warning: skipping file with unexpected name: ${file}`);
      continue;
    }

    const [, refId, language] = match;
    if (!manifest.refs[refId]) {
      console.warn(
        `  Warning: skipping ${file} - ref '${refId}' not found in manifest`,
      );
      continue;
    }

    const existing = translationsByRef.get(refId) ?? [];
    existing.push(language);
    translationsByRef.set(refId, existing);
  }

  if (translationsByRef.size === 0) {
    console.log('No valid translation files found for known refs.');
    return;
  }

  // Generate the wiring module
  const importLines: string[] = [];
  const resourceLines: string[] = [];

  importLines.push(
    "import { createTranslationResource } from '@backstage/frontend-plugin-api';",
  );

  for (const [refId, languages] of [...translationsByRef.entries()].sort(
    ([a], [b]) => a.localeCompare(b),
  )) {
    const refEntry = manifest.refs[refId];
    const importPath =
      refEntry.exportPath === '.'
        ? refEntry.package
        : `${refEntry.package}/${refEntry.exportPath.replace(/^\.\//, '')}`;

    importLines.push(`import { ${refEntry.exportName} } from '${importPath}';`);

    const messagesRelPath = relativePath(
      resolvePath(outputPath, '..'),
      messagesDir,
    );

    const translationEntries = languages
      .sort()
      .map(
        lang =>
          `    ${JSON.stringify(
            lang,
          )}: () => import('./${messagesRelPath}/${refId}.${lang}.json'),`,
      )
      .join('\n');

    resourceLines.push(
      [
        `  createTranslationResource({`,
        `    ref: ${refEntry.exportName},`,
        `    translations: {`,
        translationEntries,
        `    },`,
        `  }),`,
      ].join('\n'),
    );
  }

  const fileContent = [
    '// This file is auto-generated by backstage-cli translations import',
    '// Do not edit manually.',
    '',
    ...importLines,
    '',
    'export default [',
    ...resourceLines,
    '];',
    '',
  ].join('\n');

  await fs.ensureDir(resolvePath(outputPath, '..'));
  await fs.writeFile(outputPath, fileContent, 'utf8');

  console.log(`Generated translation resources at ${options.output}`);
  console.log(
    `  ${translationsByRef.size} ref(s), ${translatedFiles.length} translation file(s)`,
  );
  console.log(
    '\nImport this file in your app and pass the resources to your translation API setup.',
  );
};
