## API Report File for "@backstage/backend-test-utils"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts
/// <reference types="jest" />
/// <reference types="node" />

import { Backend } from '@backstage/backend-app-api';
import { BackendFeature } from '@backstage/backend-plugin-api';
import { CacheService } from '@backstage/backend-plugin-api';
import { DatabaseService } from '@backstage/backend-plugin-api';
import { ExtendedHttpServer } from '@backstage/backend-app-api';
import { ExtensionPoint } from '@backstage/backend-plugin-api';
import { HttpRouterFactoryOptions } from '@backstage/backend-app-api';
import { HttpRouterService } from '@backstage/backend-plugin-api';
import { IdentityService } from '@backstage/backend-plugin-api';
import { JsonObject } from '@backstage/types';
import { Knex } from 'knex';
import { LifecycleService } from '@backstage/backend-plugin-api';
import { LoggerService } from '@backstage/backend-plugin-api';
import { PermissionsService } from '@backstage/backend-plugin-api';
import { RootConfigService } from '@backstage/backend-plugin-api';
import { RootHttpRouterFactoryOptions } from '@backstage/backend-app-api';
import { RootHttpRouterService } from '@backstage/backend-plugin-api';
import { RootLifecycleService } from '@backstage/backend-plugin-api';
import { RootLoggerService } from '@backstage/backend-plugin-api';
import { SchedulerService } from '@backstage/backend-plugin-api';
import { ServiceFactory } from '@backstage/backend-plugin-api';
import { ServiceRef } from '@backstage/backend-plugin-api';
import { TokenManagerService } from '@backstage/backend-plugin-api';
import { UrlReaderService } from '@backstage/backend-plugin-api';

// @public (undocumented)
export function isDockerDisabledForTests(): boolean;

// @public
export class MockDirectory {
  addContent(root: MockDirectoryContent): void;
  clear: () => void;
  content(
    options?: MockDirectoryContentOptions,
  ): MockDirectoryContent | undefined;
  static create(options?: MockDirectoryCreateOptions): MockDirectory;
  static mockOsTmpDir(): MockDirectory;
  get path(): string;
  remove: () => void;
  resolve(...paths: string[]): string;
  setContent(root: MockDirectoryContent): void;
}

// @public
export type MockDirectoryContent = {
  [name in string]: MockDirectoryContent | string | Buffer;
};

// @public
export interface MockDirectoryContentOptions {
  path?: string;
  shouldReadAsText?: boolean | ((path: string, buffer: Buffer) => boolean);
}

// @public
export interface MockDirectoryCreateOptions {
  root?: string;
}

// @public (undocumented)
export namespace mockServices {
  // (undocumented)
  export namespace cache {
    const // (undocumented)
      factory: () => ServiceFactory<CacheService, 'plugin'>;
    const // (undocumented)
      mock: (
        partialImpl?: Partial<CacheService> | undefined,
      ) => ServiceMock<CacheService>;
  }
  // (undocumented)
  export namespace database {
    const // (undocumented)
      factory: () => ServiceFactory<DatabaseService, 'plugin'>;
    const // (undocumented)
      mock: (
        partialImpl?: Partial<DatabaseService> | undefined,
      ) => ServiceMock<DatabaseService>;
  }
  // (undocumented)
  export namespace httpRouter {
    const // (undocumented)
      factory: (
        options?: HttpRouterFactoryOptions | undefined,
      ) => ServiceFactory<HttpRouterService, 'plugin'>;
    const // (undocumented)
      mock: (
        partialImpl?: Partial<HttpRouterService> | undefined,
      ) => ServiceMock<HttpRouterService>;
  }
  // (undocumented)
  export function identity(): IdentityService;
  // (undocumented)
  export namespace identity {
    const // (undocumented)
      factory: () => ServiceFactory<IdentityService, 'plugin'>;
    const // (undocumented)
      mock: (
        partialImpl?: Partial<IdentityService> | undefined,
      ) => ServiceMock<IdentityService>;
  }
  // (undocumented)
  export namespace lifecycle {
    const // (undocumented)
      factory: () => ServiceFactory<LifecycleService, 'plugin'>;
    const // (undocumented)
      mock: (
        partialImpl?: Partial<LifecycleService> | undefined,
      ) => ServiceMock<LifecycleService>;
  }
  // (undocumented)
  export namespace logger {
    const // (undocumented)
      factory: () => ServiceFactory<LoggerService, 'plugin'>;
    const // (undocumented)
      mock: (
        partialImpl?: Partial<LoggerService> | undefined,
      ) => ServiceMock<LoggerService>;
  }
  // (undocumented)
  export namespace permissions {
    const // (undocumented)
      factory: () => ServiceFactory<PermissionsService, 'plugin'>;
    const // (undocumented)
      mock: (
        partialImpl?: Partial<PermissionsService> | undefined,
      ) => ServiceMock<PermissionsService>;
  }
  // (undocumented)
  export function rootConfig(options?: rootConfig.Options): RootConfigService;
  // (undocumented)
  export namespace rootConfig {
    // (undocumented)
    export type Options = {
      data?: JsonObject;
    };
    const // (undocumented)
      factory: (
        options?: Options | undefined,
      ) => ServiceFactory<RootConfigService, 'root'>;
  }
  // (undocumented)
  export namespace rootHttpRouter {
    const // (undocumented)
      factory: (
        options?: RootHttpRouterFactoryOptions | undefined,
      ) => ServiceFactory<RootHttpRouterService, 'root'>;
    const // (undocumented)
      mock: (
        partialImpl?: Partial<RootHttpRouterService> | undefined,
      ) => ServiceMock<RootHttpRouterService>;
  }
  // (undocumented)
  export namespace rootLifecycle {
    const // (undocumented)
      factory: () => ServiceFactory<RootLifecycleService, 'root'>;
    const // (undocumented)
      mock: (
        partialImpl?: Partial<RootLifecycleService> | undefined,
      ) => ServiceMock<RootLifecycleService>;
  }
  // (undocumented)
  export function rootLogger(options?: rootLogger.Options): LoggerService;
  // (undocumented)
  export namespace rootLogger {
    // (undocumented)
    export type Options = {
      level?: 'none' | 'error' | 'warn' | 'info' | 'debug';
    };
    const // (undocumented)
      factory: (
        options?: Options | undefined,
      ) => ServiceFactory<LoggerService, 'root'>;
    const // (undocumented)
      mock: (
        partialImpl?: Partial<RootLoggerService> | undefined,
      ) => ServiceMock<RootLoggerService>;
  }
  // (undocumented)
  export namespace scheduler {
    const // (undocumented)
      factory: () => ServiceFactory<SchedulerService, 'plugin'>;
    const // (undocumented)
      mock: (
        partialImpl?: Partial<SchedulerService> | undefined,
      ) => ServiceMock<SchedulerService>;
  }
  // (undocumented)
  export function tokenManager(): TokenManagerService;
  // (undocumented)
  export namespace tokenManager {
    const // (undocumented)
      factory: () => ServiceFactory<TokenManagerService, 'plugin'>;
    const // (undocumented)
      mock: (
        partialImpl?: Partial<TokenManagerService> | undefined,
      ) => ServiceMock<TokenManagerService>;
  }
  // (undocumented)
  export namespace urlReader {
    const // (undocumented)
      factory: () => ServiceFactory<UrlReaderService, 'plugin'>;
    const // (undocumented)
      mock: (
        partialImpl?: Partial<UrlReaderService> | undefined,
      ) => ServiceMock<UrlReaderService>;
  }
}

// @public
export class ServiceFactoryTester<TService, TScope extends 'root' | 'plugin'> {
  static from<TService, TScope extends 'root' | 'plugin'>(
    subject:
      | ServiceFactory<TService, TScope>
      | (() => ServiceFactory<TService, TScope>),
    options?: ServiceFactoryTesterOptions,
  ): ServiceFactoryTester<TService, TScope>;
  get(
    ...args: 'root' extends TScope ? [] : [pluginId?: string]
  ): Promise<TService>;
  getService<TGetService, TGetScope extends 'root' | 'plugin'>(
    service: ServiceRef<TGetService, TGetScope>,
    ...args: 'root' extends TGetScope ? [] : [pluginId?: string]
  ): Promise<TGetService>;
}

// @public
export interface ServiceFactoryTesterOptions {
  dependencies?: Array<ServiceFactory | (() => ServiceFactory)>;
}

// @public (undocumented)
export type ServiceMock<TService> = {
  factory: ServiceFactory<TService>;
} & {
  [Key in keyof TService]: TService[Key] extends (
    ...args: infer Args
  ) => infer Return
    ? TService[Key] & jest.MockInstance<Return, Args>
    : TService[Key];
};

// @public
export function setupRequestMockHandlers(worker: {
  listen: (t: any) => void;
  close: () => void;
  resetHandlers: () => void;
}): void;

// @public (undocumented)
export function startTestBackend<TExtensionPoints extends any[]>(
  options: TestBackendOptions<TExtensionPoints>,
): Promise<TestBackend>;

// @public (undocumented)
export interface TestBackend extends Backend {
  readonly server: ExtendedHttpServer;
}

// @public (undocumented)
export interface TestBackendOptions<TExtensionPoints extends any[]> {
  // (undocumented)
  extensionPoints?: readonly [
    ...{
      [index in keyof TExtensionPoints]: [
        ExtensionPoint<TExtensionPoints[index]>,
        Partial<TExtensionPoints[index]>,
      ];
    },
  ];
  // (undocumented)
  features?: Array<
    | BackendFeature
    | (() => BackendFeature)
    | Promise<{
        default: BackendFeature | (() => BackendFeature);
      }>
  >;
}

// @public
export type TestDatabaseId =
  | 'POSTGRES_14'
  | 'POSTGRES_13'
  | 'POSTGRES_12'
  | 'POSTGRES_11'
  | 'POSTGRES_9'
  | 'MYSQL_8'
  | 'SQLITE_3';

// @public
export class TestDatabases {
  static create(options?: {
    ids?: TestDatabaseId[];
    disableDocker?: boolean;
  }): TestDatabases;
  // (undocumented)
  eachSupportedId(): [TestDatabaseId][];
  init(id: TestDatabaseId): Promise<Knex>;
  // (undocumented)
  supports(id: TestDatabaseId): boolean;
}
```
