## API Report File for "@backstage/plugin-techdocs-node"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts
/// <reference types="node" />

import { CompoundEntityRef } from '@backstage/catalog-model';
import { Config } from '@backstage/config';
import { ContainerRunner } from '@backstage/backend-common';
import { Entity } from '@backstage/catalog-model';
import express from 'express';
import { IndexableDocument } from '@backstage/plugin-search-common';
import { Logger } from 'winston';
import { PluginEndpointDiscovery } from '@backstage/backend-common';
import { ScmIntegrationRegistry } from '@backstage/integration';
import { UrlReader } from '@backstage/backend-common';
import { Writable } from 'stream';

// @public
export class DirectoryPreparer implements PreparerBase {
  static fromConfig(
    config: Config,
    { logger, reader }: PreparerConfig,
  ): DirectoryPreparer;
  prepare(entity: Entity, options?: PreparerOptions): Promise<PreparerResponse>;
}

// @public
export type ETag = string;

// @public
export type GeneratorBase = {
  run(opts: GeneratorRunOptions): Promise<void>;
};

// @public
export type GeneratorBuilder = {
  register(protocol: SupportedGeneratorKey, generator: GeneratorBase): void;
  get(entity: Entity): GeneratorBase;
};

// @public
export type GeneratorOptions = {
  containerRunner: ContainerRunner;
  logger: Logger;
};

// @public
export type GeneratorRunOptions = {
  inputDir: string;
  outputDir: string;
  parsedLocationAnnotation?: ParsedLocationAnnotation;
  etag?: string;
  logger: Logger;
  logStream?: Writable;
};

// @public
export class Generators implements GeneratorBuilder {
  static fromConfig(
    config: Config,
    options: {
      logger: Logger;
      containerRunner: ContainerRunner;
    },
  ): Promise<GeneratorBuilder>;
  get(entity: Entity): GeneratorBase;
  register(generatorKey: SupportedGeneratorKey, generator: GeneratorBase): void;
}

// @public
export const getDocFilesFromRepository: (
  reader: UrlReader,
  entity: Entity,
  opts?: {
    etag?: string;
    logger?: Logger;
  },
) => Promise<PreparerResponse>;

// @public
export const getLocationForEntity: (
  entity: Entity,
  scmIntegration: ScmIntegrationRegistry,
) => ParsedLocationAnnotation;

// @public
export type MigrateRequest = {
  removeOriginal?: boolean;
  concurrency?: number;
};

// @public
export type ParsedLocationAnnotation = {
  type: RemoteProtocol;
  target: string;
};

// @public
export const parseReferenceAnnotation: (
  annotationName: string,
  entity: Entity,
) => ParsedLocationAnnotation;

// @public
export type PreparerBase = {
  prepare(entity: Entity, options?: PreparerOptions): Promise<PreparerResponse>;
};

// @public
export type PreparerBuilder = {
  register(protocol: RemoteProtocol, preparer: PreparerBase): void;
  get(entity: Entity): PreparerBase;
};

// @public
export type PreparerConfig = {
  logger: Logger;
  reader: UrlReader;
};

// @public
export type PreparerOptions = {
  logger?: Logger;
  etag?: ETag;
};

// @public
export type PreparerResponse = {
  preparedDir: string;
  etag: ETag;
};

// @public
export class Preparers implements PreparerBuilder {
  static fromConfig(
    backstageConfig: Config,
    { logger, reader }: PreparerConfig,
  ): Promise<PreparerBuilder>;
  get(entity: Entity): PreparerBase;
  register(protocol: RemoteProtocol, preparer: PreparerBase): void;
}

// @public
export class Publisher {
  static fromConfig(
    config: Config,
    { logger, discovery }: PublisherFactory,
  ): Promise<PublisherBase>;
}

// @public
export interface PublisherBase {
  docsRouter(): express.Handler;
  fetchTechDocsMetadata(
    entityName: CompoundEntityRef,
  ): Promise<TechDocsMetadata>;
  getReadiness(): Promise<ReadinessResponse>;
  hasDocsBeenGenerated(entityName: Entity): Promise<boolean>;
  migrateDocsCase?(migrateRequest: MigrateRequest): Promise<void>;
  publish(request: PublishRequest): Promise<PublishResponse>;
}

// @public
export type PublisherFactory = {
  logger: Logger;
  discovery: PluginEndpointDiscovery;
};

// @public
export type PublisherType =
  | 'local'
  | 'googleGcs'
  | 'awsS3'
  | 'azureBlobStorage'
  | 'openStackSwift';

// @public
export type PublishRequest = {
  entity: Entity;
  directory: string;
};

// @public
export type PublishResponse = {
  remoteUrl?: string;
  objects?: string[];
} | void;

// @public
export type ReadinessResponse = {
  isAvailable: boolean;
};

// @public
export type RemoteProtocol = 'url' | 'dir';

// @public
export type SupportedGeneratorKey = 'techdocs' | string;

// @public
export interface TechDocsDocument extends IndexableDocument {
  kind: string;
  lifecycle: string;
  name: string;
  namespace: string;
  owner: string;
  path: string;
}

// @public
export class TechdocsGenerator implements GeneratorBase {
  constructor(options: {
    logger: Logger;
    containerRunner: ContainerRunner;
    config: Config;
    scmIntegrations: ScmIntegrationRegistry;
  });
  static readonly defaultDockerImage = 'spotify/techdocs:v1.0.3';
  static fromConfig(
    config: Config,
    options: GeneratorOptions,
  ): TechdocsGenerator;
  run(options: GeneratorRunOptions): Promise<void>;
}

// @public
export type TechDocsMetadata = {
  site_name: string;
  site_description: string;
  etag: string;
  build_timestamp: number;
  files?: string[];
};

// @public
export const transformDirLocation: (
  entity: Entity,
  dirAnnotation: ParsedLocationAnnotation,
  scmIntegrations: ScmIntegrationRegistry,
) => {
  type: 'dir' | 'url';
  target: string;
};

// @public
export class UrlPreparer implements PreparerBase {
  static fromConfig({ reader, logger }: PreparerConfig): UrlPreparer;
  prepare(entity: Entity, options?: PreparerOptions): Promise<PreparerResponse>;
}
```
