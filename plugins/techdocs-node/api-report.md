## API Report File for "@backstage/plugin-techdocs-node"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts
/// <reference types="node" />

import { CompoundEntityRef } from '@backstage/catalog-model';
import { Config } from '@backstage/config';
import { ContainerRunner } from '@backstage/backend-common';
import { Entity } from '@backstage/catalog-model';
import express from 'express';
import { ExtensionPoint } from '@backstage/backend-plugin-api';
import { IndexableDocument } from '@backstage/plugin-search-common';
import { Logger } from 'winston';
import { PluginEndpointDiscovery } from '@backstage/backend-common';
import { ScmIntegrationRegistry } from '@backstage/integration';
import { UrlReader } from '@backstage/backend-common';
import * as winston from 'winston';
import { Writable } from 'stream';

// @public
export class DirectoryPreparer implements PreparerBase {
  static fromConfig(config: Config, options: PreparerConfig): DirectoryPreparer;
  prepare(entity: Entity, options?: PreparerOptions): Promise<PreparerResponse>;
  shouldCleanPreparedDirectory(): boolean;
}

// @public
export interface DocsBuildStrategy {
  // (undocumented)
  shouldBuild(params: { entity: Entity }): Promise<boolean>;
}

// @public
export type ETag = string;

// @public
export type GeneratorBase = {
  run(opts: GeneratorRunOptions): Promise<void>;
};

// @public
export type GeneratorBuilder = {
  register(protocol: SupportedGeneratorKey, generator: GeneratorBase): void;
  get(entity: Entity): GeneratorBase;
};

// @public
export type GeneratorOptions = {
  logger: Logger;
  containerRunner?: ContainerRunner;
};

// @public
export type GeneratorRunOptions = {
  inputDir: string;
  outputDir: string;
  parsedLocationAnnotation?: ParsedLocationAnnotation;
  etag?: string;
  logger: Logger;
  logStream?: Writable;
  siteOptions?: {
    name?: string;
  };
  runAsDefaultUser?: boolean;
};

// @public
export class Generators implements GeneratorBuilder {
  static fromConfig(
    config: Config,
    options: {
      logger: Logger;
      containerRunner?: ContainerRunner;
      customGenerator?: TechdocsGenerator;
    },
  ): Promise<GeneratorBuilder>;
  get(entity: Entity): GeneratorBase;
  register(generatorKey: SupportedGeneratorKey, generator: GeneratorBase): void;
}

// @public
export const getDocFilesFromRepository: (
  reader: UrlReader,
  entity: Entity,
  opts?: {
    etag?: string;
    logger?: Logger;
  },
) => Promise<PreparerResponse>;

// @public
export const getLocationForEntity: (
  entity: Entity,
  scmIntegration: ScmIntegrationRegistry,
) => ParsedLocationAnnotation;

// @public @deprecated (undocumented)
export const getMkDocsYml: (
  inputDir: string,
  options?:
    | {
        name?: string | undefined;
        mkdocsConfigFileName?: string | undefined;
      }
    | undefined,
) => Promise<{
  path: string;
  content: string;
  configIsTemporary: boolean;
}>;

// @public
export const getMkdocsYml: (
  inputDir: string,
  options?: {
    name?: string;
    mkdocsConfigFileName?: string;
  },
) => Promise<{
  path: string;
  content: string;
  configIsTemporary: boolean;
}>;

// @public
export type MigrateRequest = {
  removeOriginal?: boolean;
  concurrency?: number;
};

// @public
export type ParsedLocationAnnotation = {
  type: RemoteProtocol;
  target: string;
};

// @public
export const parseReferenceAnnotation: (
  annotationName: string,
  entity: Entity,
) => ParsedLocationAnnotation;

// @public
export type PreparerBase = {
  prepare(entity: Entity, options?: PreparerOptions): Promise<PreparerResponse>;
  shouldCleanPreparedDirectory(): boolean;
};

// @public
export type PreparerBuilder = {
  register(protocol: RemoteProtocol, preparer: PreparerBase): void;
  get(entity: Entity): PreparerBase;
};

// @public
export type PreparerConfig = {
  logger: Logger;
  reader: UrlReader;
};

// @public
export type PreparerOptions = {
  logger?: Logger;
  etag?: ETag;
};

// @public
export type PreparerResponse = {
  preparedDir: string;
  etag: ETag;
};

// @public
export class Preparers implements PreparerBuilder {
  static fromConfig(
    backstageConfig: Config,
    options: PreparerConfig,
  ): Promise<PreparerBuilder>;
  get(entity: Entity): PreparerBase;
  register(protocol: RemoteProtocol, preparer: PreparerBase): void;
}

// @public
export class Publisher implements PublisherBuilder {
  static fromConfig(
    config: Config,
    options: PublisherFactory,
  ): Promise<PublisherBase>;
  // (undocumented)
  get(config: Config): PublisherBase;
  // (undocumented)
  register(type: PublisherType | 'techdocs', publisher: PublisherBase): void;
}

// @public
export interface PublisherBase {
  docsRouter(): express.Handler;
  fetchTechDocsMetadata(
    entityName: CompoundEntityRef,
  ): Promise<TechDocsMetadata>;
  getReadiness(): Promise<ReadinessResponse>;
  hasDocsBeenGenerated(entityName: Entity): Promise<boolean>;
  migrateDocsCase?(migrateRequest: MigrateRequest): Promise<void>;
  publish(request: PublishRequest): Promise<PublishResponse>;
}

// @public
export type PublisherBuilder = {
  register(type: PublisherType, publisher: PublisherBase): void;
  get(config: Config): PublisherBase;
};

// @public
export type PublisherFactory = {
  logger: Logger;
  discovery: PluginEndpointDiscovery;
  customPublisher?: PublisherBase | undefined;
};

// @public
export type PublisherType =
  | 'local'
  | 'googleGcs'
  | 'awsS3'
  | 'azureBlobStorage'
  | 'openStackSwift';

// @public
export type PublishRequest = {
  entity: Entity;
  directory: string;
};

// @public
export type PublishResponse = {
  remoteUrl?: string;
  objects?: string[];
} | void;

// @public
export type ReadinessResponse = {
  isAvailable: boolean;
};

// @public
export type RemoteProtocol = 'url' | 'dir';

// @public
export type SupportedGeneratorKey = 'techdocs' | string;

// @public
export interface TechdocsBuildsExtensionPoint {
  // (undocumented)
  setBuildLogTransport(transport: winston.transport): void;
  // (undocumented)
  setBuildStrategy(buildStrategy: DocsBuildStrategy): void;
}

// @public
export const techdocsBuildsExtensionPoint: ExtensionPoint<TechdocsBuildsExtensionPoint>;

// @public
export interface TechDocsDocument extends IndexableDocument {
  kind: string;
  lifecycle: string;
  name: string;
  namespace: string;
  owner: string;
  path: string;
}

// @public
export class TechdocsGenerator implements GeneratorBase {
  constructor(options: {
    logger: Logger;
    containerRunner?: ContainerRunner;
    config: Config;
    scmIntegrations: ScmIntegrationRegistry;
  });
  static readonly defaultDockerImage = 'spotify/techdocs:v1.2.4';
  static fromConfig(
    config: Config,
    options: GeneratorOptions,
  ): TechdocsGenerator;
  run(options: GeneratorRunOptions): Promise<void>;
}

// @public
export interface TechdocsGeneratorExtensionPoint {
  // (undocumented)
  setTechdocsGenerator(generator: TechdocsGenerator): void;
}

// @public
export const techdocsGeneratorExtensionPoint: ExtensionPoint<TechdocsGeneratorExtensionPoint>;

// @public
export type TechDocsMetadata = {
  site_name: string;
  site_description: string;
  etag: string;
  build_timestamp: number;
  files?: string[];
};

// @public
export interface TechdocsPreparerExtensionPoint {
  // (undocumented)
  registerPreparer(protocol: RemoteProtocol, preparer: PreparerBase): void;
}

// @public
export const techdocsPreparerExtensionPoint: ExtensionPoint<TechdocsPreparerExtensionPoint>;

// @public
export interface TechdocsPublisherExtensionPoint {
  // (undocumented)
  registerPublisher(type: PublisherType, publisher: PublisherBase): void;
}

// @public
export const techdocsPublisherExtensionPoint: ExtensionPoint<TechdocsPublisherExtensionPoint>;

// @public
export const transformDirLocation: (
  entity: Entity,
  dirAnnotation: ParsedLocationAnnotation,
  scmIntegrations: ScmIntegrationRegistry,
) => {
  type: 'dir' | 'url';
  target: string;
};

// @public
export class UrlPreparer implements PreparerBase {
  static fromConfig(options: PreparerConfig): UrlPreparer;
  prepare(entity: Entity, options?: PreparerOptions): Promise<PreparerResponse>;
  shouldCleanPreparedDirectory(): boolean;
}
```
