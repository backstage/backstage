## API Report File for "@backstage/plugin-catalog-node"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts
/// <reference types="node" />

import { CompoundEntityRef } from '@backstage/catalog-model';
import { Entity } from '@backstage/catalog-model';
import { ExtensionPoint } from '@backstage/backend-plugin-api';
import { JsonValue } from '@backstage/types';

// @alpha (undocumented)
export interface CatalogProcessingExtensionPoint {
  // (undocumented)
  addEntityProvider(
    ...providers: Array<EntityProvider | Array<EntityProvider>>
  ): void;
  // (undocumented)
  addProcessor(
    ...processors: Array<CatalogProcessor | Array<CatalogProcessor>>
  ): void;
}

// @alpha (undocumented)
export const catalogProcessingExtensionPoint: ExtensionPoint<CatalogProcessingExtensionPoint>;

// @public (undocumented)
export type CatalogProcessor = {
  getProcessorName(): string;
  readLocation?(
    location: LocationSpec,
    optional: boolean,
    emit: CatalogProcessorEmit,
    parser: CatalogProcessorParser,
    cache: CatalogProcessorCache,
  ): Promise<boolean>;
  preProcessEntity?(
    entity: Entity,
    location: LocationSpec,
    emit: CatalogProcessorEmit,
    originLocation: LocationSpec,
    cache: CatalogProcessorCache,
  ): Promise<Entity>;
  validateEntityKind?(entity: Entity): Promise<boolean>;
  postProcessEntity?(
    entity: Entity,
    location: LocationSpec,
    emit: CatalogProcessorEmit,
    cache: CatalogProcessorCache,
  ): Promise<Entity>;
};

// @public
export interface CatalogProcessorCache {
  get<ItemType extends JsonValue>(key: string): Promise<ItemType | undefined>;
  set<ItemType extends JsonValue>(key: string, value: ItemType): Promise<void>;
}

// @public (undocumented)
export type CatalogProcessorEmit = (generated: CatalogProcessorResult) => void;

// @public (undocumented)
export type CatalogProcessorEntityResult = {
  type: 'entity';
  entity: Entity;
  location: LocationSpec;
};

// @public (undocumented)
export type CatalogProcessorErrorResult = {
  type: 'error';
  error: Error;
  location: LocationSpec;
};

// @public (undocumented)
export type CatalogProcessorLocationResult = {
  type: 'location';
  location: LocationSpec;
};

// @public
export type CatalogProcessorParser = (options: {
  data: Buffer;
  location: LocationSpec;
}) => AsyncIterable<CatalogProcessorResult>;

// @public (undocumented)
export type CatalogProcessorRefreshKeysResult = {
  type: 'refresh';
  key: string;
};

// @public (undocumented)
export type CatalogProcessorRelationResult = {
  type: 'relation';
  relation: EntityRelationSpec;
};

// @public (undocumented)
export type CatalogProcessorResult =
  | CatalogProcessorLocationResult
  | CatalogProcessorEntityResult
  | CatalogProcessorRelationResult
  | CatalogProcessorErrorResult
  | CatalogProcessorRefreshKeysResult;

// @public
export type DeferredEntity = {
  entity: Entity;
  locationKey?: string;
};

// @public
export interface EntityProvider {
  connect(connection: EntityProviderConnection): Promise<void>;
  getProviderName(): string;
}

// @public
export interface EntityProviderConnection {
  applyMutation(mutation: EntityProviderMutation): Promise<void>;
}

// @public
export type EntityProviderMutation =
  | {
      type: 'full';
      entities: DeferredEntity[];
    }
  | {
      type: 'delta';
      added: DeferredEntity[];
      removed: DeferredEntity[];
    };

// @public
export type EntityRelationSpec = {
  source: CompoundEntityRef;
  type: string;
  target: CompoundEntityRef;
};

// @public
export type LocationSpec = {
  type: string;
  target: string;
  presence?: 'optional' | 'required';
};

// @public
export const processingResult: Readonly<{
  readonly notFoundError: (
    atLocation: LocationSpec,
    message: string,
  ) => CatalogProcessorResult;
  readonly inputError: (
    atLocation: LocationSpec,
    message: string,
  ) => CatalogProcessorResult;
  readonly generalError: (
    atLocation: LocationSpec,
    message: string,
  ) => CatalogProcessorResult;
  readonly location: (newLocation: LocationSpec) => CatalogProcessorResult;
  readonly entity: (
    atLocation: LocationSpec,
    newEntity: Entity,
  ) => CatalogProcessorResult;
  readonly relation: (spec: EntityRelationSpec) => CatalogProcessorResult;
  readonly refresh: (key: string) => CatalogProcessorResult;
}>;
```
