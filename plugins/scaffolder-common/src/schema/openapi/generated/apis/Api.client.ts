/*
 * Copyright 2025 The Backstage Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// ******************************************************************
// * THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY. *
// ******************************************************************
import { DiscoveryApi } from '../types/discovery';
import { FetchApi } from '../types/fetch';
import crossFetch from 'cross-fetch';
import { pluginId } from '../pluginId';
import * as parser from 'uri-template';
import { Action } from '../models/Action.model';
import { Autocomplete200Response } from '../models/Autocomplete200Response.model';
import { AutocompleteRequest } from '../models/AutocompleteRequest.model';
import { CancelTask200Response } from '../models/CancelTask200Response.model';
import { DryRun200Response } from '../models/DryRun200Response.model';
import { DryRunRequest } from '../models/DryRunRequest.model';
import { ListTasksResponse } from '../models/ListTasksResponse.model';
import { ListTemplatingExtensionsResponse } from '../models/ListTemplatingExtensionsResponse.model';
import { RetryRequest } from '../models/RetryRequest.model';
import { Scaffold201Response } from '../models/Scaffold201Response.model';
import { ScaffolderScaffoldOptions } from '../models/ScaffolderScaffoldOptions.model';
import { SerializedTask } from '../models/SerializedTask.model';
import { SerializedTaskEvent } from '../models/SerializedTaskEvent.model';
import { TemplateParameterSchema } from '../models/TemplateParameterSchema.model';

/**
 * Wraps the Response type to convey a type on the json call.
 *
 * @public
 */
export type TypedResponse<T> = Omit<Response, 'json'> & {
  json: () => Promise<T>;
};

/**
 * Options you can pass into a request for additional information.
 *
 * @public
 */
export interface RequestOptions {
  token?: string;
}
/**
 * @public
 */
export type Autocomplete = {
  path: {
    provider: string;
    resource: string;
  };
  body: AutocompleteRequest;
};
/**
 * @public
 */
export type CancelTask = {
  path: {
    taskId: string;
  };
};
/**
 * @public
 */
export type DryRun = {
  body: DryRunRequest;
};
/**
 * @public
 */
export type GetTask = {
  path: {
    taskId: string;
  };
};
/**
 * @public
 */
export type GetTemplateParameterSchema = {
  path: {
    namespace: string;
    kind: string;
    name: string;
  };
};
/**
 * @public
 */
export type ListActions = {};
/**
 * @public
 */
export type ListTasks = {
  query: {
    createdBy?: Array<string>;
    limit?: number;
    offset?: number;
    order?: Array<string>;
    status?: Array<string>;
  };
};
/**
 * @public
 */
export type ListTemplatingExtensions = {};
/**
 * @public
 */
export type Retry = {
  path: {
    taskId: string;
  };
  body: RetryRequest;
};
/**
 * @public
 */
export type Scaffold = {
  body: ScaffolderScaffoldOptions;
};
/**
 * @public
 */
export type StreamLogsPolling = {
  path: {
    taskId: string;
  };
  query: {
    after?: number;
  };
};

/**
 * @public
 */
export class DefaultApiClient {
  private readonly discoveryApi: DiscoveryApi;
  private readonly fetchApi: FetchApi;

  constructor(options: {
    discoveryApi: { getBaseUrl(pluginId: string): Promise<string> };
    fetchApi?: { fetch: typeof fetch };
  }) {
    this.discoveryApi = options.discoveryApi;
    this.fetchApi = options.fetchApi || { fetch: crossFetch };
  }

  /**
   * Perform an autocomplete for the given provider and resource.
   * @param provider -
   * @param resource -
   * @param autocompleteRequest -
   */
  public async autocomplete(
    // @ts-ignore
    request: Autocomplete,
    options?: RequestOptions,
  ): Promise<TypedResponse<Autocomplete200Response>> {
    const baseUrl = await this.discoveryApi.getBaseUrl(pluginId);

    const uriTemplate = `/v2/autocomplete/{provider}/{resource}`;

    const uri = parser.parse(uriTemplate).expand({
      provider: request.path.provider,
      resource: request.path.resource,
    });

    return await this.fetchApi.fetch(`${baseUrl}${uri}`, {
      headers: {
        'Content-Type': 'application/json',
        ...(options?.token && { Authorization: `Bearer ${options?.token}` }),
      },
      method: 'POST',
      body: JSON.stringify(request.body),
    });
  }

  /**
   * Sends a signal to a task broker to cancel the running task by taskId.
   * @param taskId -
   */
  public async cancelTask(
    // @ts-ignore
    request: CancelTask,
    options?: RequestOptions,
  ): Promise<TypedResponse<CancelTask200Response>> {
    const baseUrl = await this.discoveryApi.getBaseUrl(pluginId);

    const uriTemplate = `/v2/tasks/{taskId}/cancel`;

    const uri = parser.parse(uriTemplate).expand({
      taskId: request.path.taskId,
    });

    return await this.fetchApi.fetch(`${baseUrl}${uri}`, {
      headers: {
        'Content-Type': 'application/json',
        ...(options?.token && { Authorization: `Bearer ${options?.token}` }),
      },
      method: 'POST',
    });
  }

  /**
   * Perform a dry-run of a template
   * @param dryRunRequest -
   */
  public async dryRun(
    // @ts-ignore
    request: DryRun,
    options?: RequestOptions,
  ): Promise<TypedResponse<DryRun200Response>> {
    const baseUrl = await this.discoveryApi.getBaseUrl(pluginId);

    const uriTemplate = `/v2/dry-run`;

    const uri = parser.parse(uriTemplate).expand({});

    return await this.fetchApi.fetch(`${baseUrl}${uri}`, {
      headers: {
        'Content-Type': 'application/json',
        ...(options?.token && { Authorization: `Bearer ${options?.token}` }),
      },
      method: 'POST',
      body: JSON.stringify(request.body),
    });
  }

  /**
   * Get a task by ID.
   * @param taskId -
   */
  public async getTask(
    // @ts-ignore
    request: GetTask,
    options?: RequestOptions,
  ): Promise<TypedResponse<SerializedTask>> {
    const baseUrl = await this.discoveryApi.getBaseUrl(pluginId);

    const uriTemplate = `/v2/tasks/{taskId}`;

    const uri = parser.parse(uriTemplate).expand({
      taskId: request.path.taskId,
    });

    return await this.fetchApi.fetch(`${baseUrl}${uri}`, {
      headers: {
        'Content-Type': 'application/json',
        ...(options?.token && { Authorization: `Bearer ${options?.token}` }),
      },
      method: 'GET',
    });
  }

  /**
   * Get template parameter schema.
   * @param namespace -
   * @param kind -
   * @param name -
   */
  public async getTemplateParameterSchema(
    // @ts-ignore
    request: GetTemplateParameterSchema,
    options?: RequestOptions,
  ): Promise<TypedResponse<TemplateParameterSchema>> {
    const baseUrl = await this.discoveryApi.getBaseUrl(pluginId);

    const uriTemplate = `/v2/templates/{namespace}/{kind}/{name}/parameter-schema`;

    const uri = parser.parse(uriTemplate).expand({
      namespace: request.path.namespace,
      kind: request.path.kind,
      name: request.path.name,
    });

    return await this.fetchApi.fetch(`${baseUrl}${uri}`, {
      headers: {
        'Content-Type': 'application/json',
        ...(options?.token && { Authorization: `Bearer ${options?.token}` }),
      },
      method: 'GET',
    });
  }

  /**
   * Returns a list of all installed actions.
   */
  public async listActions(
    // @ts-ignore
    request: ListActions,
    options?: RequestOptions,
  ): Promise<TypedResponse<Array<Action>>> {
    const baseUrl = await this.discoveryApi.getBaseUrl(pluginId);

    const uriTemplate = `/v2/actions`;

    const uri = parser.parse(uriTemplate).expand({});

    return await this.fetchApi.fetch(`${baseUrl}${uri}`, {
      headers: {
        'Content-Type': 'application/json',
        ...(options?.token && { Authorization: `Bearer ${options?.token}` }),
      },
      method: 'GET',
    });
  }

  /**
   * Returns a list of tasks, filtering by ownership and/or status if given.
   * @param createdBy - Created by
   * @param limit - Number of records to return in the response.
   * @param offset - Number of records to skip in the query page.
   * @param order - Order
   * @param status - Status
   */
  public async listTasks(
    // @ts-ignore
    request: ListTasks,
    options?: RequestOptions,
  ): Promise<TypedResponse<ListTasksResponse>> {
    const baseUrl = await this.discoveryApi.getBaseUrl(pluginId);

    const uriTemplate = `/v2/tasks{?createdBy*,limit,offset,order*,status*}`;

    const uri = parser.parse(uriTemplate).expand({
      ...request.query,
    });

    return await this.fetchApi.fetch(`${baseUrl}${uri}`, {
      headers: {
        'Content-Type': 'application/json',
        ...(options?.token && { Authorization: `Bearer ${options?.token}` }),
      },
      method: 'GET',
    });
  }

  /**
   * Returns a structure describing the available templating extensions.
   */
  public async listTemplatingExtensions(
    // @ts-ignore
    request: ListTemplatingExtensions,
    options?: RequestOptions,
  ): Promise<TypedResponse<ListTemplatingExtensionsResponse>> {
    const baseUrl = await this.discoveryApi.getBaseUrl(pluginId);

    const uriTemplate = `/v2/templating-extensions`;

    const uri = parser.parse(uriTemplate).expand({});

    return await this.fetchApi.fetch(`${baseUrl}${uri}`, {
      headers: {
        'Content-Type': 'application/json',
        ...(options?.token && { Authorization: `Bearer ${options?.token}` }),
      },
      method: 'GET',
    });
  }

  /**
   * Starts the task again from the point where it failed.
   * @param taskId -
   * @param retryRequest -
   */
  public async retry(
    // @ts-ignore
    request: Retry,
    options?: RequestOptions,
  ): Promise<TypedResponse<Scaffold201Response>> {
    const baseUrl = await this.discoveryApi.getBaseUrl(pluginId);

    const uriTemplate = `/v2/tasks/{taskId}/retry`;

    const uri = parser.parse(uriTemplate).expand({
      taskId: request.path.taskId,
    });

    return await this.fetchApi.fetch(`${baseUrl}${uri}`, {
      headers: {
        'Content-Type': 'application/json',
        ...(options?.token && { Authorization: `Bearer ${options?.token}` }),
      },
      method: 'POST',
      body: JSON.stringify(request.body),
    });
  }

  /**
   * Executes the scaffolding of a component, given a template and its parameter values.
   * @param scaffolderScaffoldOptions -
   */
  public async scaffold(
    // @ts-ignore
    request: Scaffold,
    options?: RequestOptions,
  ): Promise<TypedResponse<Scaffold201Response>> {
    const baseUrl = await this.discoveryApi.getBaseUrl(pluginId);

    const uriTemplate = `/v2/tasks`;

    const uri = parser.parse(uriTemplate).expand({});

    return await this.fetchApi.fetch(`${baseUrl}${uri}`, {
      headers: {
        'Content-Type': 'application/json',
        ...(options?.token && { Authorization: `Bearer ${options?.token}` }),
      },
      method: 'POST',
      body: JSON.stringify(request.body),
    });
  }

  /**
   * Get events for a task by ID.
   * @param taskId -
   * @param after - Offset event ID to stream events after.
   */
  public async streamLogsPolling(
    // @ts-ignore
    request: StreamLogsPolling,
    options?: RequestOptions,
  ): Promise<TypedResponse<Array<SerializedTaskEvent>>> {
    const baseUrl = await this.discoveryApi.getBaseUrl(pluginId);

    const uriTemplate = `/v2/tasks/{taskId}/events{?after}`;

    const uri = parser.parse(uriTemplate).expand({
      taskId: request.path.taskId,
      ...request.query,
    });

    return await this.fetchApi.fetch(`${baseUrl}${uri}`, {
      headers: {
        'Content-Type': 'application/json',
        ...(options?.token && { Authorization: `Bearer ${options?.token}` }),
      },
      method: 'GET',
    });
  }
}
