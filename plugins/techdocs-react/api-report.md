## API Report File for "@backstage/plugin-techdocs-react"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts
import { ApiRef } from '@backstage/core-plugin-api';
import { AsyncState } from 'react-use/lib/useAsync';
import { ComponentType } from 'react';
import { CompoundEntityRef } from '@backstage/catalog-model';
import { Config } from '@backstage/config';
import { Dispatch } from 'react';
import { Entity } from '@backstage/catalog-model';
import { Extension } from '@backstage/core-plugin-api';
import { PropsWithChildren } from 'react';
import { default as React_2 } from 'react';
import { ReactNode } from 'react';
import { SetStateAction } from 'react';

// @public
export function createTechDocsAddonExtension(
  options: TechDocsAddonOptions,
): Extension<() => JSX.Element | null>;

// @public
export function createTechDocsAddonExtension<TComponentProps>(
  options: TechDocsAddonOptions<TComponentProps>,
): Extension<(props: TComponentProps) => JSX.Element | null>;

// @public
export const SHADOW_DOM_STYLE_LOAD_EVENT = 'TECH_DOCS_SHADOW_DOM_STYLE_LOAD';

// @public
export type SyncResult = 'cached' | 'updated';

// @public
export const TECHDOCS_ADDONS_WRAPPER_KEY = 'techdocs.addons.wrapper.v1';

// @public
export const TechDocsAddonLocations: Readonly<{
  readonly Header: 'Header';
  readonly Subheader: 'Subheader';
  readonly Settings: 'Settings';
  readonly PrimarySidebar: 'PrimarySidebar';
  readonly SecondarySidebar: 'SecondarySidebar';
  readonly Content: 'Content';
}>;

// @public
export type TechDocsAddonOptions<TAddonProps = {}> = {
  name: string;
  location: keyof typeof TechDocsAddonLocations;
  component: ComponentType<TAddonProps>;
};

// @public
export const TechDocsAddons: React_2.ComponentType;

// @public
export interface TechDocsApi {
  // (undocumented)
  getApiOrigin(): Promise<string>;
  // (undocumented)
  getEntityMetadata(
    entityId: CompoundEntityRef,
  ): Promise<TechDocsEntityMetadata>;
  // (undocumented)
  getTechDocsMetadata(entityId: CompoundEntityRef): Promise<TechDocsMetadata>;
}

// @public
export const techdocsApiRef: ApiRef<TechDocsApi>;

// @public
export type TechDocsEntityMetadata = Entity & {
  locationMetadata?: {
    type: string;
    target: string;
  };
};

// @public
export type TechDocsMetadata = {
  site_name: string;
  site_description: string;
};

// @public
export const TechDocsReaderPageContentProvider: ({
  children,
}: TechDocsReaderPageContentProviderProps) => JSX.Element;

// @public
export type TechDocsReaderPageContentProviderProps = {
  children: TechDocsReaderPageContentProviderRenderFunction | ReactNode;
};

// @public
export type TechDocsReaderPageContentProviderRenderFunction = (
  value: TechDocsReaderPageContentState,
) => JSX.Element;

// @public
export type TechDocsReaderPageContentState = {
  state: TechDocsReaderPageContentStateTypes;
  path: string;
  contentReload: () => void;
  content?: string;
  contentErrorMessage?: string;
  syncErrorMessage?: string;
  buildLog: string[];
};

// @public
export type TechDocsReaderPageContentStateTypes =
  /** There is nothing to display but a loading indicator */
  | 'CHECKING'
  /** There is no content yet -> present a full screen loading page */
  | 'INITIAL_BUILD'
  /** There is content, but the backend is about to update it */
  | 'CONTENT_STALE_REFRESHING'
  /** There is content, but after a reload, the content will be different */
  | 'CONTENT_STALE_READY'
  /** There is content, the backend tried to update it, but failed */
  | 'CONTENT_STALE_ERROR'
  /** There is nothing to see but a "not found" page. Is also shown on page load errors */
  | 'CONTENT_NOT_FOUND'
  /** There is only the latest and greatest content */
  | 'CONTENT_FRESH';

// @public
export const TechDocsReaderPageProvider: React_2.MemoExoticComponent<
  ({ entityRef, children }: TechDocsReaderPageProviderProps) => JSX.Element
>;

// @public
export type TechDocsReaderPageProviderProps = {
  entityRef: CompoundEntityRef;
  children: TechDocsReaderPageProviderRenderFunction | ReactNode;
};

// @public
export type TechDocsReaderPageProviderRenderFunction = (
  value: TechDocsReaderPageValue,
) => JSX.Element;

// @public
export type TechDocsReaderPageValue = {
  metadata: AsyncState<TechDocsMetadata>;
  entityRef: CompoundEntityRef;
  entityMetadata: AsyncState<TechDocsEntityMetadata>;
  shadowRoot?: ShadowRoot;
  setShadowRoot: Dispatch<SetStateAction<ShadowRoot | undefined>>;
  title: string;
  setTitle: Dispatch<SetStateAction<string>>;
  subtitle: string;
  setSubtitle: Dispatch<SetStateAction<string>>;
  ready: boolean;
  setReady: Dispatch<SetStateAction<boolean>>;
  onReady?: () => void;
};

// @public
export const TechDocsShadowDom: ({
  element,
  onAppend,
  children,
}: TechDocsShadowDomProps) => JSX.Element;

// @public
export type TechDocsShadowDomProps = PropsWithChildren<{
  element: Element;
  onAppend?: (shadowRoot: ShadowRoot) => void;
}>;

// @public
export interface TechDocsStorageApi {
  // (undocumented)
  getApiOrigin(): Promise<string>;
  // (undocumented)
  getBaseUrl(
    oldBaseUrl: string,
    entityId: CompoundEntityRef,
    path: string,
  ): Promise<string>;
  // (undocumented)
  getBuilder(): Promise<string>;
  // (undocumented)
  getEntityDocs(entityId: CompoundEntityRef, path: string): Promise<string>;
  // (undocumented)
  getStorageUrl(): Promise<string>;
  // (undocumented)
  syncEntityDocs(
    entityId: CompoundEntityRef,
    logHandler?: (line: string) => void,
  ): Promise<SyncResult>;
}

// @public
export const techdocsStorageApiRef: ApiRef<TechDocsStorageApi>;

// @public
export function toLowercaseEntityRefMaybe(
  entityRef: CompoundEntityRef,
  config: Config,
): CompoundEntityRef;

// @public
export const useShadowDomStylesLoading: (element: Element | null) => boolean;

// @public
export const useShadowRoot: () => ShadowRoot | undefined;

// @public
export const useShadowRootElements: <
  TReturnedElement extends HTMLElement = HTMLElement,
>(
  selectors: string[],
) => TReturnedElement[];

// @public
export const useShadowRootSelection: (wait?: number) => Selection | null;

// @public
export const useTechDocsAddons: () => {
  renderComponentByName: (name: string) => JSX.Element | null;
  renderComponentsByLocation: (
    location: keyof typeof TechDocsAddonLocations,
  ) => (JSX.Element | null)[] | null;
};

// @public
export const useTechDocsReaderPage: () => TechDocsReaderPageValue;

// @public
export const useTechDocsReaderPageContent: () => TechDocsReaderPageContentState;

// @public
export const withTechDocsReaderPageContentProvider: <T extends {}>(
  Component: React_2.ComponentType<T>,
) => (props: T) => JSX.Element;
```
