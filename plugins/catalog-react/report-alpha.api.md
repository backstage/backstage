## API Report File for "@backstage/plugin-catalog-react"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts
import { AnyRouteRefParams } from '@backstage/frontend-plugin-api';
import { ComponentType } from 'react';
import { ConfigurableExtensionDataRef } from '@backstage/frontend-plugin-api';
import { Entity } from '@backstage/catalog-model';
import { ExtensionBlueprint } from '@backstage/frontend-plugin-api';
import { ExtensionDataRef } from '@backstage/frontend-plugin-api';
import { ExtensionDefinition } from '@backstage/frontend-plugin-api';
import { IconLinkVerticalProps } from '@backstage/core-components';
import { JsonValue } from '@backstage/types';
import { JSX as JSX_2 } from 'react';
import { ReactNode } from 'react';
import { ResourcePermission } from '@backstage/plugin-permission-common';
import { RouteRef } from '@backstage/frontend-plugin-api';
import { TranslationRef } from '@backstage/frontend-plugin-api';

// @alpha
export const CatalogFilterBlueprint: ExtensionBlueprint<{
  kind: 'catalog-filter';
  params: {
    loader: () => Promise<JSX.Element>;
  };
  output: ExtensionDataRef<JSX_2.Element, 'core.reactElement', {}>;
  inputs: {};
  config: {};
  configInput: {};
  dataRefs: never;
}>;

// @alpha (undocumented)
export const catalogReactTranslationRef: TranslationRef<
  'catalog-react',
  {
    readonly 'catalogFilter.title': 'Filters';
    readonly 'catalogFilter.buttonTitle': 'Filters';
    readonly 'entityKindPicker.title': 'Kind';
    readonly 'entityKindPicker.errorMessage': 'Failed to load entity kinds';
    readonly 'entityLifecyclePicker.title': 'Lifecycle';
    readonly 'entityNamespacePicker.title': 'Namespace';
    readonly 'entityOwnerPicker.title': 'Owner';
    readonly 'entityProcessingStatusPicker.title': 'Processing Status';
    readonly 'entityTagPicker.title': 'Tags';
    readonly 'entityPeekAheadPopover.title': 'Drill into the entity to see all of the tags.';
    readonly 'entityPeekAheadPopover.entityCardActionsAriaLabel': 'Show';
    readonly 'entityPeekAheadPopover.entityCardActionsTitle': 'Show details';
    readonly 'entityPeekAheadPopover.emailCardAction.title': 'Email {{email}}';
    readonly 'entityPeekAheadPopover.emailCardAction.ariaLabel': 'Email';
    readonly 'entityPeekAheadPopover.emailCardAction.subTitle': 'mailto {{email}}';
    readonly 'entitySearchBar.placeholder': 'Search';
    readonly 'entityTypePicker.title': 'Type';
    readonly 'entityTypePicker.errorMessage': 'Failed to load entity types';
    readonly 'entityTypePicker.optionAllTitle': 'all';
    readonly 'favoriteEntity.addToFavorites': 'Add to favorites';
    readonly 'favoriteEntity.removeFromFavorites': 'Remove from favorites';
    readonly 'inspectEntityDialog.title': 'Entity Inspector';
    readonly 'inspectEntityDialog.closeButtonTitle': 'Close';
    readonly 'inspectEntityDialog.tabsAriaLabel': 'Inspector options';
    readonly 'inspectEntityDialog.ancestryPage.title': 'Ancestry';
    readonly 'inspectEntityDialog.ancestryPage.description': 'This is the ancestry of entities above the current one - as in, the chain(s) of entities down to the current one, where {{processorsLink}} child entities that ultimately led to the current one existing. Note that this is a completely different mechanism from relations.';
    readonly 'inspectEntityDialog.ancestryPage.processorsLink': 'processors emitted';
    readonly 'inspectEntityDialog.colocatedPage.title': 'Colocated';
    readonly 'inspectEntityDialog.colocatedPage.description': 'These are the entities that are colocated with this entity - as in, they originated from the same data source (e.g. came from the same YAML file), or from the same origin (e.g. the originally registered URL).';
    readonly 'inspectEntityDialog.colocatedPage.alertNoLocation': 'Entity had no location information.';
    readonly 'inspectEntityDialog.colocatedPage.alertNoEntity': 'There were no other entities on this location.';
    readonly 'inspectEntityDialog.colocatedPage.locationHeader': 'At the same location';
    readonly 'inspectEntityDialog.colocatedPage.originHeader': 'At the same origin';
    readonly 'inspectEntityDialog.jsonPage.title': 'Entity as JSON';
    readonly 'inspectEntityDialog.jsonPage.description': 'This is the raw entity data as received from the catalog, on JSON form.';
    readonly 'inspectEntityDialog.overviewPage.title': 'Overview';
    readonly 'inspectEntityDialog.overviewPage.metadata.title': 'Metadata';
    readonly 'inspectEntityDialog.overviewPage.labels': 'Labels';
    readonly 'inspectEntityDialog.overviewPage.status.title': 'Status';
    readonly 'inspectEntityDialog.overviewPage.identity.title': 'Identity';
    readonly 'inspectEntityDialog.overviewPage.annotations': 'Annotations';
    readonly 'inspectEntityDialog.overviewPage.tags': 'Tags';
    readonly 'inspectEntityDialog.overviewPage.relation.title': 'Relations';
    readonly 'inspectEntityDialog.yamlPage.title': 'Entity as YAML';
    readonly 'inspectEntityDialog.yamlPage.description': 'This is the raw entity data as received from the catalog, on YAML form.';
    readonly 'inspectEntityDialog.tabNames.json': 'Raw JSON';
    readonly 'inspectEntityDialog.tabNames.yaml': 'Raw YAML';
    readonly 'inspectEntityDialog.tabNames.overview': 'Overview';
    readonly 'inspectEntityDialog.tabNames.ancestry': 'Ancestry';
    readonly 'inspectEntityDialog.tabNames.colocated': 'Colocated';
    readonly 'unregisterEntityDialog.title': 'Are you sure you want to unregister this entity?';
    readonly 'unregisterEntityDialog.cancelButtonTitle': 'Cancel';
    readonly 'unregisterEntityDialog.deleteButtonTitle': 'Delete Entity';
    readonly 'unregisterEntityDialog.deleteEntitySuccessMessage': 'Removed entity {{entityName}}';
    readonly 'unregisterEntityDialog.onlyDeleteStateTitle': 'This entity does not seem to originate from a registered location. You therefore only have the option to delete it outright from the catalog.';
    readonly 'unregisterEntityDialog.errorStateTitle': 'Internal error: Unknown state';
    readonly 'unregisterEntityDialog.bootstrapState.title': 'You cannot unregister this entity, since it originates from a protected Backstage configuration (location "{{location}}"). If you believe this is in error, please contact the {{appTitle}} integrator.';
    readonly 'unregisterEntityDialog.bootstrapState.advancedDescription': 'You have the option to delete the entity itself from the catalog. Note that this should only be done if you know that the catalog file has been deleted at, or moved from, its origin location. If that is not the case, the entity will reappear shortly as the next refresh round is performed by the catalog.';
    readonly 'unregisterEntityDialog.bootstrapState.advancedOptions': 'Advanced Options';
    readonly 'unregisterEntityDialog.unregisterState.title': 'This action will unregister the following entities:';
    readonly 'unregisterEntityDialog.unregisterState.description': 'To undo, just re-register the entity in {{appTitle}}.';
    readonly 'unregisterEntityDialog.unregisterState.subTitle': 'Located at the following location:';
    readonly 'unregisterEntityDialog.unregisterState.advancedDescription': 'You also have the option to delete the entity itself from the catalog. Note that this should only be done if you know that the catalog file has been deleted at, or moved from, its origin location. If that is not the case, the entity will reappear shortly as the next refresh round is performed by the catalog.';
    readonly 'unregisterEntityDialog.unregisterState.advancedOptions': 'Advanced Options';
    readonly 'unregisterEntityDialog.unregisterState.unregisterButtonTitle': 'Unregister Location';
    readonly 'userListPicker.defaultOrgName': 'Company';
    readonly 'userListPicker.orgFilterAllLabel': 'All';
    readonly 'userListPicker.personalFilter.title': 'Personal';
    readonly 'userListPicker.personalFilter.ownedLabel': 'Owned';
    readonly 'userListPicker.personalFilter.starredLabel': 'Starred';
    readonly 'entityTableColumnTitle.name': 'Name';
    readonly 'entityTableColumnTitle.type': 'Type';
    readonly 'entityTableColumnTitle.label': 'Label';
    readonly 'entityTableColumnTitle.title': 'Title';
    readonly 'entityTableColumnTitle.description': 'Description';
    readonly 'entityTableColumnTitle.domain': 'Domain';
    readonly 'entityTableColumnTitle.system': 'System';
    readonly 'entityTableColumnTitle.namespace': 'Namespace';
    readonly 'entityTableColumnTitle.tags': 'Tags';
    readonly 'entityTableColumnTitle.lifecycle': 'Lifecycle';
    readonly 'entityTableColumnTitle.owner': 'Owner';
    readonly 'entityTableColumnTitle.targets': 'Targets';
    readonly 'missingAnnotationEmptyState.title': 'Missing Annotation';
    readonly 'missingAnnotationEmptyState.readMore': 'Read more';
    readonly 'missingAnnotationEmptyState.annotationYaml': 'Add the annotation to your {{entityKind}} YAML as shown in the highlighted example below:';
    readonly 'missingAnnotationEmptyState.generateDescription_one': 'The annotation {{annotations}} is missing. You need to add the annotation to your {{entityKind}} if you want to enable this tool.';
    readonly 'missingAnnotationEmptyState.generateDescription_other': 'The annotations {{annotations}} are missing. You need to add the annotations to your {{entityKind}} if you want to enable this tool.';
  }
>;

// @alpha (undocumented)
export function convertLegacyEntityCardExtension(
  LegacyExtension: ComponentType<{}>,
  overrides?: {
    name?: string;
    filter?: string | EntityPredicate | ((entity: Entity) => boolean);
    type?: EntityCardType;
  },
): ExtensionDefinition;

// @alpha (undocumented)
export function convertLegacyEntityContentExtension(
  LegacyExtension: ComponentType<{}>,
  overrides?: {
    name?: string;
    filter?: string | EntityPredicate | ((entity: Entity) => boolean);
    path?: string;
    title?: string;
    defaultPath?: [Error: `Use the 'path' override instead`];
    defaultTitle?: [Error: `Use the 'title' override instead`];
  },
): ExtensionDefinition;

// @alpha
export const defaultEntityContentGroups: {
  overview: string;
  documentation: string;
  development: string;
  deployment: string;
  operation: string;
  observability: string;
};

// @alpha
export const EntityCardBlueprint: ExtensionBlueprint<{
  kind: 'entity-card';
  params: {
    loader: () => Promise<JSX.Element>;
    filter?: string | EntityPredicate | ((entity: Entity) => boolean);
    type?: EntityCardType;
  };
  output:
    | ExtensionDataRef<JSX_2.Element, 'core.reactElement', {}>
    | ExtensionDataRef<
        (entity: Entity) => boolean,
        'catalog.entity-filter-function',
        {
          optional: true;
        }
      >
    | ExtensionDataRef<
        string,
        'catalog.entity-filter-expression',
        {
          optional: true;
        }
      >
    | ExtensionDataRef<
        EntityCardType,
        'catalog.entity-card-type',
        {
          optional: true;
        }
      >;
  inputs: {};
  config: {
    filter: EntityPredicate | undefined;
    type: 'content' | 'info' | undefined;
  };
  configInput: {
    filter?: EntityPredicate | undefined;
    type?: 'content' | 'info' | undefined;
  };
  dataRefs: {
    filterFunction: ConfigurableExtensionDataRef<
      (entity: Entity) => boolean,
      'catalog.entity-filter-function',
      {}
    >;
    filterExpression: ConfigurableExtensionDataRef<
      string,
      'catalog.entity-filter-expression',
      {}
    >;
    type: ConfigurableExtensionDataRef<
      EntityCardType,
      'catalog.entity-card-type',
      {}
    >;
  };
}>;

// @alpha (undocumented)
export type EntityCardType = 'info' | 'content';

// @alpha
export const EntityContentBlueprint: ExtensionBlueprint<{
  kind: 'entity-content';
  params: {
    defaultPath?: [Error: `Use the 'path' param instead`];
    path: string;
    defaultTitle?: [Error: `Use the 'title' param instead`];
    title: string;
    defaultGroup?: [Error: `Use the 'group' param instead`];
    group?: keyof typeof defaultEntityContentGroups | (string & {});
    loader: () => Promise<JSX.Element>;
    routeRef?: RouteRef;
    filter?: string | EntityPredicate | ((entity: Entity) => boolean);
  };
  output:
    | ExtensionDataRef<string, 'core.routing.path', {}>
    | ExtensionDataRef<JSX_2.Element, 'core.reactElement', {}>
    | ExtensionDataRef<
        RouteRef<AnyRouteRefParams>,
        'core.routing.ref',
        {
          optional: true;
        }
      >
    | ExtensionDataRef<
        (entity: Entity) => boolean,
        'catalog.entity-filter-function',
        {
          optional: true;
        }
      >
    | ExtensionDataRef<
        string,
        'catalog.entity-filter-expression',
        {
          optional: true;
        }
      >
    | ExtensionDataRef<string, 'catalog.entity-content-title', {}>
    | ExtensionDataRef<
        string,
        'catalog.entity-content-group',
        {
          optional: true;
        }
      >;
  inputs: {};
  config: {
    path: string | undefined;
    title: string | undefined;
    filter: EntityPredicate | undefined;
    group: string | false | undefined;
  };
  configInput: {
    filter?: EntityPredicate | undefined;
    title?: string | undefined;
    path?: string | undefined;
    group?: string | false | undefined;
  };
  dataRefs: {
    title: ConfigurableExtensionDataRef<
      string,
      'catalog.entity-content-title',
      {}
    >;
    filterFunction: ConfigurableExtensionDataRef<
      (entity: Entity) => boolean,
      'catalog.entity-filter-function',
      {}
    >;
    filterExpression: ConfigurableExtensionDataRef<
      string,
      'catalog.entity-filter-expression',
      {}
    >;
    group: ConfigurableExtensionDataRef<
      string,
      'catalog.entity-content-group',
      {}
    >;
  };
}>;

// @alpha (undocumented)
export const EntityContentLayoutBlueprint: ExtensionBlueprint<{
  kind: 'entity-content-layout';
  params: {
    filter?: string | EntityPredicate | ((entity: Entity) => boolean);
    loader: () => Promise<(props: EntityContentLayoutProps) => JSX_2.Element>;
  };
  output:
    | ExtensionDataRef<
        (entity: Entity) => boolean,
        'catalog.entity-filter-function',
        {
          optional: true;
        }
      >
    | ExtensionDataRef<
        string,
        'catalog.entity-filter-expression',
        {
          optional: true;
        }
      >
    | ExtensionDataRef<
        (props: EntityContentLayoutProps) => React.JSX.Element,
        'catalog.entity-content-layout.component',
        {}
      >;
  inputs: {};
  config: {
    type: string | undefined;
    filter: EntityPredicate | undefined;
  };
  configInput: {
    filter?: EntityPredicate | undefined;
    type?: string | undefined;
  };
  dataRefs: {
    filterFunction: ConfigurableExtensionDataRef<
      (entity: Entity) => boolean,
      'catalog.entity-filter-function',
      {}
    >;
    filterExpression: ConfigurableExtensionDataRef<
      string,
      'catalog.entity-filter-expression',
      {}
    >;
    component: ConfigurableExtensionDataRef<
      (props: EntityContentLayoutProps) => React.JSX.Element,
      'catalog.entity-content-layout.component',
      {}
    >;
  };
}>;

// @alpha (undocumented)
export interface EntityContentLayoutProps {
  // (undocumented)
  cards: Array<{
    type?: EntityCardType;
    element: JSX_2.Element;
  }>;
}

// @alpha (undocumented)
export const EntityContextMenuItemBlueprint: ExtensionBlueprint<{
  kind: 'entity-context-menu-item';
  params: EntityContextMenuItemParams;
  output:
    | ExtensionDataRef<JSX_2.Element, 'core.reactElement', {}>
    | ExtensionDataRef<
        (entity: Entity) => boolean,
        'catalog.entity-filter-function',
        {
          optional: true;
        }
      >;
  inputs: {};
  config: {
    filter: EntityPredicate | undefined;
  };
  configInput: {
    filter?: EntityPredicate | undefined;
  };
  dataRefs: {
    filterFunction: ConfigurableExtensionDataRef<
      (entity: Entity) => boolean,
      'catalog.entity-filter-function',
      {}
    >;
  };
}>;

// @alpha (undocumented)
export type EntityContextMenuItemParams = {
  useProps: UseProps;
  icon: JSX_2.Element;
  filter?: EntityPredicate | ((entity: Entity) => boolean);
};

// @alpha (undocumented)
export const EntityHeaderBlueprint: ExtensionBlueprint<{
  kind: 'entity-header';
  params: {
    loader: () => Promise<JSX.Element>;
    filter?: EntityPredicate | ((entity: Entity) => boolean);
  };
  output:
    | ExtensionDataRef<
        (entity: Entity) => boolean,
        'catalog.entity-filter-function',
        {
          optional: true;
        }
      >
    | ExtensionDataRef<
        string,
        'catalog.entity-filter-expression',
        {
          optional: true;
        }
      >
    | ExtensionDataRef<
        JSX_2.Element,
        'core.reactElement',
        {
          optional: true;
        }
      >;
  inputs: {};
  config: {
    filter: EntityPredicate | undefined;
  };
  configInput: {
    filter?: EntityPredicate | undefined;
  };
  dataRefs: {
    filterFunction: ConfigurableExtensionDataRef<
      (entity: Entity) => boolean,
      'catalog.entity-filter-function',
      {}
    >;
    element: ConfigurableExtensionDataRef<
      JSX_2.Element,
      'core.reactElement',
      {}
    >;
  };
}>;

// @alpha (undocumented)
export const EntityIconLinkBlueprint: ExtensionBlueprint<{
  kind: 'entity-icon-link';
  params: {
    useProps: () => Omit<IconLinkVerticalProps, 'color'>;
    filter?: EntityPredicate | ((entity: Entity) => boolean);
  };
  output:
    | ExtensionDataRef<
        (entity: Entity) => boolean,
        'catalog.entity-filter-function',
        {
          optional: true;
        }
      >
    | ExtensionDataRef<
        string,
        'catalog.entity-filter-expression',
        {
          optional: true;
        }
      >
    | ExtensionDataRef<
        () => IconLinkVerticalProps,
        'entity-icon-link-props',
        {}
      >;
  inputs: {};
  config: {
    label: string | undefined;
    title: string | undefined;
    filter: EntityPredicate | undefined;
  };
  configInput: {
    filter?: EntityPredicate | undefined;
    label?: string | undefined;
    title?: string | undefined;
  };
  dataRefs: {
    useProps: ConfigurableExtensionDataRef<
      () => IconLinkVerticalProps,
      'entity-icon-link-props',
      {}
    >;
    filterFunction: ConfigurableExtensionDataRef<
      (entity: Entity) => boolean,
      'catalog.entity-filter-function',
      {}
    >;
    filterExpression: ConfigurableExtensionDataRef<
      string,
      'catalog.entity-filter-expression',
      {}
    >;
  };
}>;

// @alpha (undocumented)
export type EntityPredicate =
  | EntityPredicateExpression
  | EntityPredicatePrimitive
  | {
      $all: EntityPredicate[];
    }
  | {
      $any: EntityPredicate[];
    }
  | {
      $not: EntityPredicate;
    };

// @alpha (undocumented)
export type EntityPredicateExpression = {
  [KPath in string]: EntityPredicateValue;
} & {
  [KPath in `$${string}`]: never;
};

// @alpha (undocumented)
export type EntityPredicatePrimitive = string | number | boolean;

// @alpha
export function entityPredicateToFilterFunction<T extends JsonValue>(
  entityPredicate: EntityPredicate,
): (value: T) => boolean;

// @alpha (undocumented)
export type EntityPredicateValue =
  | EntityPredicatePrimitive
  | {
      $exists: boolean;
    }
  | {
      $in: EntityPredicatePrimitive[];
    }
  | {
      $contains: EntityPredicate;
    };

// @alpha (undocumented)
export const EntityTableColumnTitle: ({
  translationKey,
}: EntityTableColumnTitleProps) =>
  | 'Title'
  | 'System'
  | 'Domain'
  | 'Lifecycle'
  | 'Namespace'
  | 'Owner'
  | 'Tags'
  | 'Type'
  | 'Name'
  | 'Description'
  | 'Targets'
  | 'Label';

// @alpha (undocumented)
export type EntityTableColumnTitleProps = {
  translationKey:
    | 'name'
    | 'system'
    | 'owner'
    | 'type'
    | 'lifecycle'
    | 'namespace'
    | 'description'
    | 'tags'
    | 'targets'
    | 'title'
    | 'label'
    | 'domain';
};

// @alpha
export function isOwnerOf(owner: Entity, entity: Entity): boolean;

// @alpha
export function useEntityPermission(
  permission: ResourcePermission<'catalog-entity'>,
): {
  loading: boolean;
  allowed: boolean;
  error?: Error;
};

// @alpha (undocumented)
export type UseProps = () =>
  | {
      title: ReactNode;
      href: string;
      disabled?: boolean;
    }
  | {
      title: ReactNode;
      onClick: () => void | Promise<void>;
      disabled?: boolean;
    };

// (No @packageDocumentation comment for this package)
```
