/*
 * Copyright 2024 The Backstage Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { CacheService } from '@backstage/backend-plugin-api';
import { Config } from '@backstage/config';
import {
  AuthenticationError,
  ForwardedError,
  ResponseError,
} from '@backstage/errors';
import express from 'express';
import { createRemoteJWKSet, jwtVerify } from 'jose';
import fetch, { Headers } from 'node-fetch';
import {
  CACHE_PREFIX,
  CF_JWT_HEADER,
  COOKIE_AUTH_NAME,
  CloudflareAccessClaims,
  CloudflareAccessIdentityProfile,
  CloudflareAccessResult,
  ServiceToken,
} from './types';

export class AuthHelper {
  static fromConfig(
    config: Config,
    options?: { cache?: CacheService },
  ): AuthHelper {
    const teamName = config.getString('teamName');
    const jwtHeaderName =
      config.getOptionalString('jwtHeaderName') ?? CF_JWT_HEADER;
    const authorizationCookieName =
      config.getOptionalString('authorizationCookieName') ?? COOKIE_AUTH_NAME;
    const serviceTokens = (
      config.getOptionalConfigArray('serviceTokens') ?? []
    )?.map(cfg => {
      return {
        token: cfg.getString('token'),
        subject: cfg.getString('subject'),
      } as ServiceToken;
    });

    const keySet = createRemoteJWKSet(
      new URL(`https://${teamName}.cloudflareaccess.com/cdn-cgi/access/certs`),
    );

    return new AuthHelper(
      teamName,
      serviceTokens,
      jwtHeaderName,
      authorizationCookieName,
      keySet,
      options?.cache,
    );
  }

  private constructor(
    private readonly teamName: string,
    private readonly serviceTokens: ServiceToken[],
    private readonly jwtHeaderName: string,
    private readonly authorizationCookieName: string,
    private readonly keySet: ReturnType<typeof createRemoteJWKSet>,
    private readonly cache?: CacheService,
  ) {}

  async authenticate(req: express.Request): Promise<CloudflareAccessResult> {
    // JWTs generated by Access are available in a request header as
    // Cf-Access-Jwt-Assertion and as cookies as CF_Authorization.
    let jwt = req.header(this.jwtHeaderName);
    if (!jwt) {
      jwt = req.cookies[this.authorizationCookieName];
    }
    if (!jwt) {
      // Only throw if both are not provided by Cloudflare Access since either
      // can be used.
      throw new AuthenticationError(
        `Missing ${this.jwtHeaderName} and 
          ${this.authorizationCookieName} from Cloudflare Access`,
      );
    }

    // Cloudflare signs the JWT using the RSA Signature with SHA-256 (RS256).
    // RS256 follows an asymmetric algorithm; a private key signs the JWTs and
    // a separate public key verifies the signature.
    const verifyResult = await jwtVerify(jwt, this.keySet, {
      issuer: `https://${this.teamName}.cloudflareaccess.com`,
    });

    const isServiceToken = !verifyResult.payload.sub;

    const subject = isServiceToken
      ? (verifyResult.payload.common_name as string)
      : verifyResult.payload.sub;
    if (!subject) {
      throw new AuthenticationError(
        `Missing both sub and common_name from Cloudflare Access JWT`,
      );
    }

    const serviceToken = this.serviceTokens.find(st => st.token === subject);
    if (isServiceToken && !serviceToken) {
      throw new AuthenticationError(
        `${subject} is not a permitted Service Token.`,
      );
    }

    const cacheKey = `${CACHE_PREFIX}/${subject}`;
    const cfAccessResultStr = await this.cache?.get(cacheKey);
    if (typeof cfAccessResultStr === 'string') {
      const result = JSON.parse(cfAccessResultStr) as CloudflareAccessResult;
      return {
        ...result,
        token: jwt,
      };
    }
    const claims = verifyResult.payload as CloudflareAccessClaims;

    // Builds a passport profile from JWT claims first
    try {
      let cfIdentity: CloudflareAccessIdentityProfile;
      if (serviceToken) {
        cfIdentity = {
          id: subject,
          name: 'Bot',
          email: serviceToken.subject,
          groups: [],
        };
      } else {
        // If we successfully fetch the get-identity endpoint,
        // We supplement the passport profile with richer user identity
        // information here.
        cfIdentity = await this.getIdentityProfile(jwt);
      }
      // Stores a stringified JSON object in cfaccess provider cache only when
      // we complete all steps
      const cfAccessResult = {
        claims,
        cfIdentity,
        expiresInSeconds: claims.exp - claims.iat,
      };
      this.cache?.set(cacheKey, JSON.stringify(cfAccessResult));
      return {
        ...cfAccessResult,
        token: jwt,
      };
    } catch (err) {
      throw new ForwardedError(
        'Failed to populate access identity information',
        err,
      );
    }
  }

  private async getIdentityProfile(
    jwt: string,
  ): Promise<CloudflareAccessIdentityProfile> {
    const headers = new Headers();
    // set both headers just the way inbound responses are set
    headers.set(this.jwtHeaderName, jwt);
    headers.set('cookie', `${this.authorizationCookieName}=${jwt}`);
    try {
      const res = await fetch(
        `https://${this.teamName}.cloudflareaccess.com/cdn-cgi/access/get-identity`,
        { headers },
      );
      if (!res.ok) {
        throw await ResponseError.fromResponse(res);
      }
      const cfIdentity = await res.json();
      return cfIdentity as unknown as CloudflareAccessIdentityProfile;
    } catch (err) {
      throw new ForwardedError('getIdentityProfile failed', err);
    }
  }
}
