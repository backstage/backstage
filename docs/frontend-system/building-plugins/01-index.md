---
id: index
title: Building Frontend Plugins
sidebar_label: Overview
# prettier-ignore
description: Building frontend plugins using the new frontend system
---

> NOTE: The new frontend system is in alpha and only a few number of plugins have been migrated. The new frontend
> plugins are not backwards compatible with the old `createApp()`. As a result you will need to migrate your entire
> application to the new frontend system in order to use any of the new plugin functionality. This includes
> migrating your usage of `createApp()` to the new package `@backstage/frontend-defaults` which is still incomplete.
>
> Also note that even though the old `createPlugin()` is marked as deprecated, you cannot use the new `createFrontendPlugin()`
> unless you have migrated your entire application to the new frontend system.

This section covers how to build frontend [plugins](../architecture/15-plugins.md). Plugins are one type of frontend _features_.
Features, which include plugins and modules, are stitched together to build up a Backstage frontend [app](../architecture/10-app.md).

Every plugin can incorporate one or more extensions. Extensions in the new frontend system are often generated from an
`ExtensionBlueprint`. Extension Blueprints are opinionated factories for building extensions (e.g. `ApiBlueprint` is
an `ExtensionBlueprint`).

Putting it all together, a plugin in the new frontend system will:

- Export a single `FrontendPlugin` object
- Export one or more `ExtensionDefinition` objects, usually generated by an `ExtensionBlueprint`

Your Backstage frontend app will import the plugin's package, and the new (optional) experimental feature discovery
(see below) will automatically register your new `FrontendPlugin` with the Backstage app. Then you can import and use
the various extensions your plugin provides throughout your Backstage app.

## Create a Plugin Package

This guide assumes that you already have a Backstage project set up. Even if you only want to develop a single plugin for publishing,
we still recommend that you do so in a standard Backstage monorepo project, as you often end up needing multiple packages. For instructions
on how to set up a new project, see our [getting started](../../getting-started/index.md#prerequisites) documentation.

To create a frontend plugin, run `yarn new`, select `plugin`, and fill out the rest of the prompts. See `Plugin Naming` below for
examples of plugin ids.

Example:

```sh
$ yarn new

? What do you want to create?
  web-library - A new web-library package, exporting shared functionality for frontend plugins
  backend-module - A new backend module that extends an existing backend plugin with additional features
  backend-plugin - A new backend plugin
‚ùØ plugin - A new frontend plugin
  node-library - A new node-library package, exporting shared functionality for backend plugins and modules
  plugin-common - A new isomorphic common plugin package
  plugin-node - A new Node.js library plugin package
```

Congrats! This will create your new package at `plugins/<pluginId>`.

:::info
Important! The created frontend plugin will be templated for use with the legacy frontend system. You will need to replace the
existing plugin wiring code by migrating it to the new frontend system.
:::

## Plugin Naming

A frontend plugin ID is expected to be a lowercase dash-separated string. The plugin instance variable should be the camel case
version of the plugin ID ending in `Plugin`.

- Example plugin ID: `my-new-feature`
- Example plugin code name: `myNewFeaturePlugin`

For more details on naming patterns within the frontend system, please see [naming patterns](../architecture/50-naming-patterns.md).

## Create a Plugin Instance

To instantiate and then export your plugin from your package, call `createFrontendPlugin({ ... })`. Import this function
from `@backstage/frontend-plugin-api`. This package is where you will find the common APIs for building plugins.

Create Plugin Example:

```tsx title="src/plugin.ts"
import { createFrontendPlugin } from '@backstage/frontend-plugin-api';

export const myExamplePlugin = createFrontendPlugin({
  id: 'my-example-plugin',
  extensions: [
    /** associate extensions with the plugin here **/
  ],
});
```

Make sure that this Plugin object is exported from your package:

```tsx title="src/index.ts"
export { myExamplePlugin as default } from './plugin';
```

Additionally, if you want your plugin to still support the old system, we recommend following the old plugin packaging
pattern and exporting the new plugin as follows:

```tsx title="src/alpha.ts"
export * from './index.ts';
```

And then:

```typescript jsx title="package.json"
  "exports": {
    ...
    "./alpha": "./src/alpha.ts"
    ...
  }
```

Note that we export the plugin as the default export of our package from `src/index.ts`. This is important using the new
feature discovery of the new frontend system. This default export is how users of our plugin are able to seamlessly install
the plugin package in a Backstage app without having to reference the plugin instance through code.

## Registering a Plugin with your Backstage App

The new frontend plugin system is designed to use the optional [feature discovery](../architecture/10-app/#feature-discovery) for registration. Please see the
documentation on Feature Discovery for more information and how to turn it on.

However, if you wish to manually register a plugin rather than using automated Feature Discovery, plugins are now designed
to be passed into the `features` field of the `createApp({...})` options.

Manual Plugin Registration:

```tsx title="in src/index.ts"
import { createApp } from '@backstage/frontend-defaults';
import myExamplePlugin from '@just-an-example/alpha';

// Create your app instance
const app = createApp({
  // Features such as plugins can be installed explicitly, but we will explore other options later on
  features: [myExamplePlugin],
});
```

This will register our new completely empty and useless plugin with Backstage. You will need to add features via extensions.

## Adding Plugin Features (via Extensions)

To add functionality to a plugin you need to add at least one [extension](../architecture/20-extensions.md). Let's continue by adding a
standalone page to our plugin, as well as a navigation item that allows users to navigate to the page.

Extensions can be created directly by following the `ExtensionDefinition` type or methods like `createComponentExtension()`,
but for most cases, it will be easier to use a predefined [extension blueprint](../architecture/23-extension-blueprints.md). Blueprints are provided either by
the core Backstage framework or by other plugins.

For our example we will use the framework `PageBlueprint` and `NavItemBlueprint`, both from `@backstage/frontend-plugin-api`. We will also need
to [create a route reference](../architecture/36-routes.md#creating-a-route-reference). A route reference enables us to dynamically create URL
endpoints that link to our page.

```tsx title="in src/routes.ts"
import { createRouteRef } from '@backstage/frontend-plugin-api';

// Typically all routes are defined in src/routes.ts, in order to avoid circular imports.

// This will be the route reference for our example page. If you want to link
// to the page from somewhere else, you can use this reference to generate the target path.
export const rootRouteRef = createRouteRef();
```

The route reference is a handle to a URL route that is used throughout a Backstage application to ensure that even if
the sub-url of a route changes, that every reference to that route will still work.

The example page is built by using a `PageBlueprint` provided by the Backstage framework:

```tsx title="in src/plugin.ts"
import {
  createFrontendPlugin,
  PageBlueprint,
  NavItemBlueprint,
} from '@backstage/frontend-plugin-api';
import { rootRouteRef } from './routes';

// Note that the extensions aren't exported, only the plugin itself is.
// You can export it locally for testing purposes, but don't export it from the plugin package.
const examplePage = PageBlueprint.make({
  params: {
    routeRef: rootRouteRef,

    // This is the default path of this page, but integrators are free to override it
    defaultPath: '/example',

    // Page extensions are always dynamically loaded using React.lazy().
    // All of the functionality of this page is implemented in the
    // ExamplePage component, which is a regular React component.
    // highlight-next-line
    loader: () =>
      import('./components/ExamplePage').then(m => <m.ExamplePage />),
  },
});

// This nav item is provided to the app.nav extension, and will by default be rendered as a sidebar item
const exampleNavItem = NavItemBlueprint.make({
  params: {
    routeRef: rootRouteRef,
    title: 'Example',
    icon: ExampleIcon, // Custom SvgIcon, or one from the Material UI icon library
  },
});

// The same plugin as above, now with the extensions added
export const examplePlugin = createFrontendPlugin({
  id: 'example',
  extensions: [examplePage, exampleNavItem],
  // We can also make routes available to other plugins.
  // highlight-start
  routes: {
    root: rootRouteRef,
  },
  // highlight-end
});
```

This is a very common type of plugin. It is a top-level feature that provides a single page and a routing endpoint for navigating to that page.
The implementation of the page component, in this case the highlighted `ExamplePage`, can contain whatever functionality we like.

We have also provided external access to our route reference by passing it to the plugin `routes` option. This makes it possible for app
integrators to bind an external link from a different plugin to our plugin page. You can read more about how this works in the
[External Route References](../architecture/36-routes.md#external-route-references) section.

## Utility APIs

Another type of extensions that is commonly used are [Utility APIs](../utility-apis/01-index.md). They can encapsulate shared pieces of functionality of your plugin, for example an API client for a backend service. You can optionally export your Utility API for other plugins to use, or allow integrators to replace the implementation of your Utility API with their own. For details on how to define and provide your own Utility API in your plugin, see the section on [creating Utility APIs](../utility-apis/02-creating.md).

What we'll show here is a complete example of a simple Utility API used only within the plugin itself:

```tsx title="src/api.ts - Defining an interface, API reference, and default implementation"
import { createApiRef } from '@backstage/frontend-plugin-api';

export interface ExampleApi {
  getExample(): { example: string };
}

export const exampleApiRef = createApiRef<ExampleApi>({
  id: 'plugin.example',
});

export class DefaultExampleApi implements ExampleApi {
  getExample(): { example: string } {
    return { example: 'Hello World!' };
  }
}
```

```tsx title="src/components/ExamplePage.tsx - Using the API in our page component"
import { useApi } from '@backstage/frontend-plugin-api';
import { exampleApiRef } from '../api';

export function ExamplePage() {
  // highlight-next-line
  const exampleApi = useApi(exampleApiRef);

  return (
    <div>
      <h1>Example Page</h1>
      <p>Example: {exampleApi.getExample().example}</p>
    </div>
  );
}
```

```tsx title="in src/plugin.ts - Registering a factory for our API"
import { createApiFactory, ApiBlueprint } from '@backstage/frontend-plugin-api';
import { exampleApiRef, DefaultExampleApi } from './api';

// highlight-add-start
const exampleApi = ApiBlueprint.make({
  name: 'example',
  params: {
    factory: createApiFactory({
      api: exampleApiRef,
      deps: {},
      factory: () => new DefaultExampleApi(),
    }),
  },
});
// highlight-add-end

/* Omitted definitions for examplePage, exampleNavItem, and rootRouteRef. */

export const examplePlugin = createFrontendPlugin({
  id: 'example',
  extensions: [
    // highlight-add-next-line
    exampleApi,
    examplePage,
    exampleNavItem,
  ],
  routes: {
    root: rootRouteRef,
  },
});
```

## Plugin specific extensions

There are many different plugins that you can extend with additional functionality through extensions. One such plugin is [the catalog plugin](../../features/software-catalog/), one of the core features of Backstage. It lets you catalog the software in your organization, where each item in the catalog has its own page that can be populated with tools and information relating to that catalog entity. In this example we will explore how our plugin can provide such a tool to display on an entity page.

```tsx title="in src/plugin.ts - An example entity content extension"
import { EntityContentBlueprint } from '@backstage/plugin-catalog-react/alpha';

// Entity content extensions are similar to page extensions in that they are rendered at a route,
// although they also have a title to support in-line navigation between the different content.
// Just like a page extension the content is lazy loaded, and you can also provide a
// route reference if you want to be able to generate a URL that links to the content.
const exampleEntityContent = EntityContentBlueprint.make({
  params: {
    defaultPath: 'example',
    defaultTitle: 'Example',
    loader: () =>
      import('./components/ExampleEntityContent').then(m => (
        <m.ExampleEntityContent />
      )),
  },
});

export const examplePlugin = createFrontendPlugin({
  id: 'example',
  extensions: [
    // highlight-add-next-line
    exampleEntityContent,
    exampleApi,
    examplePage,
    exampleNavItem,
  ],
  routes: {
    root: rootRouteRef,
  },
});
```

The `ExampleEntityContent` itself is again a regular React component where you can implement any functionality you want. To access the entity that the content is being rendered for, you can use the `useEntity` hook from `@backstage/plugin-catalog-react`. You can see a full list of APIs provided by the catalog React library in [the API reference](../../reference/plugin-catalog-react.md).

For a more complete list of the different kinds of extensions that you can create for your plugin, see the [extension blueprints](./03-common-extension-blueprints.md) section.
