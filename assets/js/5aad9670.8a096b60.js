/*! For license information please see 5aad9670.8a096b60.js.LICENSE.txt */
"use strict";(self.webpackChunkbackstage_microsite=self.webpackChunkbackstage_microsite||[]).push([[838674],{411072:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>s,default:()=>p,frontMatter:()=>a,metadata:()=>o,toc:()=>d});var i=t(474848),r=t(28453);const a={id:"extension-blueprints",title:"Frontend Extension Blueprints",sidebar_label:"Extensions Blueprints",description:"Frontend extensions"},s=void 0,o={id:"frontend-system/architecture/extension-blueprints",title:"Frontend Extension Blueprints",description:"Frontend extensions",source:"@site/../docs/frontend-system/architecture/23-extension-blueprints.md",sourceDirName:"frontend-system/architecture",slug:"/frontend-system/architecture/extension-blueprints",permalink:"/docs/next/frontend-system/architecture/extension-blueprints",draft:!1,unlisted:!1,editUrl:"https://github.com/backstage/backstage/edit/master/docs/frontend-system/architecture/23-extension-blueprints.md",tags:[],version:"current",sidebarPosition:23,frontMatter:{id:"extension-blueprints",title:"Frontend Extension Blueprints",sidebar_label:"Extensions Blueprints",description:"Frontend extensions"},sidebar:"docs",previous:{title:"Extensions",permalink:"/docs/next/frontend-system/architecture/extensions"},next:{title:"Extension Overrides",permalink:"/docs/next/frontend-system/architecture/extension-overrides"}},l={},d=[{value:"Creating an extension from a blueprint",id:"creating-an-extension-from-a-blueprint",level:2},{value:"Creating an extension from a blueprint with overrides",id:"creating-an-extension-from-a-blueprint-with-overrides",level:3},{value:"Creating an extension from a blueprint with advanced parameter types",id:"creating-an-extension-from-a-blueprint-with-advanced-parameter-types",level:3},{value:"Creating an extension blueprint",id:"creating-an-extension-blueprint",level:2},{value:"Creating an extension blueprint with advanced parameter types",id:"creating-an-extension-blueprint-with-advanced-parameter-types",level:3},{value:"Blueprint-specific extension data references",id:"blueprint-specific-extension-data-references",level:3},{value:"Extension Blueprints in libraries",id:"extension-blueprints-in-libraries",level:3}];function c(e){const n={a:"a",code:"code",h2:"h2",h3:"h3",p:"p",pre:"pre",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"createExtension"})," function and related APIs is considered a low-level building and fairly advanced building block, and is not typically what you would use when building plugins and features. Instead, the core APIs and plugins provide extension blueprints that makes it easier to create extensions for specific usages. These blueprints accept a number of parameters that is up to each blueprint to define, and then creates a new extension using the provided parameters. New blueprints are created using the ",(0,i.jsx)(n.code,{children:"createExtensionBlueprint"})," function, and are by convention exported with the symbol ",(0,i.jsx)(n.code,{children:"<Kind>Blueprint"}),". If you are curious about what blueprints are available from a plugin or package, look for ",(0,i.jsx)(n.code,{children:"*Blueprint"})," exports in the package's API, for plugins these are typically found in the ",(0,i.jsx)(n.code,{children:"*-react"})," package."]}),"\n",(0,i.jsx)(n.h2,{id:"creating-an-extension-from-a-blueprint",children:"Creating an extension from a blueprint"}),"\n",(0,i.jsxs)(n.p,{children:["Every extension blueprint provides a ",(0,i.jsx)(n.code,{children:"make"})," method that can be used to create new extensions. It is a simple way to create a new extension where the base blueprint provides all the necessary functionality. All you need to do is to provide the necessary blueprint parameters, but you also have the ability to provide additional options, for example a ",(0,i.jsx)(n.code,{children:"name"})," for the extension."]}),"\n",(0,i.jsxs)(n.p,{children:["The following is a simple example of how one might use the blueprint ",(0,i.jsx)(n.code,{children:"make"})," method to create a new extension:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-tsx",children:"const myPageExtension = PageBlueprint.make({\n  params: {\n    path: '/my-page',\n    loader: () => import('./components/MyPage').then(m => <m.MyPage />),\n  },\n});\n"})}),"\n",(0,i.jsxs)(n.p,{children:["The returned ",(0,i.jsx)(n.code,{children:"myPageExtension"})," is an extension which is ready to be used in a plugin. It is the same type of object as is returned by the lower level ",(0,i.jsx)(n.code,{children:"createExtension"})," function."]}),"\n",(0,i.jsx)(n.h3,{id:"creating-an-extension-from-a-blueprint-with-overrides",children:"Creating an extension from a blueprint with overrides"}),"\n",(0,i.jsxs)(n.p,{children:["Every extension blueprint also provides a ",(0,i.jsx)(n.code,{children:"makeWithOverrides"})," method. It is useful in cases where you want to provide additional integration points for an extension created with a blueprint. You might for example want to define additional inputs or configuration schema, or use the existing configuration to dynamically compute the parameters passed to the blueprint."]}),"\n",(0,i.jsxs)(n.p,{children:["The following is an example of how one might use the blueprint ",(0,i.jsx)(n.code,{children:"makeWithOverrides"})," method to create a new extension:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-tsx",children:"const myPageExtension = PageBlueprint.makeWithOverrides({\n  // This defines additional configuration options for the extension.\n  config: {\n    schema: {\n      layout: z => z.enum(['grid', 'rows']).default('grid'),\n    },\n  },\n  // This defines additional inputs for the extension.\n  inputs: {\n    content: createExtensionInput([coreExtensionData.reactElement], {\n      singleton: true,\n      optional: true,\n    }),\n  },\n  // The original blueprint factory is provided as the first argument.\n  // By convention the name is `originalFactory`, but you can also pick a different name.\n  factory(originalFactory, { config, inputs }) {\n    // Call and forward the result from the original factory, providing\n    // the blueprint parameters as the first argument.\n    return originalFactory({\n      path: '/my-page',\n      loader: () =>\n        import('./components/MyPage').then(m => (\n          // We can now access values from the factory context when providing\n          // the blueprint parameters, such as config values and inputs.\n          <m.MyPage\n            layout={config.layout}\n            content={inputs.content?.get(coreExtensionData.reactElement)}\n          />\n        )),\n    });\n  },\n});\n"})}),"\n",(0,i.jsxs)(n.p,{children:["When using ",(0,i.jsx)(n.code,{children:"makeWithOverrides"}),", we no longer pass the blueprint parameters directly. Instead, we provide a ",(0,i.jsx)(n.code,{children:"factory"})," function that receives the original blueprint factory as the first argument, and the extension factory context as the second. We can then call the original blueprint factory with the blueprint parameters and forward the result as the return value of out factory. Notice that when passing the blueprint parameters using this pattern we have access to a lot more information than when using the ",(0,i.jsx)(n.code,{children:"make"})," method, at the cost of being more complex."]}),"\n",(0,i.jsxs)(n.p,{children:["Apart from the addition of the blueprint parameters of the first argument to the original factory function, the ",(0,i.jsx)(n.code,{children:"makeWithOverrides"})," method works the same way as ",(0,i.jsx)(n.a,{href:"/docs/next/frontend-system/architecture/extension-overrides",children:"extension overrides"}),". All the same options and rules apply, including the ability to define additional inputs, override outputs, and so on. For more details and examples on how this works, please refer to the ",(0,i.jsx)(n.a,{href:"/docs/next/frontend-system/architecture/extension-overrides",children:"extension overrides"})," documentation. The patterns in that section also apply to the creation of extensions with the ",(0,i.jsx)(n.code,{children:"makeWithOverrides"})," method."]}),"\n",(0,i.jsx)(n.h3,{id:"creating-an-extension-from-a-blueprint-with-advanced-parameter-types",children:"Creating an extension from a blueprint with advanced parameter types"}),"\n",(0,i.jsxs)(n.p,{children:['Some blueprints may be defined with something known as "advanced parameter types". This is a feature that enables type inference and transform of the blueprint parameters, and the way that you pass the parameters look a little bit different. Rather than passing the parameters directly, they are instead passed as a callback function of the form ',(0,i.jsx)(n.code,{children:"defineParams => defineParams(<params>)"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["An example of a blueprint that uses advanced parameter types is the ",(0,i.jsx)(n.code,{children:"ApiBlueprint"})," blueprint. Using it to create a simple implementation for the ",(0,i.jsx)(n.code,{children:"AlertApi"})," might look like this:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"const alertApiBlueprint = ApiBlueprint.make({\n  params: defineParams =>\n    defineParams({\n      api: alertApiRef,\n      deps: {},\n      factory: () => new MyAlertApi(),\n    }),\n});\n"})}),"\n",(0,i.jsxs)(n.p,{children:["This also works with ",(0,i.jsx)(n.code,{children:"makeWithOverrides"}),", where the define callback is passed as the first argument to the original factory:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"const alertApiBlueprint = ApiBlueprint.makeWithOverrides({\n  factory(originalFactory, { config }) {\n    return originalFactory(defineParams =>\n      defineParams({\n        api: alertApiRef,\n        deps: {},\n        factory: () => new MyAlertApi(config),\n      }),\n    );\n  },\n});\n"})}),"\n",(0,i.jsx)(n.h2,{id:"creating-an-extension-blueprint",children:"Creating an extension blueprint"}),"\n",(0,i.jsxs)(n.p,{children:["To create a new extension blueprint, you use the ",(0,i.jsx)(n.code,{children:"createExtensionBlueprint"})," function. At the surface it is very similar to ",(0,i.jsx)(n.code,{children:"createExtension"}),", but with a few key differences. Firstly you must provide a ",(0,i.jsx)(n.code,{children:"kind"})," option, which will be the kind of all extensions created with the blueprint. See the ",(0,i.jsx)(n.a,{href:"/docs/next/frontend-system/architecture/naming-patterns",children:"naming patterns section"})," for more information about how to select a good extension kind. Secondly, the ",(0,i.jsx)(n.code,{children:"factory"})," function has a new signature where the first parameter is the blueprint parameters, and the second is the factory context. And finally, rather than returning an extension, ",(0,i.jsx)(n.code,{children:"createExtensionBlueprint"})," returns a blueprint object with the ",(0,i.jsx)(n.code,{children:"make"})," method and friends, which is used as is described above."]}),"\n",(0,i.jsx)(n.p,{children:"The following is an example of how one might create a new extension blueprint:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-tsx",children:"export interface MyWidgetBlueprintParams {\n  title: string;\n  element: JSX.Element;\n}\n\nexport const MyWidgetBlueprint = createExtensionBlueprint({\n  kind: 'my-widget',\n  attachTo: { id: 'page:my-plugin', input: 'widgets' },\n  config: {\n    schema: {\n      title: z.string().optional(),\n    },\n  },\n  output: [coreExtensionData.reactElement],\n  factory(params: MyWidgetBlueprintParams, { config }) {\n    return [\n      // Note that while this is a valid pattern, you might often want to\n      // return separate pieces of data instead, more on that below.\n      coreExtensionData.reactElement(\n        <MyWidgetContainer title={config.title ?? params.title}>\n          {params.element}\n        </MyWidgetContainer>,\n      ),\n    ];\n  },\n});\n"})}),"\n",(0,i.jsx)(n.p,{children:"This is of course a quite bare-bones example blueprint, but still a very real example. Blueprints can be very simple, there's already a lot of value in encapsulating the extension kind, attachment point, and output in a blueprint."}),"\n",(0,i.jsxs)(n.p,{children:["Most of the options provided to ",(0,i.jsx)(n.code,{children:"createExtensionBlueprint"})," can be overridden when using ",(0,i.jsx)(n.code,{children:"makeWithOverrides"})," to create an extension from the blueprint. These overrides work the same way as ",(0,i.jsx)(n.a,{href:"/docs/next/frontend-system/architecture/extension-overrides",children:"extension overrides"}),", and we defer to that documentation for more information on how overrides work."]}),"\n",(0,i.jsx)(n.h3,{id:"creating-an-extension-blueprint-with-advanced-parameter-types",children:"Creating an extension blueprint with advanced parameter types"}),"\n",(0,i.jsxs)(n.p,{children:['In some cases you may want to use inferred type parameters in the definition of the blueprint parameters. For this you need to use something known as "advanced parameter types". This is a feature that enables type inference and transform of the blueprint parameters, and the way you define the parameter type is a bit different. Rather than defining the type of the parameters as part of the factory function, you instead provide a separate ',(0,i.jsx)(n.code,{children:"defineParams"})," options. This is a function that takes the parameters as a single argument, and must then return the parameters wrapped with the ",(0,i.jsx)(n.code,{children:"createExtensionBlueprintParams"})," function."]}),"\n",(0,i.jsx)(n.p,{children:"The following is an example of how one might define a blueprint where the parameters make use of inferred types:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"export interface MyWidgetBlueprintParams<T> {\n  defaultOptions: T;\n  elementFactory(options: T): JSX.Element;\n}\n\nexport const MyWidgetBlueprint = createExtensionBlueprint({\n  kind: 'my-widget',\n  attachTo: { id: 'page:my-plugin', input: 'widgets' },\n  output: [coreExtensionData.reactElement],\n  defineParams<T>(params: MyWidgetBlueprintParams<T>) {\n    return createExtensionBlueprintParams(params);\n  },\n  // Note that we no longer define the parameters type here, they are inferred from the defineParams function\n  factory(params) {\n    return [\n      coreExtensionData.reactElement(\n        <MyWidgetRenderer\n          defaultOptions={params.defaultOptions}\n          elementFactory={params.elementFactory}\n        />,\n      ),\n    ];\n  },\n});\n"})}),"\n",(0,i.jsxs)(n.p,{children:['If you happen to ask yourself, "why can\'t I just define type parameters on the factory function instead?", this is a limitation in the TypeScript type system. We could technically support that in the blueprint definition, but there would be no way for that logic to be carried forward to the blueprint ',(0,i.jsx)(n.code,{children:".make"})," and ",(0,i.jsx)(n.code,{children:".makeWithOverrides"})," methods."]}),"\n",(0,i.jsx)(n.h3,{id:"blueprint-specific-extension-data-references",children:"Blueprint-specific extension data references"}),"\n",(0,i.jsxs)(n.p,{children:["In some cases you may want to define and provide ",(0,i.jsx)(n.a,{href:"/docs/next/frontend-system/architecture/extensions#extension-data-references",children:"extension data reference"})," that are specific to your blueprint. In the above example we might want to forward the ",(0,i.jsx)(n.code,{children:"title"})," as data for example, rather than encapsulating it into the ",(0,i.jsx)(n.code,{children:"MyWidgetContainer"})," component. This gives the parent extension more flexibility in the rendering for our example widget extensions."]}),"\n",(0,i.jsxs)(n.p,{children:["To do that, we create a new extension data reference for our widget title. This reference is provided via the ",(0,i.jsx)(n.code,{children:"dataRefs"})," options when we create the blueprint, which makes it available for use via ",(0,i.jsx)(n.code,{children:"MyWidgetBlueprint.dataRefs.widgetTitle"}),"."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-tsx",children:"export interface MyWidgetBlueprintParams {\n  title: string;\n  element: JSX.Element;\n}\n\nconst widgetTitleRef = createExtensionDataRef<string>().with({\n  id: 'my-plugin.widget.title',\n});\n\nexport const MyWidgetBlueprint = createExtensionBlueprint({\n  kind: 'my-widget',\n  attachTo: { id: 'page:my-plugin', input: 'widgets' },\n  config: {\n    schema: {\n      title: z.string().optional(),\n    },\n  },\n  output: [widgetTitleRef, coreExtensionData.reactElement],\n  factory(params: MyWidgetBlueprintParams, { config }) {\n    return [\n      widgetTitleRef(config.title ?? params.title),\n      coreExtensionData.reactElement(params.element),\n    ];\n  },\n  dataRefs: {\n    widgetTitle: widgetTitleRef,\n  },\n});\n"})}),"\n",(0,i.jsx)(n.h3,{id:"extension-blueprints-in-libraries",children:"Extension Blueprints in libraries"}),"\n",(0,i.jsxs)(n.p,{children:["If you are publishing a plugin, the extension creators should always be exported from frontend library packages (e.g. ",(0,i.jsx)(n.code,{children:"*-react"}),") rather than plugin packages."]})]})}function p(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}},221020:(e,n,t)=>{var i=t(296540),r=Symbol.for("react.element"),a=Symbol.for("react.fragment"),s=Object.prototype.hasOwnProperty,o=i.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner,l={key:!0,ref:!0,__self:!0,__source:!0};function d(e,n,t){var i,a={},d=null,c=null;for(i in void 0!==t&&(d=""+t),void 0!==n.key&&(d=""+n.key),void 0!==n.ref&&(c=n.ref),n)s.call(n,i)&&!l.hasOwnProperty(i)&&(a[i]=n[i]);if(e&&e.defaultProps)for(i in n=e.defaultProps)void 0===a[i]&&(a[i]=n[i]);return{$$typeof:r,type:e,key:d,ref:c,props:a,_owner:o.current}}n.Fragment=a,n.jsx=d,n.jsxs=d},474848:(e,n,t)=>{e.exports=t(221020)},28453:(e,n,t)=>{t.d(n,{R:()=>s,x:()=>o});var i=t(296540);const r={},a=i.createContext(r);function s(e){const n=i.useContext(a);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:s(e.components),i.createElement(a.Provider,{value:n},e.children)}}}]);