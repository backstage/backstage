/*! For license information please see 1a6c6cbd.39669c5d.js.LICENSE.txt */
"use strict";(self.webpackChunkbackstage_microsite=self.webpackChunkbackstage_microsite||[]).push([[204815],{6835:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>p,frontMatter:()=>s,metadata:()=>r,toc:()=>d});var o=t(474848),i=t(28453);const s={id:"writing-custom-field-extensions",title:"Writing Custom Field Extensions",description:"How to write your own field extensions"},a=void 0,r={id:"features/software-templates/writing-custom-field-extensions",title:"Writing Custom Field Extensions",description:"How to write your own field extensions",source:"@site/../docs/features/software-templates/writing-custom-field-extensions.md",sourceDirName:"features/software-templates",slug:"/features/software-templates/writing-custom-field-extensions",permalink:"/docs/next/features/software-templates/writing-custom-field-extensions",draft:!1,unlisted:!1,editUrl:"https://github.com/backstage/backstage/edit/master/docs/features/software-templates/writing-custom-field-extensions.md",tags:[],version:"current",frontMatter:{id:"writing-custom-field-extensions",title:"Writing Custom Field Extensions",description:"How to write your own field extensions"},sidebar:"docs",previous:{title:"Writing Tests For Actions",permalink:"/docs/next/features/software-templates/writing-tests-for-actions"},next:{title:"Writing custom step layouts",permalink:"/docs/next/features/software-templates/writing-custom-step-layouts"}},l={},d=[{value:"Creating a Field Extension",id:"creating-a-field-extension",level:2},{value:"Async Validation Function",id:"async-validation-function",level:3},{value:"Using the Custom Field Extension",id:"using-the-custom-field-extension",level:2},{value:"Access Data from other Fields",id:"access-data-from-other-fields",level:2},{value:"Previewing Custom Field Extensions",id:"previewing-custom-field-extensions",level:2}];function c(e){const n={a:"a",code:"code",h2:"h2",h3:"h3",img:"img",p:"p",pre:"pre",...(0,i.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.p,{children:"Collecting input from the user is a very large part of the scaffolding process\nand Software Templates as a whole. Sometimes the built in components and fields\njust aren't good enough, and sometimes you want to enrich the form that the\nusers sees with better inputs that fit better."}),"\n",(0,o.jsxs)(n.p,{children:["This is where ",(0,o.jsx)(n.code,{children:"Custom Field Extensions"})," come in."]}),"\n",(0,o.jsxs)(n.p,{children:["With them you can show your own ",(0,o.jsx)(n.code,{children:"React"})," Components and use them to control the\nstate of the JSON schema, as well as provide your own validation functions to\nvalidate the data too."]}),"\n",(0,o.jsx)(n.h2,{id:"creating-a-field-extension",children:"Creating a Field Extension"}),"\n",(0,o.jsxs)(n.p,{children:["Field extensions are a way to combine an ID, a ",(0,o.jsx)(n.code,{children:"React"})," Component and a\n",(0,o.jsx)(n.code,{children:"validation"})," function together in a modular way that you can then use to pass to\nthe ",(0,o.jsx)(n.code,{children:"Scaffolder"})," frontend plugin in your own ",(0,o.jsx)(n.code,{children:"App.tsx"}),"."]}),"\n",(0,o.jsxs)(n.p,{children:["You can create your own Field Extension by using the\n",(0,o.jsx)(n.a,{href:"https://backstage.io/docs/reference/plugin-scaffolder.createscaffolderfieldextension",children:(0,o.jsx)(n.code,{children:"createScaffolderFieldExtension"})}),"\n",(0,o.jsx)(n.code,{children:"API"})," like below."]}),"\n",(0,o.jsxs)(n.p,{children:["As an example, we will create a component that validates whether a string is in the ",(0,o.jsx)(n.code,{children:"Kebab-case"})," pattern:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-tsx",children:'//packages/app/src/scaffolder/ValidateKebabCase/ValidateKebabCaseExtension.tsx\nimport { FieldExtensionComponentProps } from \'@backstage/plugin-scaffolder-react\';\nimport type { FieldValidation } from \'@rjsf/utils\';\nimport FormControl from \'@material-ui/core/FormControl\';\nimport FormHelperText from \'@material-ui/core/FormHelperText\';\nimport Input from \'@material-ui/core/Input\';\nimport InputLabel from \'@material-ui/core/InputLabel\';\n/*\n This is the actual component that will get rendered in the form\n*/\nexport const ValidateKebabCase = ({\n  onChange,\n  rawErrors,\n  required,\n  formData,\n}: FieldExtensionComponentProps<string>) => {\n  return (\n    <FormControl\n      margin="normal"\n      required={required}\n      error={rawErrors?.length > 0 && !formData}\n    >\n      <InputLabel htmlFor="validateName">Name</InputLabel>\n      <Input\n        id="validateName"\n        aria-describedby="entityName"\n        onChange={e => onChange(e.target?.value)}\n      />\n      <FormHelperText id="entityName">\n        Use only letters, numbers, hyphens and underscores\n      </FormHelperText>\n    </FormControl>\n  );\n};\n\n/*\n This is a validation function that will run when the form is submitted.\n  You will get the value from the `onChange` handler before as the value here to make sure that the types are aligned\\\n*/\n\nexport const validateKebabCaseValidation = (\n  value: string,\n  validation: FieldValidation,\n) => {\n  const kebabCase = /^[a-z0-9-_]+$/g.test(value);\n\n  if (kebabCase === false) {\n    validation.addError(\n      `Only use letters, numbers, hyphen ("-") and underscore ("_").`,\n    );\n  }\n};\n'})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-tsx",children:"// packages/app/src/scaffolder/ValidateKebabCase/extensions.ts\n\n/*\n  This is where the magic happens and creates the custom field extension.\n\n  Note that if you're writing extensions part of a separate plugin,\n  then please use `scaffolderPlugin.provide` from there instead and export it part of your `plugin.ts` rather than re-using the `scaffolder.plugin`.\n*/\n\nimport { scaffolderPlugin } from '@backstage/plugin-scaffolder';\nimport { createScaffolderFieldExtension } from '@backstage/plugin-scaffolder-react';\nimport {\n  ValidateKebabCase,\n  validateKebabCaseValidation,\n} from './ValidateKebabCaseExtension';\n\nexport const ValidateKebabCaseFieldExtension = scaffolderPlugin.provide(\n  createScaffolderFieldExtension({\n    name: 'ValidateKebabCase',\n    component: ValidateKebabCase,\n    validation: validateKebabCaseValidation,\n  }),\n);\n"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-tsx",children:"// packages/app/src/scaffolder/ValidateKebabCase/index.ts\n\nexport { ValidateKebabCaseFieldExtension } from './extensions';\n"})}),"\n",(0,o.jsxs)(n.p,{children:["Once all these files are in place, you then need to provide your custom\nextension to the ",(0,o.jsx)(n.code,{children:"scaffolder"})," plugin."]}),"\n",(0,o.jsxs)(n.p,{children:["You do this in ",(0,o.jsx)(n.code,{children:"packages/app/src/App.tsx"}),". You need to provide the\n",(0,o.jsx)(n.code,{children:"customFieldExtensions"})," as children to the ",(0,o.jsx)(n.code,{children:"ScaffolderPage"}),"."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-tsx",children:'const routes = (\n  <FlatRoutes>\n    ...\n    <Route path="/create" element={<ScaffolderPage />} />\n    ...\n  </FlatRoutes>\n);\n'})}),"\n",(0,o.jsx)(n.p,{children:"Should look something like this instead:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-tsx",children:"import { ValidateKebabCaseFieldExtension } from './scaffolder/ValidateKebabCase';\nimport { ScaffolderFieldExtensions } from '@backstage/plugin-scaffolder-react';\n\nconst routes = (\n  <FlatRoutes>\n    ...\n    <Route path=\"/create\" element={<ScaffolderPage />}>\n      <ScaffolderFieldExtensions>\n        <ValidateKebabCaseFieldExtension />\n      </ScaffolderFieldExtensions>\n    </Route>\n    ...\n  </FlatRoutes>\n);\n"})}),"\n",(0,o.jsx)(n.h3,{id:"async-validation-function",children:"Async Validation Function"}),"\n",(0,o.jsxs)(n.p,{children:["A validation function can be asynchronous and use ",(0,o.jsx)(n.a,{href:"https://backstage.io/docs/api/utility-apis/",children:"Utility APIs"})," via the ",(0,o.jsx)(n.code,{children:"ApiHolder"})," in the ",(0,o.jsx)(n.a,{href:"https://backstage.io/docs/reference/plugin-scaffolder-react.customfieldvalidator",children:"field validation context"}),". The example below uses the ",(0,o.jsx)(n.code,{children:"catalogApiRef"})," to check if the submitted value (in this scenario an entity ref) exists in the catalog."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-tsx",children:"import { FieldValidation } from '@rjsf/utils';\nimport { ApiHolder } from '@backstage/core-plugin-api';\nimport { catalogApiRef } from '@backstage/plugin-catalog-react';\n\n/*\n  This validation function checks if the submitted entity ref value is present in the catalog.\n*/\n\nexport const customFieldExtensionValidator = async (\n  value: string,\n  validation: FieldValidation,\n  context: { apiHolder: ApiHolder },\n) => {\n  const catalogApi = context.apiHolder.get(catalogApiRef);\n\n  if ((await catalogApi?.getEntityByRef(value)) === undefined) {\n    validation.addError('Entity not found');\n  }\n};\n"})}),"\n",(0,o.jsx)(n.h2,{id:"using-the-custom-field-extension",children:"Using the Custom Field Extension"}),"\n",(0,o.jsxs)(n.p,{children:["Once it's been passed to the ",(0,o.jsx)(n.code,{children:"ScaffolderPage"})," you should now be able to use the\n",(0,o.jsx)(n.code,{children:"ui:field"})," property in your templates to point it to the name of the\n",(0,o.jsx)(n.code,{children:"customFieldExtension"})," that you registered."]}),"\n",(0,o.jsx)(n.p,{children:"Something like this:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-yaml",children:"apiVersion: scaffolder.backstage.io/v1beta3\nkind: Template\nmetadata:\n  name: Test template\n  title: Test template with custom extension\n  description: Test template\nspec:\n  parameters:\n    - title: Fill in some steps\n      required:\n        - name\n      properties:\n        name:\n          title: Name\n          type: string\n          description: My custom name for the component\n          ui:field: ValidateKebabCase\n  steps:\n  [...]\n"})}),"\n",(0,o.jsx)(n.h2,{id:"access-data-from-other-fields",children:"Access Data from other Fields"}),"\n",(0,o.jsx)(n.p,{children:"Custom fields extensions can read data from other fields in the form via the form context. This\nis something that we discourage due to the coupling that it creates, but is sometimes still\nthe most sensible solution."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-tsx",children:"const CustomFieldExtensionComponent = (props: FieldExtensionComponentProps<string[]>) => {\n  const { formData } = props.formContext;\n  ...\n};\n\nconst CustomFieldExtension = scaffolderPlugin.provide(\n  createScaffolderFieldExtension({\n    name: ...,\n    component: CustomFieldExtensionComponent,\n    validation: ...\n  })\n);\n"})}),"\n",(0,o.jsx)(n.h2,{id:"previewing-custom-field-extensions",children:"Previewing Custom Field Extensions"}),"\n",(0,o.jsxs)(n.p,{children:["You can preview custom field extensions you write in the Backstage UI using the Custom Field Explorer\n(accessible via the ",(0,o.jsx)(n.code,{children:"/create/edit"})," route by default):"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.img,{alt:"Custom Field Explorer",src:t(856728).A+"",width:"1832",height:"781"})}),"\n",(0,o.jsx)(n.p,{children:"In order to make your new custom field extension available in the explorer you will have to define a\nJSON schema that describes the input/output types on your field like in the following example:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-tsx",children:"//packages/app/src/scaffolder/MyCustomExtensionWithOptions/MyCustomExtensionWithOptions.tsx\nexport const MyCustomExtensionWithOptionsSchema = {\n  uiOptions: {\n    type: 'object',\n    properties: {\n      focused: {\n        description: 'Whether to focus this field',\n        type: 'boolean',\n      },\n    },\n  },\n  returnValue: { type: 'string' },\n};\n\nexport const MyCustomExtensionWithOptions = ({\n  onChange,\n  rawErrors,\n  required,\n  formData,\n}: FieldExtensionComponentProps<string, { focused?: boolean }>) => {\n  return (\n    <FormControl\n      margin=\"normal\"\n      required={required}\n      error={rawErrors?.length > 0 && !formData}\n      onChange={onChange}\n      focused={focused}\n    />\n  );\n};\n"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-tsx",children:"// packages/app/src/scaffolder/MyCustomExtensionWithOptions/extensions.ts\n...\nimport { MyCustomExtensionWithOptions, MyCustomExtensionWithOptionsSchema } from './MyCustomExtensionWithOptions';\n\nexport const MyCustomFieldWithOptionsExtension = scaffolderPlugin.provide(\n  createScaffolderFieldExtension({\n    name: 'MyCustomExtensionWithOptions',\n    component: MyCustomExtensionWithOptions,\n    schema: MyCustomExtensionWithOptionsSchema,\n  }),\n);\n"})}),"\n",(0,o.jsxs)(n.p,{children:["We recommend using a library like ",(0,o.jsx)(n.a,{href:"https://github.com/colinhacks/zod",children:"zod"})," to define your schema\nand the provided ",(0,o.jsx)(n.code,{children:"makeFieldSchemaFromZod"})," helper utility function to generate both the JSON schema\nand type for your field props to preventing having to duplicate the definitions:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-tsx",children:"//packages/app/src/scaffolder/MyCustomExtensionWithOptions/MyCustomExtensionWithOptions.tsx\n...\nimport { z } from 'zod';\nimport { makeFieldSchemaFromZod } from '@backstage/plugin-scaffolder';\n\nconst MyCustomExtensionWithOptionsFieldSchema = makeFieldSchemaFromZod(\n  z.string(),\n  z.object({\n    focused: z\n      .boolean()\n      .optional()\n      .describe('Whether to focus this field'),\n  }),\n);\n\nexport const MyCustomExtensionWithOptionsSchema = MyCustomExtensionWithOptionsFieldSchema.schema;\n\ntype MyCustomExtensionWithOptionsProps = typeof MyCustomExtensionWithOptionsFieldSchema.type;\n\nexport const MyCustomExtensionWithOptions = ({\n  onChange,\n  rawErrors,\n  required,\n  formData,\n}: MyCustomExtensionWithOptionsProps) => {\n  return (\n    <FormControl\n      margin=\"normal\"\n      required={required}\n      error={rawErrors?.length > 0 && !formData}\n      onChange={onChange}\n      focused={focused}\n    />\n  );\n};\n"})})]})}function p(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(c,{...e})}):c(e)}},221020:(e,n,t)=>{var o=t(296540),i=Symbol.for("react.element"),s=Symbol.for("react.fragment"),a=Object.prototype.hasOwnProperty,r=o.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner,l={key:!0,ref:!0,__self:!0,__source:!0};function d(e,n,t){var o,s={},d=null,c=null;for(o in void 0!==t&&(d=""+t),void 0!==n.key&&(d=""+n.key),void 0!==n.ref&&(c=n.ref),n)a.call(n,o)&&!l.hasOwnProperty(o)&&(s[o]=n[o]);if(e&&e.defaultProps)for(o in n=e.defaultProps)void 0===s[o]&&(s[o]=n[o]);return{$$typeof:i,type:e,key:d,ref:c,props:s,_owner:r.current}}n.Fragment=s,n.jsx=d,n.jsxs=d},474848:(e,n,t)=>{e.exports=t(221020)},856728:(e,n,t)=>{t.d(n,{A:()=>o});const o=t.p+"assets/images/custom-field-explorer-a0f6f73e07cdd0e6821b6fc78b2ca827.png"},28453:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>r});var o=t(296540);const i={},s=o.createContext(i);function a(e){const n=o.useContext(s);return o.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),o.createElement(s.Provider,{value:n},e.children)}}}]);