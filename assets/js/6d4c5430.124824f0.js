/*! For license information please see 6d4c5430.124824f0.js.LICENSE.txt */
"use strict";(self.webpackChunkbackstage_microsite=self.webpackChunkbackstage_microsite||[]).push([[110068],{77759:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>c,contentTitle:()=>s,default:()=>g,frontMatter:()=>a,metadata:()=>r,toc:()=>l});var t=i(474848),o=i(28453);const a={id:"reading",title:"Reading Backstage Configuration",description:"Documentation on Reading Backstage Configuration"},s=void 0,r={id:"conf/reading",title:"Reading Backstage Configuration",description:"Documentation on Reading Backstage Configuration",source:"@site/../docs/conf/reading.md",sourceDirName:"conf",slug:"/conf/reading",permalink:"/docs/next/conf/reading",draft:!1,unlisted:!1,editUrl:"https://github.com/backstage/backstage/edit/master/docs/conf/reading.md",tags:[],version:"current",frontMatter:{id:"reading",title:"Reading Backstage Configuration",description:"Documentation on Reading Backstage Configuration"},sidebar:"docs",previous:{title:"Static Configuration in Backstage",permalink:"/docs/next/conf/"},next:{title:"Writing Backstage Configuration Files",permalink:"/docs/next/conf/writing"}},c={},l=[{value:"Config API",id:"config-api",level:2},{value:"Type Safety",id:"type-safety",level:3},{value:"Reading Nested Configuration",id:"reading-nested-configuration",level:3},{value:"Required vs Optional Configuration",id:"required-vs-optional-configuration",level:3},{value:"Accessing ConfigApi in Frontend Plugins",id:"accessing-configapi-in-frontend-plugins",level:2},{value:"Accessing ConfigApi in Backend Plugins",id:"accessing-configapi-in-backend-plugins",level:2},{value:"Old Backend System",id:"old-backend-system",level:3}];function d(e){const n={a:"a",code:"code",h2:"h2",h3:"h3",p:"p",pre:"pre",...(0,o.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.h2,{id:"config-api",children:"Config API"}),"\n",(0,t.jsxs)(n.p,{children:["There's a common configuration API for by both frontend and backend plugins. An\nAPI reference can be found ",(0,t.jsx)(n.a,{href:"/docs/next/reference/config.config",children:"here"}),"."]}),"\n",(0,t.jsx)(n.p,{children:"The configuration API is tailored towards failing fast in case of missing or bad\nconfig. That's because configuration errors can always be considered programming\nmistakes, and will fail deterministically."}),"\n",(0,t.jsx)(n.h3,{id:"type-safety",children:"Type Safety"}),"\n",(0,t.jsxs)(n.p,{children:["The methods for reading primitive values are typed, and validate that type at\nruntime. For example ",(0,t.jsx)(n.code,{children:"getNumber()"})," requires the underlying value to be a number,\nand there will be no attempt to coerce other types into the desired one. If\n",(0,t.jsx)(n.code,{children:"getNumber()"})," receives a string value, it will throw an error, explaining where\nthe bad config came from, and what the desired and actual types where."]}),"\n",(0,t.jsx)(n.h3,{id:"reading-nested-configuration",children:"Reading Nested Configuration"}),"\n",(0,t.jsx)(n.p,{children:"The backing configuration data is a nested JSON structure, meaning there will be\nobject, within objects, arrays within objects, and so on. There are a couple of\ndifferent ways to access nested values when reading configuration, but the\nprimary one is to use dot-separated paths."}),"\n",(0,t.jsx)(n.p,{children:"For example, given the following configuration:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",children:"app:\n  baseUrl: http://localhost:3000\n"})}),"\n",(0,t.jsxs)(n.p,{children:["We can access the ",(0,t.jsx)(n.code,{children:"baseUrl"})," using ",(0,t.jsx)(n.code,{children:"config.getString('app.baseUrl')"}),". Because of\nthis syntax, configuration keys are not allowed to contain dots. In fact,\nconfiguration keys are validated using the following regular expression:\n",(0,t.jsx)(n.code,{children:"/^[a-z][a-z0-9]*(?:[-_][a-z][a-z0-9]*)*$/i"}),". This basically means that keys\nmust only contain the letters ",(0,t.jsx)(n.code,{children:"a"})," through ",(0,t.jsx)(n.code,{children:"z"})," and digits, in groups separated by\ndashes or underscores. Additionally, the very first character of each such group\nmust be a letter, not a digit."]}),"\n",(0,t.jsxs)(n.p,{children:["Another option of accessing the ",(0,t.jsx)(n.code,{children:"baseUrl"})," value is to create a sub-view of the\nconfiguration, ",(0,t.jsx)(n.code,{children:"config.getConfig('app').getString('baseUrl')"}),". When reading out\nsingle values the dot-path pattern is preferred, but creating sub-views can be\nuseful for when you want to pass on parts of configuration to be read out by a\nseparate function. For example, given something like"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",children:"my-plugin:\n  items:\n    a:\n      title: Item A\n      path: /a\n    b:\n      title: Item B\n      path: /b\n"})}),"\n",(0,t.jsxs)(n.p,{children:["You can get the list of all items using the ",(0,t.jsx)(n.code,{children:".keys()"})," method, and then pass on\neach sub-view to be handled individually."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"for (const itemKey of config.keys('my-plugin.items')) {\n  const itemConfig = config.getConfig(`my-plugin.items`).getConfig(itemKey);\n  const title = itemConfig.getString('title');\n  // ...\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Another option for iterating through configuration keys is to call\n",(0,t.jsx)(n.code,{children:"config.get('my-plugin.items')"}),", which simply returns the JSON structure for\nthat position without any validation. This can be handy to use sometimes,\nespecially if you're passing on config to an external library. There's a clear\nbenefit to the sub-view approach though, which is that the user will receive\nmuch more detailed and relevant error messages. For example, if\n",(0,t.jsx)(n.code,{children:"itemConfig.getString('title')"})," fails in the above example because a boolean was\nsupplied, the user will receive an error message with the full path, e.g.\n",(0,t.jsx)(n.code,{children:"my-plugin.items.b.title"}),", as well as the name of the config file with the bad\nvalue. Conversely, if you try to access missing fields in raw JSON, you tend to\nend up with very technical and hard-to-understand type errors from javascript."]}),"\n",(0,t.jsx)(n.p,{children:"Note that no matter what method is used for reading out nested config, the same\nmerging rules apply. You will always get the same value for any way of accessing\nnested config:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"// Equivalent as long as a.b.c exists and is a string\nconfig.getString('a.b.c');\nconfig.getConfig('a.b').getString('c');\nconfig.get('a').b.c;\n"})}),"\n",(0,t.jsx)(n.h3,{id:"required-vs-optional-configuration",children:"Required vs Optional Configuration"}),"\n",(0,t.jsxs)(n.p,{children:["Reading configuration can be divided into two categories: required, and\noptional. When reading optional configuration you use the optional methods such\nas ",(0,t.jsx)(n.code,{children:"getOptionalString"}),". These methods will simply return ",(0,t.jsx)(n.code,{children:"undefined"})," if\nconfiguration values are missing, allowing the called to fall back to default\nvalues. The optional methods still validate types however, so receiving a string\nin a call to ",(0,t.jsx)(n.code,{children:"config.getOptionalNumber"})," will still throw an error."]}),"\n",(0,t.jsxs)(n.p,{children:["A good pattern for reading optional configuration values is to use the ",(0,t.jsx)(n.code,{children:"??"}),"\noperator. For example:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"const title = config.getOptionalString('my-plugin.title') ?? 'My Plugin';\n"})}),"\n",(0,t.jsxs)(n.p,{children:["To read required configuration, simply use the methods without ",(0,t.jsx)(n.code,{children:"Optional"}),", for\nexample ",(0,t.jsx)(n.code,{children:"getString"}),". These will throw an error if there is no value available."]}),"\n",(0,t.jsx)(n.h2,{id:"accessing-configapi-in-frontend-plugins",children:"Accessing ConfigApi in Frontend Plugins"}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.a,{href:"/docs/next/reference/frontend-plugin-api.configapi",children:"ConfigApi"})," in the frontend is a\n",(0,t.jsx)(n.a,{href:"/docs/next/api/utility-apis",children:"UtilityApi"}),". It's accessible as usual via the\n",(0,t.jsx)(n.code,{children:"configApiRef"})," exported from ",(0,t.jsx)(n.code,{children:"@backstage/core-plugin-api"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"import { useApi, configApiRef } from '@backstage/core-plugin-api';\n...\nconst MyReactComponent = (...) => {\n  const config = useApi(configApiRef);\n  ...\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Depending on the config api in another API is slightly different though, as the\n",(0,t.jsx)(n.code,{children:"ConfigApi"})," implementation is supplied via the App itself and not instantiated\nlike other APIs. See\n",(0,t.jsx)(n.a,{href:"https://github.com/backstage/backstage/blob/244eef851f5aa19f91c7c9b5c12d5df95cf482ca/packages/app/src/apis.ts#L66",children:"packages/app/src/apis.ts"}),"\nfor an example of how this wiring is done."]}),"\n",(0,t.jsxs)(n.p,{children:["For standalone plugin setups in ",(0,t.jsx)(n.code,{children:"dev/index.ts"}),", register a factory with a\nstatically mocked implementation of the config API. Use the ",(0,t.jsx)(n.code,{children:"ConfigReader"})," from\n",(0,t.jsx)(n.code,{children:"@backstage/config"})," to create an instance and register it for the ",(0,t.jsx)(n.code,{children:"configApiRef"}),"\nfrom ",(0,t.jsx)(n.code,{children:"@backstage/core-plugin-api"}),"."]}),"\n",(0,t.jsx)(n.h2,{id:"accessing-configapi-in-backend-plugins",children:"Accessing ConfigApi in Backend Plugins"}),"\n",(0,t.jsx)(n.p,{children:"In the backend system, plugins are able to directly access config through dependencies. You can access config like so,"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",metastring:'title="plugins/your-plugin-backend/src/plugin.ts"',children:"export const yourPlugin = createBackendPlugin({\n  pluginId: 'yourPlugin',\n  register(env) {\n    env.registerInit({\n      deps: {\n        httpRouter: coreServices.httpRouter,\n        logger: coreServices.logger,\n        // highlight-next-line\n        config: coreServices.rootConfig,\n      },\n      async init({\n        httpRouter,\n        logger,\n        // highlight-next-line\n        config,\n      }) {\n        // highlight-next-line\n        console.log(config.getOptionalString('backend.test.property'));\n      },\n    });\n  },\n});\n"})}),"\n",(0,t.jsx)(n.h3,{id:"old-backend-system",children:"Old Backend System"}),"\n",(0,t.jsx)(n.p,{children:"In the old backend system plugins, the configuration is passed in via options from the main backend package."})]})}function g(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},221020:(e,n,i)=>{var t=i(296540),o=Symbol.for("react.element"),a=Symbol.for("react.fragment"),s=Object.prototype.hasOwnProperty,r=t.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner,c={key:!0,ref:!0,__self:!0,__source:!0};function l(e,n,i){var t,a={},l=null,d=null;for(t in void 0!==i&&(l=""+i),void 0!==n.key&&(l=""+n.key),void 0!==n.ref&&(d=n.ref),n)s.call(n,t)&&!c.hasOwnProperty(t)&&(a[t]=n[t]);if(e&&e.defaultProps)for(t in n=e.defaultProps)void 0===a[t]&&(a[t]=n[t]);return{$$typeof:o,type:e,key:l,ref:d,props:a,_owner:r.current}}n.Fragment=a,n.jsx=l,n.jsxs=l},474848:(e,n,i)=>{e.exports=i(221020)},28453:(e,n,i)=>{i.d(n,{R:()=>s,x:()=>r});var t=i(296540);const o={},a=t.createContext(o);function s(e){const n=t.useContext(a);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:s(e.components),t.createElement(a.Provider,{value:n},e.children)}}}]);