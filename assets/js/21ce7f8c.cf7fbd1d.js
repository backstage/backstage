"use strict";(self.webpackChunkbackstage_microsite=self.webpackChunkbackstage_microsite||[]).push([["37153"],{258090(e,n,t){t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>r,default:()=>u,frontMatter:()=>a,metadata:()=>o,toc:()=>d});var o=t(835836),i=t(474848),s=t(28453);let a={id:"extension-points",title:"Backend Plugin Extension Points",sidebar_label:"Extension Points",description:"Extension points of backend plugins"},r,c={},d=[{value:"Defining an Extension Point",id:"defining-an-extension-point",level:2},{value:"Registering an Extension Point",id:"registering-an-extension-point",level:2},{value:"Factory-Based Extension Points",id:"factory-based-extension-points",level:2},{value:"Module Extension Points",id:"module-extension-points",level:2},{value:"Extension Point Design",id:"extension-point-design",level:2}];function l(e){let n={a:"a",code:"code",h2:"h2",p:"p",pre:"pre",...(0,s.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(n.p,{children:["While plugins are able to use static configuration for lightweight forms of customization, you can quickly hit a limit where you need something more powerful to allow users to extend your plugin. For this purpose, the backend system provides a mechanism for plugins to provide extension points, which can be used to expose deeper customizations for your plugin. Extension points are used by modules, which are installed in the backend adjacent to plugins. Modules are covered more in-depth in the ",(0,i.jsx)(n.a,{href:"/docs/backend-system/architecture/modules",children:"next section"}),"."]}),"\n",(0,i.jsx)(n.p,{children:"Extension points are quite similar to services, in that they both encapsulate an interface in a reference object. The key difference is that extension points are registered and provided by plugins themselves, and do not have any factory associated with them. Extension points for a given plugin are also only accessible to modules that extend that same plugin."}),"\n",(0,i.jsxs)(n.p,{children:["Plugin extension points should always be exported from a plugin node library package, for example ",(0,i.jsx)(n.code,{children:"@backstage/plugin-catalog-node"}),". This is to allow for modules to avoid a direct dependency on the plugin, and make it easier to evolve extension points over time. You can export as many different extension points as you want, just be mindful of the complexity of the API surface. It is however often better to export multiple extension points with few methods, rather than few extension points with many methods, as that tends to be easier to maintain."]}),"\n",(0,i.jsx)(n.h2,{id:"defining-an-extension-point",children:"Defining an Extension Point"}),"\n",(0,i.jsxs)(n.p,{children:["Extension points are created using the ",(0,i.jsx)(n.code,{children:"createExtensionPoint"})," method from ",(0,i.jsx)(n.code,{children:"@backstage/backend-plugin-api"}),". You need to provide the type, as well as an ID."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"import { createExtensionPoint } from '@backstage/backend-plugin-api';\n\nexport interface ScaffolderActionsExtensionPoint {\n  addAction(action: ScaffolderAction): void;\n}\n\nexport const scaffolderActionsExtensionPoint =\n  createExtensionPoint<ScaffolderActionsExtensionPoint>({\n    id: 'scaffolder.actions',\n  });\n"})}),"\n",(0,i.jsx)(n.h2,{id:"registering-an-extension-point",children:"Registering an Extension Point"}),"\n",(0,i.jsxs)(n.p,{children:["For modules to be able to use your extension point, an implementation of it must be registered by the plugin. This is done using the ",(0,i.jsx)(n.code,{children:"registerExtensionPoint"})," method in the ",(0,i.jsx)(n.code,{children:"register"})," callback of the plugin definition."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"export const scaffolderPlugin = createBackendPlugin(\n  {\n    pluginId: 'scaffolder',\n    register(env) {\n      const actions = new Map<string, TemplateAction<any>>();\n\n      env.registerExtensionPoint(\n        scaffolderActionsExtensionPoint,\n        {\n          addAction(action) {\n            if (actions.has(action.id)) {\n              throw new Error(`Scaffolder actions with ID '${action.id}' has already been installed`);\n            }\n            actions.set(action.id, action);\n          },\n        },\n      );\n\n      env.registerInit({\n        deps: { ... },\n        async init({ ... }) {\n          // Use the registered actions when setting up the scaffolder ...\n          const installedActions = Array.from(actions.values());\n        },\n      });\n    },\n  },\n);\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Note that we create a closure that adds to a shared ",(0,i.jsx)(n.code,{children:"actions"})," structure when ",(0,i.jsx)(n.code,{children:"addAction"})," is called by users of your extension point. It is safe for us to then access our ",(0,i.jsx)(n.code,{children:"actions"})," in the ",(0,i.jsx)(n.code,{children:"init"})," method of our plugin, since all modules that extend our plugin will be completely initialized before our plugin gets initialized. That means that at the point where our ",(0,i.jsx)(n.code,{children:"init"})," method is called, all actions have been added and can be accessed."]}),"\n",(0,i.jsx)(n.h2,{id:"factory-based-extension-points",children:"Factory-Based Extension Points"}),"\n",(0,i.jsxs)(n.p,{children:["In some cases, you may want to be able to attribute startup failures to modules that provided an extension, rather than failing the plugin startup entirely. To do this, you can use a variant of ",(0,i.jsx)(n.code,{children:"registerExtensionPoint"})," that instead of providing a direct implementation, registers a factory function that produces the implementation. This factory receives an ",(0,i.jsx)(n.code,{children:"ExtensionPointFactoryContext"})," with a ",(0,i.jsx)(n.code,{children:"reportModuleStartupFailure"})," method that lets you report startup failures and attribute them to the module."]}),"\n",(0,i.jsx)(n.p,{children:"Here's an example of registering an extension point using a factory:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"import {\n  createBackendPlugin,\n  ExtensionPointFactoryContext,\n} from '@backstage/backend-plugin-api';\nimport { assertError, ForwardedError } from '@backstage/errors';\nimport { createProviderConnection, Provider } from './internal';\n\ntype ProviderEntry = {\n  provider: Provider;\n  context: ExtensionPointFactoryContext;\n};\n\nexport const examplePlugin = createBackendPlugin({\n  pluginId: 'example',\n  register(env) {\n    const providers: ProviderEntry[] = [];\n\n    // Using the variant of registerExtensionPoint that takes an options object.\n    env.registerExtensionPoint({\n      extensionPoint: exampleProvidersExtensionPoint,\n      // The factory function produces a separate instance for each module.\n      factory: context => ({\n        addProvider(provider) {\n          // Store the context together with the provider so we can report failures later\n          providers.push({ provider, context });\n        },\n      }),\n    });\n\n    env.registerInit({\n      deps: { database: coreServices.database },\n      async init({ database }) {\n        for (const { provider, context } of providers) {\n          const connection = await createProviderConnection(provider, database);\n          try {\n            // This connects each provider that was installed by a module\n            await provider.connect(connection);\n          } catch (error: unknown) {\n            // If the connection fails, we can report this as a failure of the module rather than the plugin\n            assertError(error);\n            context.reportModuleStartupFailure({\n              error: new ForwardedError('Failed to connect provider', error),\n            });\n          }\n        }\n      },\n    });\n  },\n});\n"})}),"\n",(0,i.jsx)(n.h2,{id:"module-extension-points",children:"Module Extension Points"}),"\n",(0,i.jsx)(n.p,{children:"Just like plugins, modules can also provide their own extension points. The API for registering and using extension points is the same as for plugins. However, modules should typically only use extension points to allow for complex internal customizations by users of the plugin module. It is therefore preferred to export the extension point directly from the module package, rather than creating a separate node library for that purpose. Extension points exported by a module are used the same way as extension points exported by a plugin, you create your own separate module and declare a dependency on the extension point that you want to interact with."}),"\n",(0,i.jsx)(n.h2,{id:"extension-point-design",children:"Extension Point Design"}),"\n",(0,i.jsxs)(n.p,{children:["Designing the extension point interface requires careful consideration. It is a public API surface that your plugin will need to maintain over time. Keep in mind that the installation of modules is an intentional action by the user, meaning you can always design an extension point interface for additions only. For example, there is no need for the ",(0,i.jsx)(n.code,{children:"scaffolderActionsExtensionPoint"})," to support removal of actions, since the user can just uninstall the module that added the action."]}),"\n",(0,i.jsx)(n.p,{children:"Another pattern that can be used is a type of singleton pattern where the extension point is used to add or override some default behavior. For example, let's say the scaffolder wants to expose a way to customize the execution of template tasks. It wouldn't really make sense to allow multiple modules to each add their own task runners, so instead we use a setter to ensure that only one task runner is installed, throwing an error if any other module tries to install another task runner."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"interface ScaffolderTaskRunnerExtensionPoint {\n  setTaskRunner(taskRunner: SchedulerServiceTaskRunner): void;\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["If you want to make breaking changes to an extension point that already has some usage, we recommend that you instead deprecate the existing one and create a new one with a different name. You might want to use a completely new name, but you can also suffix the existing one with a version number, for example ",(0,i.jsx)(n.code,{children:"scaffolderActionsV2ExtensionPoint"}),"."]})]})}function u(e={}){let{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(l,{...e})}):l(e)}},28453(e,n,t){t.d(n,{R:()=>a,x:()=>r});var o=t(296540);let i={},s=o.createContext(i);function a(e){let n=o.useContext(s);return o.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),o.createElement(s.Provider,{value:n},e.children)}},835836(e){e.exports=JSON.parse('{"id":"backend-system/architecture/extension-points","title":"Backend Plugin Extension Points","description":"Extension points of backend plugins","source":"@site/versioned_docs/version-stable/backend-system/architecture/05-extension-points.md","sourceDirName":"backend-system/architecture","slug":"/backend-system/architecture/extension-points","permalink":"/docs/backend-system/architecture/extension-points","draft":false,"unlisted":false,"editUrl":"https://github.com/backstage/backstage/edit/master/docs/backend-system/architecture/05-extension-points.md","tags":[],"version":"stable","sidebarPosition":5,"frontMatter":{"id":"extension-points","title":"Backend Plugin Extension Points","sidebar_label":"Extension Points","description":"Extension points of backend plugins"},"sidebar":"docs","previous":{"title":"Plugins","permalink":"/docs/backend-system/architecture/plugins"},"next":{"title":"Modules","permalink":"/docs/backend-system/architecture/modules"}}')}}]);