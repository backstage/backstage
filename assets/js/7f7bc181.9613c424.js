/*! For license information please see 7f7bc181.9613c424.js.LICENSE.txt */
"use strict";(self.webpackChunkbackstage_microsite=self.webpackChunkbackstage_microsite||[]).push([[466370],{292156:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>r,default:()=>d,frontMatter:()=>o,metadata:()=>s,toc:()=>p});var i=t(474848),a=t(28453);const o={id:"index",title:"Building Frontend Plugins",sidebar_label:"Overview",description:"Building frontend plugins using the new frontend system"},r=void 0,s={id:"frontend-system/building-plugins/index",title:"Building Frontend Plugins",description:"Building frontend plugins using the new frontend system",source:"@site/../docs/frontend-system/building-plugins/01-index.md",sourceDirName:"frontend-system/building-plugins",slug:"/frontend-system/building-plugins/index",permalink:"/docs/next/frontend-system/building-plugins/index",draft:!1,unlisted:!1,editUrl:"https://github.com/backstage/backstage/edit/master/docs/frontend-system/building-plugins/01-index.md",tags:[],version:"current",sidebarPosition:1,frontMatter:{id:"index",title:"Building Frontend Plugins",sidebar_label:"Overview",description:"Building frontend plugins using the new frontend system"},sidebar:"docs",previous:{title:"Changelog",permalink:"/docs/next/frontend-system/architecture/migrations"},next:{title:"Testing",permalink:"/docs/next/frontend-system/building-plugins/testing"}},l={},p=[{value:"Creating a new plugin",id:"creating-a-new-plugin",level:2},{value:"The plugin instance",id:"the-plugin-instance",level:2},{value:"Adding extensions",id:"adding-extensions",level:2},{value:"Utility APIs",id:"utility-apis",level:2},{value:"Plugin specific extensions",id:"plugin-specific-extensions",level:2}];function c(e){const n={a:"a",admonition:"admonition",code:"code",em:"em",h2:"h2",p:"p",pre:"pre",...(0,a.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(n.p,{children:["This section covers how to build your own frontend ",(0,i.jsx)(n.a,{href:"/docs/next/frontend-system/architecture/plugins",children:"plugins"})," and\n",(0,i.jsx)(n.a,{href:"/docs/next/frontend-system/architecture/extension-overrides",children:"overrides"}),". They are sometimes collectively referred to as\nfrontend ",(0,i.jsx)(n.em,{children:"features"}),", and what you install to build up a Backstage frontend ",(0,i.jsx)(n.a,{href:"/docs/next/frontend-system/architecture/app",children:"app"}),"."]}),"\n",(0,i.jsx)(n.h2,{id:"creating-a-new-plugin",children:"Creating a new plugin"}),"\n",(0,i.jsxs)(n.p,{children:["This guide assumes that you already have a Backstage project set up. Even if you only want to develop a single plugin for publishing, we still recommend that you do so in a standard Backstage monorepo project, as you often end up needing multiple packages. For instructions on how to set up a new project, see our ",(0,i.jsx)(n.a,{href:"/docs/next/getting-started/#prerequisites",children:"getting started"})," documentation."]}),"\n",(0,i.jsxs)(n.p,{children:["To create a frontend plugin, run ",(0,i.jsx)(n.code,{children:"yarn new"}),", select ",(0,i.jsx)(n.code,{children:"plugin"}),", and fill out the rest of the prompts. This will create a new package at ",(0,i.jsx)(n.code,{children:"plugins/<pluginId>"}),", which will be the main entrypoint for your plugin."]}),"\n",(0,i.jsx)(n.admonition,{type:"info",children:(0,i.jsx)(n.p,{children:"The created plugin will currently be templated for use in the legacy frontend system, and you will need to replace the existing plugin wiring code."})}),"\n",(0,i.jsx)(n.h2,{id:"the-plugin-instance",children:"The plugin instance"}),"\n",(0,i.jsxs)(n.p,{children:["The starting point of a frontend plugin is the ",(0,i.jsx)(n.code,{children:"createFrontendPlugin"})," function, which accepts a single options object as its only parameter. It is imported from ",(0,i.jsx)(n.code,{children:"@backstage/frontend-plugin-api"}),", which is where you will find most of the common APIs for building plugins."]}),"\n",(0,i.jsx)(n.p,{children:"This is how to create a minimal plugin:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-tsx",metastring:'title="in src/plugin.ts"',children:"import { createFrontendPlugin } from '@backstage/frontend-plugin-api';\n\nexport const examplePlugin = createFrontendPlugin({\n  pluginId: 'example',\n  extensions: [],\n});\n"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-tsx",metastring:'title="in src/index.ts"',children:"export { examplePlugin as default } from './plugin';\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Note that we export the plugin as the default export of our package from ",(0,i.jsx)(n.code,{children:"src/index.ts"}),". This is important, as it is how users of our plugin are able to seamlessly install the plugin package in a Backstage app without having to reference the plugin instance through code."]}),"\n",(0,i.jsxs)(n.p,{children:["The plugin ID should be a lowercase dash-separated string, while the plugin instance variable should be the camel case version of the ID with a ",(0,i.jsx)(n.code,{children:"Plugin"})," suffix. For more details on naming patterns within the frontend system, see ",(0,i.jsx)(n.a,{href:"/docs/next/frontend-system/architecture/naming-patterns",children:"the article on naming patterns"}),". By sticking to these naming patterns you ensure that users of your plugin more easily recognize the exports and features provided by your plugin."]}),"\n",(0,i.jsx)(n.h2,{id:"adding-extensions",children:"Adding extensions"}),"\n",(0,i.jsxs)(n.p,{children:["The plugin that we created above is empty, and doesn't provide any actual functionality. To add functionality to a plugin you need to create and provide it with one or more ",(0,i.jsx)(n.a,{href:"/docs/next/frontend-system/architecture/extensions",children:"extensions"}),". Let's continue by adding a standalone page to our plugin, as well as a navigation item that allows users to navigate to the page."]}),"\n",(0,i.jsxs)(n.p,{children:["To create a new extension you typically use pre-defined ",(0,i.jsx)(n.a,{href:"/docs/next/frontend-system/architecture/extension-blueprints",children:"extension blueprints"}),", provided either by the framework itself or by other plugins. In this case we'll use ",(0,i.jsx)(n.code,{children:"PageBlueprint"})," and ",(0,i.jsx)(n.code,{children:"NavItemBlueprint"}),", both from ",(0,i.jsx)(n.code,{children:"@backstage/frontend-plugin-api"}),". We will also need to ",(0,i.jsx)(n.a,{href:"/docs/next/frontend-system/architecture/routes#creating-a-route-reference",children:"create a route reference"})," to use as a reference for our page, allowing us to dynamically create URLs that link to our page."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-tsx",metastring:'title="in src/routes.ts"',children:"import { createRouteRef } from '@backstage/frontend-plugin-api';\n\n// Typically all routes are defined in src/routes.ts, in order to avoid circular imports.\n\n// This will be the route reference for our example page. If you want to link\n// to the page from somewhere else, you can use this reference to generate the target path.\nexport const rootRouteRef = createRouteRef();\n"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-tsx",metastring:'title="in src/plugin.ts"',children:"import {\n  createFrontendPlugin,\n  PageBlueprint,\n  NavItemBlueprint,\n} from '@backstage/frontend-plugin-api';\nimport { rootRouteRef } from './routes';\n\n// Note that these extensions aren't exported, only the plugin itself is.\n// You can export it locally for testing purposes, but don't export it from the plugin package.\nconst examplePage = PageBlueprint.make({\n  params: {\n    routeRef: rootRouteRef,\n\n    // This is the default path of this page, but integrators are free to override it\n    path: '/example',\n\n    // Page extensions are always dynamically loaded using React.lazy().\n    // All of the functionality of this page is implemented in the\n    // ExamplePage component, which is a regular React component.\n    // highlight-next-line\n    loader: () =>\n      import('./components/ExamplePage').then(m => <m.ExamplePage />),\n  },\n});\n\n// This nav item is provided to the app.nav extension, and will by default be rendered as a sidebar item\nconst exampleNavItem = NavItemBlueprint.make({\n  params: {\n    routeRef: rootRouteRef,\n    title: 'Example',\n    icon: ExampleIcon, // Custom SvgIcon, or one from the Material UI icon library\n  },\n});\n\n// The same plugin as above, now with the extensions added\nexport const examplePlugin = createFrontendPlugin({\n  pluginId: 'example',\n  extensions: [examplePage, exampleNavItem],\n  // We can also make routes available to other plugins.\n  // highlight-start\n  routes: {\n    root: rootRouteRef,\n  },\n  // highlight-end\n});\n"})}),"\n",(0,i.jsxs)(n.p,{children:["What we've built here is a very common type of plugin. It's a top-level tool that provides a single page, along with a method for navigating to that page. The implementation of the page component, in this case the highlighted ",(0,i.jsx)(n.code,{children:"ExamplePage"}),", can be arbitrarily complex. It can be anything from a single simple information page, to a full-blown application with multiple sub-pages."]}),"\n",(0,i.jsxs)(n.p,{children:["We have also provided external access to our route reference by passing it to the plugin ",(0,i.jsx)(n.code,{children:"routes"})," option. This makes it possible for app integrators to bind an external link from a different plugin to our plugin page. You can read more about how this works in the ",(0,i.jsx)(n.a,{href:"/docs/next/frontend-system/architecture/routes#external-route-references",children:"External Route References"})," section."]}),"\n",(0,i.jsx)(n.h2,{id:"utility-apis",children:"Utility APIs"}),"\n",(0,i.jsxs)(n.p,{children:["Another type of extensions that is commonly used are ",(0,i.jsx)(n.a,{href:"/docs/next/frontend-system/utility-apis/index",children:"Utility APIs"}),". They can encapsulate shared pieces of functionality of your plugin, for example an API client for a backend service. You can optionally export your Utility API for other plugins to use, or allow integrators to replace the implementation of your Utility API with their own. For details on how to define and provide your own Utility API in your plugin, see the section on ",(0,i.jsx)(n.a,{href:"/docs/next/frontend-system/utility-apis/creating",children:"creating Utility APIs"}),"."]}),"\n",(0,i.jsx)(n.p,{children:"What we'll show here is a complete example of a simple Utility API used only within the plugin itself:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-tsx",metastring:'title="src/api.ts - Defining an interface, API reference, and default implementation"',children:"import { createApiRef } from '@backstage/frontend-plugin-api';\n\nexport interface ExampleApi {\n  getExample(): { example: string };\n}\n\nexport const exampleApiRef = createApiRef<ExampleApi>({\n  id: 'plugin.example',\n});\n\nexport class DefaultExampleApi implements ExampleApi {\n  getExample(): { example: string } {\n    return { example: 'Hello World!' };\n  }\n}\n"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-tsx",metastring:'title="src/components/ExamplePage.tsx - Using the API in our page component"',children:"import { useApi } from '@backstage/frontend-plugin-api';\nimport { exampleApiRef } from '../api';\n\nexport function ExamplePage() {\n  // highlight-next-line\n  const exampleApi = useApi(exampleApiRef);\n\n  return (\n    <div>\n      <h1>Example Page</h1>\n      <p>Example: {exampleApi.getExample().example}</p>\n    </div>\n  );\n}\n"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-tsx",metastring:'title="in src/plugin.ts - Registering a factory for our API"',children:"import { ApiBlueprint } from '@backstage/frontend-plugin-api';\nimport { exampleApiRef, DefaultExampleApi } from './api';\n\n// highlight-add-start\nconst exampleApi = ApiBlueprint.make({\n  name: 'example',\n  params: defineParams =>\n    defineParams({\n      api: exampleApiRef,\n      deps: {},\n      factory: () => new DefaultExampleApi(),\n    }),\n});\n// highlight-add-end\n\n/* Omitted definitions for examplePage, exampleNavItem, and rootRouteRef. */\n\nexport const examplePlugin = createFrontendPlugin({\n  pluginId: 'example',\n  extensions: [\n    // highlight-add-next-line\n    exampleApi,\n    examplePage,\n    exampleNavItem,\n  ],\n  routes: {\n    root: rootRouteRef,\n  },\n});\n"})}),"\n",(0,i.jsx)(n.h2,{id:"plugin-specific-extensions",children:"Plugin specific extensions"}),"\n",(0,i.jsxs)(n.p,{children:["There are many different plugins that you can extend with additional functionality through extensions. One such plugin is ",(0,i.jsx)(n.a,{href:"https://backstage.io/docs/features/software-catalog/",children:"the catalog plugin"}),", one of the core features of Backstage. It lets you catalog the software in your organization, where each item in the catalog has its own page that can be populated with tools and information relating to that catalog entity. In this example we will explore how our plugin can provide such a tool to display on an entity page."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-tsx",metastring:'title="in src/plugin.ts - An example entity content extension"',children:"import { EntityContentBlueprint } from '@backstage/plugin-catalog-react/alpha';\n\n// Entity content extensions are similar to page extensions in that they are rendered at a route,\n// although they also have a title to support in-line navigation between the different content.\n// Just like a page extension the content is lazy loaded, and you can also provide a\n// route reference if you want to be able to generate a URL that links to the content.\nconst exampleEntityContent = EntityContentBlueprint.make({\n  params: {\n    path: 'example',\n    title: 'Example',\n    loader: () =>\n      import('./components/ExampleEntityContent').then(m => (\n        <m.ExampleEntityContent />\n      )),\n  },\n});\n\nexport const examplePlugin = createFrontendPlugin({\n  pluginId: 'example',\n  extensions: [\n    // highlight-add-next-line\n    exampleEntityContent,\n    exampleApi,\n    examplePage,\n    exampleNavItem,\n  ],\n  routes: {\n    root: rootRouteRef,\n  },\n});\n"})}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"ExampleEntityContent"})," itself is again a regular React component where you can implement any functionality you want. To access the entity that the content is being rendered for, you can use the ",(0,i.jsx)(n.code,{children:"useEntity"})," hook from ",(0,i.jsx)(n.code,{children:"@backstage/plugin-catalog-react"}),". You can see a full list of APIs provided by the catalog React library in ",(0,i.jsx)(n.a,{href:"/docs/next/reference/plugin-catalog-react",children:"the API reference"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["For a more complete list of the different kinds of extensions that you can create for your plugin, see the ",(0,i.jsx)(n.a,{href:"/docs/next/frontend-system/building-plugins/common-extension-blueprints",children:"extension blueprints"})," section."]})]})}function d(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}},221020:(e,n,t)=>{var i=t(296540),a=Symbol.for("react.element"),o=Symbol.for("react.fragment"),r=Object.prototype.hasOwnProperty,s=i.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner,l={key:!0,ref:!0,__self:!0,__source:!0};function p(e,n,t){var i,o={},p=null,c=null;for(i in void 0!==t&&(p=""+t),void 0!==n.key&&(p=""+n.key),void 0!==n.ref&&(c=n.ref),n)r.call(n,i)&&!l.hasOwnProperty(i)&&(o[i]=n[i]);if(e&&e.defaultProps)for(i in n=e.defaultProps)void 0===o[i]&&(o[i]=n[i]);return{$$typeof:a,type:e,key:p,ref:c,props:o,_owner:s.current}}n.Fragment=o,n.jsx=p,n.jsxs=p},474848:(e,n,t)=>{e.exports=t(221020)},28453:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>s});var i=t(296540);const a={},o=i.createContext(a);function r(e){const n=i.useContext(o);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:r(e.components),i.createElement(o.Provider,{value:n},e.children)}}}]);