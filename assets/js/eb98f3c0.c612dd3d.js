"use strict";(self.webpackChunkbackstage_microsite=self.webpackChunkbackstage_microsite||[]).push([["90242"],{325340(e,n,i){i.r(n),i.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>l,frontMatter:()=>o,metadata:()=>t,toc:()=>d});var t=i(585064),r=i(474848),s=i(28453);let o={id:"index",title:"Authentication in Backstage",description:"Introduction to authentication in Backstage"},a,c={},d=[{value:"Built-in Authentication Providers",id:"built-in-authentication-providers",level:2},{value:"Configuring Authentication Providers",id:"configuring-authentication-providers",level:2},{value:"Sign-In Configuration",id:"sign-in-configuration",level:2},{value:"Using Multiple Providers",id:"using-multiple-providers",level:3},{value:"Conditionally Render Sign In Provider",id:"conditionally-render-sign-in-provider",level:3},{value:"Sign-In with Proxy Providers",id:"sign-in-with-proxy-providers",level:2},{value:"Scaffolder Configuration (Software Templates)",id:"scaffolder-configuration-software-templates",level:2},{value:"For Plugin Developers",id:"for-plugin-developers",level:2},{value:"Identity for Plugin Developers",id:"identity-for-plugin-developers",level:3},{value:"Accessing Third Party Resources",id:"accessing-third-party-resources",level:3},{value:"Custom Authentication Provider",id:"custom-authentication-provider",level:2},{value:"Custom ScmAuthApi Implementation",id:"custom-scmauthapi-implementation",level:2},{value:"Configuring token issuers",id:"configuring-token-issuers",level:2}];function h(e){let n={a:"a",admonition:"admonition",code:"code",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",ul:"ul",...(0,s.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.p,{children:"The authentication system in Backstage serves two distinct purposes: sign-in and\nidentification of users, as well as delegating access to third-party resources. It is possible to\nconfigure Backstage to have any number of authentication providers, but only\none of these will typically be used for sign-in, with the rest being used to provide\naccess to external resources."}),"\n",(0,r.jsx)(n.admonition,{title:"Note",type:"note",children:(0,r.jsxs)(n.p,{children:["Identity management and the Sign-In page in Backstage will only block external access when using the new backend system, without setting ",(0,r.jsx)(n.code,{children:"backend.auth.dangerouslyDisableDefaultAuthPolicy"})," in configuration. Even so, the frontend bundle is not protected from external access, protecting it requires the use of the ",(0,r.jsx)(n.a,{href:"https://backstage.io/docs/tutorials/enable-public-entry/",children:"experimental public entry point"}),". You can learn more about this in the ",(0,r.jsx)(n.a,{href:"/docs/next/overview/threat-model#operator-responsibilities",children:"Threat Model"}),"."]})}),"\n",(0,r.jsx)(n.h2,{id:"built-in-authentication-providers",children:"Built-in Authentication Providers"}),"\n",(0,r.jsx)(n.p,{children:"Backstage comes with many common authentication providers in the core library:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"/docs/next/auth/auth0/provider",children:"Auth0"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"/docs/next/auth/atlassian/provider",children:"Atlassian"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"/docs/next/auth/microsoft/provider",children:"Azure"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"/docs/next/auth/microsoft/easy-auth",children:"Azure Easy Auth"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"/docs/next/auth/bitbucket/provider",children:"Bitbucket"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"/docs/next/auth/bitbucketServer/provider",children:"Bitbucket Server"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"/docs/next/auth/cloudflare/provider",children:"Cloudflare Access"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"/docs/next/auth/github/provider",children:"GitHub"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"/docs/next/auth/gitlab/provider",children:"GitLab"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"/docs/next/auth/google/provider",children:"Google"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"/docs/next/auth/google/gcp-iap-auth",children:"Google IAP"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"/docs/next/auth/okta/provider",children:"Okta"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"/docs/next/auth/oauth2-proxy/provider",children:"OAuth 2 Custom Proxy"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"/docs/next/auth/onelogin/provider",children:"OneLogin"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"/docs/next/auth/openshift/provider",children:"OpenShift"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"/docs/next/auth/vmware-cloud/provider",children:"VMware Cloud"})}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"These built-in providers handle the authentication flow for a particular service, including required scopes, callbacks, etc. These providers are each added to a\nBackstage app in a similar way."}),"\n",(0,r.jsx)(n.h2,{id:"configuring-authentication-providers",children:"Configuring Authentication Providers"}),"\n",(0,r.jsxs)(n.p,{children:["Each built-in provider has a configuration block under the ",(0,r.jsx)(n.code,{children:"auth"})," section of\n",(0,r.jsx)(n.code,{children:"app-config.yaml"}),". For example, the GitHub provider:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-yaml",children:"auth:\n  environment: development\n  providers:\n    github:\n      development:\n        clientId: ${AUTH_GITHUB_CLIENT_ID}\n        clientSecret: ${AUTH_GITHUB_CLIENT_SECRET}\n"})}),"\n",(0,r.jsx)(n.p,{children:"See the documentation for a particular provider to see what configuration is\nneeded."}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"providers"})," key may have several authentication providers if multiple\nauthentication methods are supported. Each provider may also have configuration\nfor different authentication environments (development, production, etc). This\nallows a single auth backend to serve multiple environments, such as running a\nlocal frontend against a deployed backend. The provider configuration matching\nthe local ",(0,r.jsx)(n.code,{children:"auth.environment"})," setting will be selected."]}),"\n",(0,r.jsx)(n.h2,{id:"sign-in-configuration",children:"Sign-In Configuration"}),"\n",(0,r.jsxs)(n.p,{children:["Using an authentication provider for sign-in is something you need to configure\nboth in the frontend app as well as the ",(0,r.jsx)(n.code,{children:"auth"})," backend plugin. For information\non how to configure the backend app, see ",(0,r.jsx)(n.a,{href:"/docs/next/auth/identity-resolver",children:"Sign-in Identities and Resolvers"}),".\nThe rest of this section will focus on how to configure sign-in for the frontend app."]}),"\n",(0,r.jsxs)(n.p,{children:["Sign-in is configured by providing a custom ",(0,r.jsx)(n.code,{children:"SignInPage"})," app component. It will be\nrendered before any other routes in the app and is responsible for providing the\nidentity of the current user. The ",(0,r.jsx)(n.code,{children:"SignInPage"})," can render any number of pages and\ncomponents, or just blank space with logic running in the background. In the end, however, it must provide a valid Backstage user identity through the ",(0,r.jsx)(n.code,{children:"onSignInSuccess"}),"\ncallback prop, at which point the rest of the app is rendered."]}),"\n",(0,r.jsxs)(n.p,{children:["If you want to, you can use the ",(0,r.jsx)(n.code,{children:"SignInPage"})," component that is provided by ",(0,r.jsx)(n.code,{children:"@backstage/core-components"}),",\nwhich takes either a ",(0,r.jsx)(n.code,{children:"provider"})," or ",(0,r.jsx)(n.code,{children:"providers"})," (array) prop of ",(0,r.jsx)(n.code,{children:"SignInProviderConfig"})," definitions."]}),"\n",(0,r.jsxs)(n.p,{children:["The following example for GitHub shows the additions needed to ",(0,r.jsx)(n.code,{children:"packages/app/src/App.tsx"}),",\nand can be adapted to any of the built-in providers:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-tsx",metastring:'title="packages/app/src/App.tsx"',children:"/* highlight-add-start */\nimport { githubAuthApiRef } from '@backstage/core-plugin-api';\nimport { SignInPage } from '@backstage/core-components';\n/* highlight-add-end */\n\nconst app = createApp({\n  /* highlight-add-start */\n  components: {\n    SignInPage: props => (\n      <SignInPage\n        {...props}\n        auto\n        provider={{\n          id: 'github-auth-provider',\n          title: 'GitHub',\n          message: 'Sign in using GitHub',\n          apiRef: githubAuthApiRef,\n        }}\n      />\n    ),\n  },\n  /* highlight-add-end */\n  // ..\n});\n"})}),"\n",(0,r.jsx)(n.admonition,{title:"Note",type:"note",children:(0,r.jsxs)(n.p,{children:["You can configure sign-in to use a redirect flow with no pop-up by adding\n",(0,r.jsx)(n.code,{children:"enableExperimentalRedirectFlow: true"})," to the root of your ",(0,r.jsx)(n.code,{children:"app-config.yaml"})]})}),"\n",(0,r.jsx)(n.h3,{id:"using-multiple-providers",children:"Using Multiple Providers"}),"\n",(0,r.jsxs)(n.p,{children:["You can also use the ",(0,r.jsx)(n.code,{children:"providers"})," prop to enable multiple sign-in methods, for example to allow guest access:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-tsx",metastring:'title="packages/app/src/App.tsx"',children:"const app = createApp({\n  /* highlight-add-start */\n  components: {\n    SignInPage: props => (\n      <SignInPage\n        {...props}\n        providers={[\n          'guest',\n          {\n            id: 'github-auth-provider',\n            title: 'GitHub',\n            message: 'Sign in using GitHub',\n            apiRef: githubAuthApiRef,\n          },\n        ]}\n      />\n    ),\n  },\n  /* highlight-add-end */\n  // ..\n});\n"})}),"\n",(0,r.jsx)(n.h3,{id:"conditionally-render-sign-in-provider",children:"Conditionally Render Sign In Provider"}),"\n",(0,r.jsx)(n.p,{children:"In the above example, you have both Guest and GitHub sign-in options; this is helpful for non-production, but in Production you will most likely not want to offer Guest access. You can easily use information from your config to help conditionally render the provider:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-tsx",metastring:'title="packages/app/src/App.tsx"',children:"import {\n  configApiRef,\n  githubAuthApiRef,\n  useApi,\n} from '@backstage/core-plugin-api';\n\nconst app = createApp({\n  components: {\n    SignInPage: props => {\n      const configApi = useApi(configApiRef);\n      if (configApi.getString('auth.environment') === 'development') {\n        return (\n          <SignInPage\n            {...props}\n            providers={[\n              'guest',\n              {\n                id: 'github-auth-provider',\n                title: 'GitHub',\n                message: 'Sign in using GitHub',\n                apiRef: githubAuthApiRef,\n              },\n            ]}\n          />\n        );\n      }\n      return (\n        <SignInPage\n          {...props}\n          provider={{\n            id: 'google-auth-provider',\n            title: 'Google',\n            message: 'Sign In using Google',\n            apiRef: googleAuthApiRef,\n          }}\n        />\n      );\n    },\n  },\n  // ..\n});\n"})}),"\n",(0,r.jsx)(n.h2,{id:"sign-in-with-proxy-providers",children:"Sign-In with Proxy Providers"}),"\n",(0,r.jsxs)(n.p,{children:['Some auth providers are so-called "proxy" providers, meaning they\'re meant to be used\nbehind an authentication proxy. Examples of these are\n',(0,r.jsx)(n.a,{href:"https://github.com/backstage/backstage/blob/master/contrib/docs/tutorials/aws-alb-aad-oidc-auth.md",children:"Amazon Application Load Balancer"}),",\n",(0,r.jsx)(n.a,{href:"/docs/next/auth/microsoft/easy-auth",children:"Azure EasyAuth"}),",\n",(0,r.jsx)(n.a,{href:"/docs/next/auth/cloudflare/provider",children:"Cloudflare Access"}),",\n",(0,r.jsx)(n.a,{href:"/docs/next/auth/google/gcp-iap-auth",children:"Google Identity-Aware Proxy"}),"\nand ",(0,r.jsx)(n.a,{href:"/docs/next/auth/oauth2-proxy/provider",children:"OAuth2 Proxy"}),"."]}),"\n",(0,r.jsxs)(n.p,{children:["When using a proxy provider, you'll end up wanting to use a different sign-in page, as\nthere is no need for further user interaction once you've signed in towards the proxy.\nAll the sign-in page needs to do is call the ",(0,r.jsx)(n.code,{children:"/refresh"})," endpoint of the auth providers\nto get the existing session, which is exactly what the ",(0,r.jsx)(n.code,{children:"ProxiedSignInPage"})," does. The only\nthing you need to do to configure the ",(0,r.jsx)(n.code,{children:"ProxiedSignInPage"})," is to pass the ID of the provider like this:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-tsx",metastring:'title="packages/app/src/App.tsx"',children:"import { ProxiedSignInPage } from '@backstage/core-components';\n\nconst app = createApp({\n  components: {\n    SignInPage: props => <ProxiedSignInPage {...props} provider=\"awsalb\" />,\n  },\n  // ..\n});\n"})}),"\n",(0,r.jsxs)(n.p,{children:["If the provider in auth backend expects additional headers such as ",(0,r.jsx)(n.code,{children:"x-provider-token"}),", there is now a way to configure that in ",(0,r.jsx)(n.code,{children:"ProxiedSignInPage"})," using the optional ",(0,r.jsx)(n.code,{children:"headers"})," prop."]}),"\n",(0,r.jsx)(n.p,{children:"Example:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-tsx",children:"<ProxiedSignInPage\n  {...props}\n  provider=\"my-custom-provider\"\n  /* highlight-next-line */\n  headers={{ 'x-some-key': someValue }}\n/>\n"})}),"\n",(0,r.jsx)(n.p,{children:"Headers can also be returned in an async manner:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-tsx",children:"<ProxiedSignInPage\n  {...props}\n  provider=\"my-custom-provider\"\n  /* highlight-start */\n  headers={async () => {\n    const someValue = await someFn();\n    return { 'x-some-key': someValue };\n  }}\n  /* highlight-end */\n/>\n"})}),"\n",(0,r.jsxs)(n.p,{children:["A downside of this method is that it can be cumbersome to set up for local development.\nAs a workaround for this, it's possible to dynamically select the sign-in page based on\nwhat environment the app is running in and then use a different sign-in method for local\ndevelopment, if one is needed at all. Depending on the exact setup, one might choose to\nselect the sign-in method based on the ",(0,r.jsx)(n.code,{children:"process.env.NODE_ENV"})," environment variable,\nby checking the ",(0,r.jsx)(n.code,{children:"hostname"})," of the current location, or by accessing the configuration API\nto read a configuration value. For example:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-tsx",metastring:'title="packages/app/src/App.tsx"',children:"const app = createApp({\n  components: {\n    SignInPage: props => {\n      const configApi = useApi(configApiRef);\n      if (configApi.getString('auth.environment') === 'development') {\n        return (\n          <SignInPage\n            {...props}\n            provider={{\n              id: 'google-auth-provider',\n              title: 'Google',\n              message: 'Sign In using Google',\n              apiRef: googleAuthApiRef,\n            }}\n          />\n        );\n      }\n      return <ProxiedSignInPage {...props} provider=\"gcpiap\" />;\n    },\n  },\n  // ..\n});\n"})}),"\n",(0,r.jsx)(n.p,{children:"When using multiple auth providers like this, it's important that you configure the different\nsign-in resolvers so that they resolve to the same identity regardless of the method used."}),"\n",(0,r.jsx)(n.h2,{id:"scaffolder-configuration-software-templates",children:"Scaffolder Configuration (Software Templates)"}),"\n",(0,r.jsxs)(n.p,{children:["If you want to use the authentication capabilities of the ",(0,r.jsx)(n.a,{href:"/docs/next/features/software-templates/writing-templates#the-repository-picker",children:"Repository Picker"})," inside your software templates, you will need to configure the ",(0,r.jsx)(n.a,{href:"https://backstage.io/api/stable/interfaces/_backstage_integration-react.ScmAuthApi.html",children:(0,r.jsx)(n.code,{children:"ScmAuthApi"})})," alongside your authentication provider. It is an API used to authenticate towards different SCM systems in a generic way, based on what resource is being accessed."]}),"\n",(0,r.jsxs)(n.p,{children:["To set it up, you'll need to add an API factory entry to ",(0,r.jsx)(n.code,{children:"packages/app/src/apis.ts"}),". The example below sets up the ",(0,r.jsx)(n.code,{children:"ScmAuthApi"})," for an already configured GitLab authentication provider:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",metastring:'title="packages/app/src/apis.ts"',children:"createApiFactory({\n  api: scmAuthApiRef,\n  deps: {\n    gitlabAuthApi: gitlabAuthApiRef,\n  },\n  factory: ({ gitlabAuthApi }) => ScmAuth.forGitlab(gitlabAuthApi),\n});\n"})}),"\n",(0,r.jsxs)(n.p,{children:["In case you are using a custom authentication providers, you might need to add a ",(0,r.jsxs)(n.a,{href:"/docs/next/auth/#custom-scmauthapi-implementation",children:["custom ",(0,r.jsx)(n.code,{children:"ScmAuthApi"})," implementation"]}),"."]}),"\n",(0,r.jsx)(n.h2,{id:"for-plugin-developers",children:"For Plugin Developers"}),"\n",(0,r.jsx)(n.p,{children:"The Backstage frontend core APIs provide a set of Utility APIs for plugin developers\nto use, both to access the user identity as well as third-party resources."}),"\n",(0,r.jsx)(n.h3,{id:"identity-for-plugin-developers",children:"Identity for Plugin Developers"}),"\n",(0,r.jsxs)(n.p,{children:["For plugin developers, there is one main touchpoint for accessing the user identity: the\n",(0,r.jsx)(n.code,{children:"IdentityApi"})," exported by ",(0,r.jsx)(n.code,{children:"@backstage/core-plugin-api"})," via the ",(0,r.jsx)(n.code,{children:"identityApiRef"}),"."]}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"IdentityApi"})," gives access to the signed-in user's identity in the frontend.\nIt provides access to the user's entity reference, lightweight profile information, and\na Backstage token that identifies the user when making authenticated calls within Backstage."]}),"\n",(0,r.jsxs)(n.p,{children:["When making calls to backend plugins, we recommend that the ",(0,r.jsx)(n.code,{children:"FetchApi"})," is used, which\nis exported via the ",(0,r.jsx)(n.code,{children:"fetchApiRef"})," from ",(0,r.jsx)(n.code,{children:"@backstage/core-plugin-api"}),". The ",(0,r.jsx)(n.code,{children:"FetchApi"})," will\nautomatically include a Backstage token in the request, meaning there is no need\nto interact directly with the ",(0,r.jsx)(n.code,{children:"IdentityApi"}),"."]}),"\n",(0,r.jsx)(n.h3,{id:"accessing-third-party-resources",children:"Accessing Third Party Resources"}),"\n",(0,r.jsx)(n.p,{children:"A common pattern for talking to third-party services in Backstage is\nuser-to-server requests, where short-lived OAuth Access Tokens are requested by\nplugins to authenticate calls to external services. These calls can be made\neither directly to the services or through a backend plugin or service."}),"\n",(0,r.jsx)(n.p,{children:"By relying on user-to-server calls, we keep the coupling between the frontend and\nbackend low and provide a much lower barrier for plugins to make use of third\nparty services. This is in comparison to, for example, a session-based system\nwhere access tokens are stored server-side. Such a solution would require a much\ndeeper coupling between the auth backend plugin, its session storage, and other\nbackend plugins or separate services. A goal of Backstage is to make it as easy\nas possible to create new plugins, and an auth solution based on user-to-server\nOAuth helps in that regard."}),"\n",(0,r.jsxs)(n.p,{children:["The method with which frontend plugins request access to third-party services is\nthrough ",(0,r.jsx)(n.a,{href:"/docs/next/api/utility-apis",children:"Utility APIs"})," for each service provider. These\nare all suffixed with ",(0,r.jsx)(n.code,{children:"*AuthApiRef"}),", for example ",(0,r.jsx)(n.code,{children:"githubAuthApiRef"}),". For a\nfull list of providers, see the\n",(0,r.jsx)(n.a,{href:"https://backstage.io/api/stable/modules/_backstage_core-plugin-api.index.html#alertapiref",children:"@backstage/core-plugin-api"})," reference."]}),"\n",(0,r.jsx)(n.h2,{id:"custom-authentication-provider",children:"Custom Authentication Provider"}),"\n",(0,r.jsx)(n.p,{children:"There are generic authentication providers for OAuth2 and SAML. These can reduce\nthe amount of code needed to implement a custom authentication provider that\nadheres to these standards."}),"\n",(0,r.jsxs)(n.p,{children:["Backstage uses ",(0,r.jsx)(n.a,{href:"http://www.passportjs.org/",children:"Passport"})," under the hood, which has\na wide library of authentication strategies for different providers. See\n",(0,r.jsx)(n.a,{href:"/docs/next/auth/add-auth-provider",children:"Add authentication provider"})," for details on adding a new\nPassport-supported authentication method."]}),"\n",(0,r.jsx)(n.h2,{id:"custom-scmauthapi-implementation",children:"Custom ScmAuthApi Implementation"}),"\n",(0,r.jsxs)(n.p,{children:["The default ",(0,r.jsx)(n.code,{children:"ScmAuthApi"})," provides integrations for ",(0,r.jsx)(n.code,{children:"github"}),", ",(0,r.jsx)(n.code,{children:"gitlab"}),", ",(0,r.jsx)(n.code,{children:"azure"})," and ",(0,r.jsx)(n.code,{children:"bitbucket"})," and is created by the following code in ",(0,r.jsx)(n.code,{children:"packages/app/src/apis.ts"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"ScmAuth.createDefaultApiFactory();\n"})}),"\n",(0,r.jsxs)(n.p,{children:["If you require only a subset of these integrations, then you will need a custom implementation of the ",(0,r.jsx)(n.a,{href:"https://backstage.io/api/stable/interfaces/_backstage_integration-react.ScmAuthApi.html",children:(0,r.jsx)(n.code,{children:"ScmAuthApi"})}),". It is an API used to authenticate different SCM systems generically, based on what resource is being accessed, and is used for example, by the Scaffolder (Software Templates) and Catalog Import plugins."]}),"\n",(0,r.jsx)(n.p,{children:"The first step is to remove the code that creates the default providers."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",metastring:'title="packages/app/src/apis.ts"',children:"import {\n  ScmIntegrationsApi,\n  scmIntegrationsApiRef,\n  /* highlight-add-next-line */\n  ScmAuth,\n} from '@backstage/integration-react';\n\nexport const apis: AnyApiFactory[] = [\n  /* highlight-add-next-line */\n  ScmAuth.createDefaultApiFactory(),\n  // ...\n];\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Then replace it with something like this, which will create an ",(0,r.jsx)(n.code,{children:"ApiFactory"})," with only a GitHub provider."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",metastring:'title="packages/app/src/apis.ts"',children:"export const apis: AnyApiFactory[] = [\n  createApiFactory({\n    api: scmAuthApiRef,\n    deps: {\n      githubAuthApi: githubAuthApiRef,\n    },\n    factory: ({ githubAuthApi }) =>\n      ScmAuth.merge(\n        ScmAuth.forGithub(githubAuthApi),\n      ),\n  });\n"})}),"\n",(0,r.jsxs)(n.p,{children:["If you use any custom authentication integrations, a new provider can be added to the ",(0,r.jsx)(n.code,{children:"ApiFactory"}),"."]}),"\n",(0,r.jsxs)(n.p,{children:["The first step is to create a new authentication ref, which follows the naming convention of ",(0,r.jsx)(n.code,{children:"xxxAuthApiRef"}),". The example below is for a new GitHub enterprise integration which can be defined either inside the app itself if it's only used for this purpose or inside a common internal package for APIs, such as ",(0,r.jsx)(n.code,{children:"@internal/apis"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"const gheAuthApiRef: ApiRef<OAuthApi & ProfileInfoApi & SessionApi> =\n  createApiRef({\n    id: 'internal.auth.ghe',\n  });\n"})}),"\n",(0,r.jsx)(n.p,{children:"This new API ref will only work if you define an API factory for it. For example:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"createApiFactory({\n  api: gheAuthApiRef,\n  deps: {\n    discoveryApi: discoveryApiRef,\n    oauthRequestApi: oauthRequestApiRef,\n    configApi: configApiRef,\n  },\n  factory: ({ discoveryApi, oauthRequestApi, configApi }) =>\n    GithubAuth.create({\n      configApi,\n      discoveryApi,\n      oauthRequestApi,\n      provider: { id: 'ghe', title: 'GitHub Enterprise', icon: () => null },\n      defaultScopes: ['read:user'],\n      environment: configApi.getOptionalString('auth.environment'),\n    }),\n});\n"})}),"\n",(0,r.jsx)(n.p,{children:"The new API ref is then used to add a new provider to the ApiFactory:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"createApiFactory({\n  api: scmAuthApiRef,\n  deps: {\n    gheAuthApi: gheAuthApiRef,\n    githubAuthApi: githubAuthApiRef,\n  },\n  factory: ({ githubAuthApi, gheAuthApi }) =>\n    ScmAuth.merge(\n      ScmAuth.forGithub(githubAuthApi),\n      ScmAuth.forGithub(gheAuthApi, {\n        host: 'ghe.example.com',\n      }),\n    ),\n});\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Finally, you also need to add and configure another provider to the ",(0,r.jsx)(n.code,{children:"auth-backend"})," using the provider ID, which in this example is ",(0,r.jsx)(n.code,{children:"ghe"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"import { providers } from '@backstage/plugin-auth-backend';\n\n// Add the following options to `createRouter` in packages/backend/src/plugins/auth.ts\nproviderFactories: {\n  ghe: providers.github.create(),\n},\n"})}),"\n",(0,r.jsxs)(n.p,{children:["In the new backend system you can leverage the ",(0,r.jsx)(n.code,{children:"authProvidersExtensionPoint"})," for this:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"// your-auth-plugin-module.ts\nexport const gheAuth = createBackendModule({\n  // This ID must be exactly \"auth\" because that's the plugin it targets\n  pluginId: 'auth',\n  // This ID must be unique, but can be anything\n  moduleId: 'ghe-auth-provider',\n  register(reg) {\n    reg.registerInit({\n      deps: {\n        providers: authProvidersExtensionPoint,\n        logger: coreServices.logger,\n      },\n      async init({ providers, logger }) {\n        providers.registerProvider({\n          // This ID must match the actual provider config, e.g. addressing\n          // auth.providers.ghe means that this must be \"ghe\".\n          providerId: 'ghe',\n          factory: createOAuthProviderFactory({\n            authenticator: githubAuthenticator,\n            signInResolverFactories: {\n              ...commonSignInResolvers,\n            },\n          }),\n        });\n      },\n    });\n  },\n});\n\n// backend index.ts\nbackend.add(gheAuth);\n"})}),"\n",(0,r.jsx)(n.h2,{id:"configuring-token-issuers",children:"Configuring token issuers"}),"\n",(0,r.jsx)(n.p,{children:"By default, the Backstage authentication backend generates and manages its own signing keys automatically for any issued\nBackstage tokens. However, these keys have a short lifetime and do not persist after instance restarts."}),"\n",(0,r.jsx)(n.p,{children:"Alternatively, users can provide their own public and private key files to sign issued tokens. This is beneficial in\nscenarios where the token verification implementation aggressively caches the list of keys, and doesn't attempt to fetch\nnew ones even if they encounter an unknown key id. To enable this feature add the following configuration to your config\nfile:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-yaml",children:"auth:\n  keyStore:\n    provider: 'static'\n    static:\n      keys:\n        # Must be declared at least once and the first one will be used for signing\n        - keyId: 'primary'\n          publicKeyFile: /path/to/public.key\n          privateKeyFile: /path/to/private.key\n          algorithm: # Optional, algorithm used to generate the keys, defaults to ES256\n          # More keys can be added so with future key rotations caches already know about it\n        - keyId: ...\n"})}),"\n",(0,r.jsx)(n.p,{children:"The private key should be stored in the PKCS#8 format. The public key should be stored in the SPKI format.\nYou can generate the public/private key pair, using openssl and the ES256 algorithm by performing the following\nsteps:"}),"\n",(0,r.jsx)(n.p,{children:"Generate a private key using the ES256 algorithm"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-sh",children:"openssl ecparam -name prime256v1 -genkey -out private.ec.key\n"})}),"\n",(0,r.jsx)(n.p,{children:"Convert it to PKCS#8 format"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-sh",children:"openssl pkcs8 -topk8 -inform PEM -outform PEM -nocrypt -in private.ec.key -out private.key\n"})}),"\n",(0,r.jsx)(n.p,{children:"Extract the public key"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-sh",children:"openssl ec -inform PEM -outform PEM -pubout -in private.key -out public.key\n"})})]})}function l(e={}){let{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(h,{...e})}):h(e)}},28453(e,n,i){i.d(n,{R:()=>o,x:()=>a});var t=i(296540);let r={},s=t.createContext(r);function o(e){let n=t.useContext(s);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:o(e.components),t.createElement(s.Provider,{value:n},e.children)}},585064(e){e.exports=JSON.parse('{"id":"auth/index","title":"Authentication in Backstage","description":"Introduction to authentication in Backstage","source":"@site/../docs/auth/index.md","sourceDirName":"auth","slug":"/auth/","permalink":"/docs/next/auth/","draft":false,"unlisted":false,"editUrl":"https://github.com/backstage/backstage/edit/master/docs/auth/index.md","tags":[],"version":"current","frontMatter":{"id":"index","title":"Authentication in Backstage","description":"Introduction to authentication in Backstage"},"sidebar":"docs","previous":{"title":"Auth and Identity","permalink":"/docs/next/auth-and-identity/generated-index"},"next":{"title":"Included providers","permalink":"/docs/next/included-providers/generated-index"}}')}}]);