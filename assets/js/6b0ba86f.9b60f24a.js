/*! For license information please see 6b0ba86f.9b60f24a.js.LICENSE.txt */
"use strict";(self.webpackChunkbackstage_microsite=self.webpackChunkbackstage_microsite||[]).push([[420258],{174791:(e,n,o)=>{o.r(n),o.d(n,{assets:()=>l,contentTitle:()=>r,default:()=>p,frontMatter:()=>i,metadata:()=>a,toc:()=>d});var t=o(474848),s=o(28453);const i={id:"adrs-adr015",title:"ADR015: Types and naming for element and component options",description:"Architecture Decision Record (ADR) for the proper types and naming for element and component options"},r=void 0,a={id:"architecture-decisions/adrs-adr015",title:"ADR015: Types and naming for element and component options",description:"Architecture Decision Record (ADR) for the proper types and naming for element and component options",source:"@site/versioned_docs/version-stable/architecture-decisions/adr015-jsx-loader-structure.md",sourceDirName:"architecture-decisions",slug:"/architecture-decisions/adrs-adr015",permalink:"/docs/architecture-decisions/adrs-adr015",draft:!1,unlisted:!1,editUrl:"https://github.com/backstage/backstage/edit/master/docs/architecture-decisions/adr015-jsx-loader-structure.md",tags:[],version:"stable",frontMatter:{id:"adrs-adr015",title:"ADR015: Types and naming for element and component options",description:"Architecture Decision Record (ADR) for the proper types and naming for element and component options"}},l={},d=[{value:"Context",id:"context",level:2},{value:"Decision",id:"decision",level:2},{value:"Simple element",id:"simple-element",level:3},{value:"Simple component",id:"simple-component",level:3},{value:"Async element loader",id:"async-element-loader",level:3},{value:"Async component loader",id:"async-component-loader",level:3},{value:"Any component loader",id:"any-component-loader",level:3},{value:"Consequences",id:"consequences",level:2}];function c(e){const n={code:"code",h2:"h2",h3:"h3",p:"p",pre:"pre",...(0,s.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.h2,{id:"context",children:"Context"}),"\n",(0,t.jsx)(n.p,{children:"Until now there hasn't been a clear standard for how to define options that are intended to provide JSX elements or components. This led to a mix of different patterns in public APIs, which this ADR aims to standardize."}),"\n",(0,t.jsx)(n.h2,{id:"decision",children:"Decision"}),"\n",(0,t.jsx)(n.p,{children:"We will use one of the following option property names and types when defining options that are intended to provide JSX elements or components:"}),"\n",(0,t.jsx)(n.h3,{id:"simple-element",children:"Simple element"}),"\n",(0,t.jsx)(n.p,{children:"This option is used when a simple synchronous JSX element is provided. It must only be used in areas where lazy-loading is not needed."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-tsx",children:"{\n  element: JSX.Element;\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"simple-component",children:"Simple component"}),"\n",(0,t.jsx)(n.p,{children:"This option is used when a simple synchronous component is provided. It must only be used in areas where lazy-loading is not needed."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-tsx",children:"{\n  component: (props: { ... }) => JSX.Element | null\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"async-element-loader",children:"Async element loader"}),"\n",(0,t.jsx)(n.p,{children:"This option is used when a simple asynchronous JSX element is provided. It is the preferred option when only producing a single instance and there is no need to pass properties to the component. This format simplifies the creation of closures for passing additional properties in the loader implementation."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-tsx",children:"{\n  loader: () => Promise<JSX.Element>;\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"async-component-loader",children:"Async component loader"}),"\n",(0,t.jsx)(n.p,{children:"This option is used when a simple asynchronous component is provided. It is the preferred option when properties need to be passed to the component or multiple instance are needed, and lazy-loading is required."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-tsx",children:"{\n  loader: () => Promise<(props: { ... }) => JSX.Element | null>\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"any-component-loader",children:"Any component loader"}),"\n",(0,t.jsx)(n.p,{children:"This option is used in the same cases as the async component loader, but when the option of synchronous loading is also needed. The structure of always having the outer loader function, even in the synchronous case, makes it possible to determine the type of the loader at runtime."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-tsx",children:"{\n  loader: (() => props => JSX.Element | null) | (() => Promise<props => JSX.Element | null>)\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Note that when consuming this loader we'll need to unconditionally wrap it with ",(0,t.jsx)(n.code,{children:"React.lazy"}),". This is because you can't delay the call to ",(0,t.jsx)(n.code,{children:"React.lazy"})," until rendering, because you're not allowed to call it within a render function. This means that we can't first call the loader to check whether the returned value is a promise or not, and we must instead unconditionally wrap it with ",(0,t.jsx)(n.code,{children:"React.lazy"}),". Therefore the implementation of accepting one of these loaders as an option needs to look something like this:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-tsx",children:"const LazyComponent = React.lazy(() =>\n  Promise.resolve(options.loader()).then(loaded => ({ default: loaded })),\n);\n"})}),"\n",(0,t.jsx)(n.h2,{id:"consequences",children:"Consequences"}),"\n",(0,t.jsxs)(n.p,{children:["We will update all APIs for the new frontend system in the ",(0,t.jsx)(n.code,{children:"@backstage/frontend-*"})," packages."]}),"\n",(0,t.jsxs)(n.p,{children:["We will not update any of the existing APIs for the old frontend system in the ",(0,t.jsx)(n.code,{children:"@backstage/core-*"})," packages."]})]})}function p(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(c,{...e})}):c(e)}},221020:(e,n,o)=>{var t=o(296540),s=Symbol.for("react.element"),i=Symbol.for("react.fragment"),r=Object.prototype.hasOwnProperty,a=t.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner,l={key:!0,ref:!0,__self:!0,__source:!0};function d(e,n,o){var t,i={},d=null,c=null;for(t in void 0!==o&&(d=""+o),void 0!==n.key&&(d=""+n.key),void 0!==n.ref&&(c=n.ref),n)r.call(n,t)&&!l.hasOwnProperty(t)&&(i[t]=n[t]);if(e&&e.defaultProps)for(t in n=e.defaultProps)void 0===i[t]&&(i[t]=n[t]);return{$$typeof:s,type:e,key:d,ref:c,props:i,_owner:a.current}}n.Fragment=i,n.jsx=d,n.jsxs=d},474848:(e,n,o)=>{e.exports=o(221020)},28453:(e,n,o)=>{o.d(n,{R:()=>r,x:()=>a});var t=o(296540);const s={},i=t.createContext(s);function r(e){const n=t.useContext(i);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),t.createElement(i.Provider,{value:n},e.children)}}}]);