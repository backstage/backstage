/*! For license information please see 06a0cf07.0847eb77.js.LICENSE.txt */
"use strict";(self.webpackChunkbackstage_microsite=self.webpackChunkbackstage_microsite||[]).push([[70754],{47369:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>a,default:()=>p,frontMatter:()=>o,metadata:()=>r,toc:()=>c});var i=n(74848),s=n(28453);const o={id:"sharing-extensions",title:"Sharing Extensions Across Multiple Locations",sidebar_label:"Sharing Extensions",description:"Using Utility APIs to share extensions across multiple locations in your app"},a=void 0,r={id:"frontend-system/architecture/sharing-extensions",title:"Sharing Extensions Across Multiple Locations",description:"Using Utility APIs to share extensions across multiple locations in your app",source:"@site/../docs/frontend-system/architecture/27-sharing-extensions.md",sourceDirName:"frontend-system/architecture",slug:"/frontend-system/architecture/sharing-extensions",permalink:"/docs/next/frontend-system/architecture/sharing-extensions",draft:!1,unlisted:!1,editUrl:"https://github.com/backstage/backstage/edit/master/docs/frontend-system/architecture/27-sharing-extensions.md",tags:[],version:"current",sidebarPosition:27,frontMatter:{id:"sharing-extensions",title:"Sharing Extensions Across Multiple Locations",sidebar_label:"Sharing Extensions",description:"Using Utility APIs to share extensions across multiple locations in your app"}},l={},c=[{value:"Overview",id:"overview",level:2},{value:"Basic Pattern",id:"basic-pattern",level:2},{value:"1. Define the Extension Data Types and API Interface",id:"1-define-the-extension-data-types-and-api-interface",level:3},{value:"2. Provide a Blueprint for Creating Extensions",id:"2-provide-a-blueprint-for-creating-extensions",level:3},{value:"3. Create a Utility API Extension that Collects Extensions",id:"3-create-a-utility-api-extension-that-collects-extensions",level:3},{value:"4. Consume the Extensions via the API",id:"4-consume-the-extensions-via-the-api",level:3}];function d(e){const t={a:"a",code:"code",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",ul:"ul",...(0,s.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.p,{children:"Some plugins may need to provide extensibility that can be reused in multiple locations throughout the app. For example, in the pattern demonstrated on this page, a plugin can be made extensible by allowing widgets to be contributed that are then rendered on multiple pages. To achieve this, the recommended pattern is to use a Utility API that collects the extensions and makes them available throughout the plugin or the app."}),"\n",(0,i.jsx)(t.h2,{id:"overview",children:"Overview"}),"\n",(0,i.jsx)(t.p,{children:"This pattern combines a Utility API with an extension blueprint to:"}),"\n",(0,i.jsxs)(t.ol,{children:["\n",(0,i.jsx)(t.li,{children:"Define the extension data types and API interface"}),"\n",(0,i.jsx)(t.li,{children:"Provide a blueprint for creating extensions"}),"\n",(0,i.jsx)(t.li,{children:"Create a Utility API extension that collects extensions as input"}),"\n",(0,i.jsx)(t.li,{children:"Consume the extensions via the API"}),"\n"]}),"\n",(0,i.jsx)(t.p,{children:"This approach provides a native integration with the frontend system, allowing to further rely on features like making the extensions configurable or have further extension points."}),"\n",(0,i.jsx)(t.h2,{id:"basic-pattern",children:"Basic Pattern"}),"\n",(0,i.jsx)(t.p,{children:"The following example demonstrates this pattern using widgets that can be displayed on multiple pages. However, this pattern is flexible and can be adapted for many different scenarios where you need to:"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"Share the same type of extension across different pages or views"}),"\n",(0,i.jsx)(t.li,{children:"Allow third-party plugins to contribute extensions in a decoupled way"}),"\n",(0,i.jsx)(t.li,{children:"Aggregate similar functionality from multiple sources in a consistent way"}),"\n"]}),"\n",(0,i.jsx)(t.p,{children:"The core concepts remain the same regardless of what type of functionality you're sharing."}),"\n",(0,i.jsx)(t.h3,{id:"1-define-the-extension-data-types-and-api-interface",children:"1. Define the Extension Data Types and API Interface"}),"\n",(0,i.jsxs)(t.p,{children:["First, in your plugin's ",(0,i.jsx)(t.code,{children:"-react"})," package (e.g., ",(0,i.jsx)(t.code,{children:"backstage-plugin-foo-react"}),"), define the widget types and API interface:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-tsx",metastring:'title="in backstage-plugin-foo-react"',children:"import { createApiRef } from '@backstage/frontend-plugin-api';\nimport { ComponentType } from 'react';\n\nexport interface FooWidgetProps {\n  title: string;\n}\n\n// Define what data each widget provides, prefer using lazy loading for large pieces of functionality like components\nexport interface FooWidget {\n  title: string;\n  size: 'small' | 'medium' | 'large';\n  loader: () => Promise<ComponentType<FooWidgetProps>>;\n}\n\n// Define the API interface\nexport interface FooWidgetsApi {\n  getWidgets(): FooWidget[];\n}\n\n// Create the API reference\nexport const fooWidgetsApiRef = createApiRef<FooWidgetsApi>({\n  id: 'plugin.foo.widgets',\n});\n"})}),"\n",(0,i.jsx)(t.h3,{id:"2-provide-a-blueprint-for-creating-extensions",children:"2. Provide a Blueprint for Creating Extensions"}),"\n",(0,i.jsxs)(t.p,{children:["Next, also in your ",(0,i.jsx)(t.code,{children:"-react"})," package (e.g., ",(0,i.jsx)(t.code,{children:"backstage-plugin-foo-react"}),"), create a blueprint that creates extensions. The blueprint creates an internal data reference and exposes it via the ",(0,i.jsx)(t.code,{children:"dataRefs"})," property. This blueprint will be exported for other plugins to use:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-tsx",metastring:'title="in backstage-plugin-foo-react"',children:"import {\n  createExtensionBlueprint,\n  createExtensionDataRef,\n  ExtensionBoundary,\n} from '@backstage/frontend-plugin-api';\n\nconst fooWidgetDataRef = createExtensionDataRef<FooWidget>().with({\n  id: 'foo.widget',\n});\n\nexport const FooWidgetBlueprint = createExtensionBlueprint({\n  kind: 'foo-widget',\n  // Attach extensions created with this blueprint to the API extension that will be created in the next step\n  attachTo: { id: 'api:foo/widgets', input: 'widgets' },\n  output: [fooWidgetDataRef],\n  *factory(params: FooWidget, { node }) {\n    yield fooWidgetDataRef({\n      title: params.title,\n      size: params.size,\n      loader: ExtensionBoundary.lazyComponent(node, params.loader),\n    });\n  },\n  dataRefs: {\n    widget: fooWidgetDataRef,\n  },\n});\n"})}),"\n",(0,i.jsx)(t.h3,{id:"3-create-a-utility-api-extension-that-collects-extensions",children:"3. Create a Utility API Extension that Collects Extensions"}),"\n",(0,i.jsxs)(t.p,{children:["In your main plugin package (e.g., ",(0,i.jsx)(t.code,{children:"backstage-plugin-foo"}),"), create a Utility API extension that collects widgets as input. Note that this imports the blueprint's data reference via ",(0,i.jsx)(t.code,{children:"FooWidgetBlueprint.dataRefs.widget"}),":"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-tsx",metastring:'title="in backstage-plugin-foo"',children:"import {\n  ApiBlueprint,\n  createExtensionInput,\n} from '@backstage/frontend-plugin-api';\nimport {\n  FooWidgetBlueprint,\n  fooWidgetsApiRef,\n} from 'backstage-plugin-foo-react';\n\nexport const FooWidgetsApiExtension = ApiBlueprint.makeWithOverrides({\n  name: 'widgets',\n  inputs: {\n    widgets: createExtensionInput([FooWidgetBlueprint.dataRefs.widget]),\n  },\n  factory(originalFactory, { inputs }) {\n    // Collect all widgets from the inputs and forward them to the API implementation\n    const widgets = inputs.widgets.map(w =>\n      w.get(FooWidgetBlueprint.dataRefs.widget),\n    );\n\n    return originalFactory(defineParams =>\n      defineParams({\n        api: fooWidgetsApiRef,\n        deps: {},\n        factory: () => ({\n          getWidgets: () => widgets,\n        }),\n      }),\n    );\n  },\n});\n"})}),"\n",(0,i.jsxs)(t.p,{children:["Other plugins can now import the blueprint from your ",(0,i.jsx)(t.code,{children:"-react"})," package and create widget extensions that will be collected by the API:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-tsx",metastring:'title="in a consuming plugin"',children:"import { FooWidgetBlueprint } from 'backstage-plugin-foo-react';\n\nconst barWidgetExtension = FooWidgetBlueprint.make({\n  name: 'bar',\n  params: {\n    title: 'Bar Widget',\n    size: 'small',\n    loader: () => import('./components/BarWidget').then(m => m.BarWidget),\n  },\n});\n\nconst bazWidgetExtension = FooWidgetBlueprint.make({\n  name: 'baz',\n  params: {\n    title: 'Baz Widget',\n    size: 'medium',\n    loader: () => import('./components/BazWidget').then(m => m.BazWidget),\n  },\n});\n"})}),"\n",(0,i.jsx)(t.h3,{id:"4-consume-the-extensions-via-the-api",children:"4. Consume the Extensions via the API"}),"\n",(0,i.jsx)(t.p,{children:"You can now consume the widgets using any of the available methods for consuming Utility APIs. For example, this is how you would access the widgets in a component:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-tsx",metastring:'title="in backstage-plugin-foo"',children:"import { useApi } from '@backstage/frontend-plugin-api';\nimport { fooWidgetsApiRef } from 'backstage-plugin-foo-react';\nimport { Suspense, lazy } from 'react';\n\nexport function FooPageContent() {\n  const widgetsApi = useApi(fooWidgetsApiRef);\n  const widgets = widgetsApi.getWidgets();\n\n  return; // load and render widgets ...\n}\n"})}),"\n",(0,i.jsxs)(t.p,{children:["For more information on consuming Utility APIs, see the ",(0,i.jsx)(t.a,{href:"/docs/next/frontend-system/utility-apis/consuming",children:"Consuming Utility APIs"})," page."]})]})}function p(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},21020:(e,t,n)=>{var i=n(96540),s=Symbol.for("react.element"),o=Symbol.for("react.fragment"),a=Object.prototype.hasOwnProperty,r=i.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner,l={key:!0,ref:!0,__self:!0,__source:!0};function c(e,t,n){var i,o={},c=null,d=null;for(i in void 0!==n&&(c=""+n),void 0!==t.key&&(c=""+t.key),void 0!==t.ref&&(d=t.ref),t)a.call(t,i)&&!l.hasOwnProperty(i)&&(o[i]=t[i]);if(e&&e.defaultProps)for(i in t=e.defaultProps)void 0===o[i]&&(o[i]=t[i]);return{$$typeof:s,type:e,key:c,ref:d,props:o,_owner:r.current}}t.Fragment=o,t.jsx=c,t.jsxs=c},74848:(e,t,n)=>{e.exports=n(21020)},28453:(e,t,n)=>{n.d(t,{R:()=>a,x:()=>r});var i=n(96540);const s={},o=i.createContext(s);function a(e){const t=i.useContext(o);return i.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),i.createElement(o.Provider,{value:t},e.children)}}}]);