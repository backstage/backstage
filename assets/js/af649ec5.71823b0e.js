"use strict";(self.webpackChunkbackstage_microsite=self.webpackChunkbackstage_microsite||[]).push([["81591"],{392511(e,n,t){t.r(n),t.d(n,{assets:()=>r,contentTitle:()=>s,default:()=>u,frontMatter:()=>i,metadata:()=>o,toc:()=>l});var o=t(547502),a=t(474848),d=t(28453);let i={id:"module-federation",title:"Module Federation",sidebar_label:"Module Federation",description:"Using Module Federation in Backstage"},s,r={},l=[{value:"Introduction",id:"introduction",level:2},{value:"Overview",id:"overview",level:2},{value:"Module Federation Host vs Remotes",id:"module-federation-host-vs-remotes",level:3},{value:"Shared Dependencies",id:"shared-dependencies",level:3},{value:"Building the Module Federation Host",id:"building-the-module-federation-host",level:2},{value:"Building Module Federation Remotes",id:"building-module-federation-remotes",level:2},{value:"Using the CLI",id:"using-the-cli",level:3},{value:"Build Output",id:"build-output",level:3},{value:"Runtime Usage",id:"runtime-usage",level:2},{value:"Basic Usage",id:"basic-usage",level:3},{value:"Integration with Feature Loaders",id:"integration-with-feature-loaders",level:3},{value:"Default Shared Dependencies",id:"default-shared-dependencies",level:2}];function c(e){let n={a:"a",code:"code",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,d.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.h2,{id:"introduction",children:"Introduction"}),"\n",(0,a.jsx)(n.p,{children:"Module Federation is a feature that enables sharing code and dependencies between separately built JavaScript applications at runtime. In Backstage, module federation support allows you to:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["Build your frontend application as a ",(0,a.jsx)(n.strong,{children:"module federation host"})," that can load remote modules at runtime"]}),"\n",(0,a.jsxs)(n.li,{children:["Package individual plugins or bundles of several plugins as ",(0,a.jsx)(n.strong,{children:"module federation remotes"})," that can be loaded dynamically"]}),"\n",(0,a.jsx)(n.li,{children:"Share dependencies efficiently between the host and remotes to avoid code duplication"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"This guide explains how to configure and build both module federation hosts and remotes in Backstage, and how to initialize module federation at runtime using the standard Module Federation Runtime API."}),"\n",(0,a.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,a.jsx)(n.h3,{id:"module-federation-host-vs-remotes",children:"Module Federation Host vs Remotes"}),"\n",(0,a.jsx)(n.p,{children:"In module federation terminology:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Host"}),": The main frontend application that loads and consumes remote modules. In Backstage, this is your app package (typically ",(0,a.jsx)(n.code,{children:"packages/app"}),")."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Remote"}),": A separately built module that can be loaded by the host at runtime. In Backstage, these are typically plugin packages built as module federation remotes."]}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"shared-dependencies",children:"Shared Dependencies"}),"\n",(0,a.jsxs)(n.p,{children:["A critical aspect of module federation is ",(0,a.jsx)(n.strong,{children:"shared dependencies"}),". When a host loads remote modules, both need to share common dependencies (like React, React Router, Material-UI) in order to ensure singleton dependencies only have one instance."]}),"\n",(0,a.jsxs)(n.p,{children:["Backstage provides a list of default shared dependencies for common packages like React, React Router, and Material-UI. At build-time the ",(0,a.jsx)(n.code,{children:"version"})," field is automatically resolved from your ",(0,a.jsx)(n.code,{children:"package.json"})," files."]}),"\n",(0,a.jsx)(n.h2,{id:"building-the-module-federation-host",children:"Building the Module Federation Host"}),"\n",(0,a.jsx)(n.p,{children:"The module federation host is your main frontend application. By default, Backstage frontend applications include a default list of module federation shared dependencies."}),"\n",(0,a.jsx)(n.p,{children:"When building and bundling the frontend application, the CLI automatically:"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsx)(n.li,{children:"Resolves versions of the shared dependencies based on the monorepo dependencies"}),"\n",(0,a.jsx)(n.li,{children:"Adds an additional entrypoint to the frontend application bundle with the list of resolved runtime shared dependencies"}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"building-module-federation-remotes",children:"Building Module Federation Remotes"}),"\n",(0,a.jsx)(n.p,{children:"Plugin packages can be built as module federation remotes, allowing them to be loaded dynamically by a host application."}),"\n",(0,a.jsx)(n.h3,{id:"using-the-cli",children:"Using the CLI"}),"\n",(0,a.jsxs)(n.p,{children:["To build a plugin as a module federation remote, use the ",(0,a.jsx)(n.code,{children:"--module-federation"})," option with the ",(0,a.jsx)(n.code,{children:"package build"})," command:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-bash",children:"cd plugins/my-plugin\nyarn build --module-federation\n"})}),"\n",(0,a.jsx)(n.h3,{id:"build-output",children:"Build Output"}),"\n",(0,a.jsx)(n.p,{children:"When building a plugin as a module federation remote, the CLI:"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsx)(n.li,{children:"Resolves versions of the shared dependencies based on the monorepo dependencies (done automatically by the Rspack/Webpack module federation plugin)"}),"\n",(0,a.jsxs)(n.li,{children:["Produces the bundle assets in the ",(0,a.jsx)(n.code,{children:"dist"})," folder, including:\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["a ",(0,a.jsx)(n.code,{children:"mf-manifest.json"})," file which contains the module federation manifest"]}),"\n",(0,a.jsxs)(n.li,{children:["a ",(0,a.jsx)(n.code,{children:"remoteEntry.js"})," file which is the main entrypoint for the remote module"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"runtime-usage",children:"Runtime Usage"}),"\n",(0,a.jsx)(n.p,{children:"To use module federation in your Backstage app, you need to initialize the Module Federation Runtime with the shared dependencies configuration."}),"\n",(0,a.jsx)(n.h3,{id:"basic-usage",children:"Basic Usage"}),"\n",(0,a.jsx)(n.p,{children:"Here's how to initialize module federation in your app, and load remote modules:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",metastring:'title="packages/app/src/moduleFederation.ts"',children:"import {\n  createInstance,\n  ModuleFederation,\n} from '@module-federation/enhanced/runtime';\nimport { loadModuleFederationHostShared } from '@backstage/module-federation-common';\n\nexport async function initializeModuleFederation(): Promise<ModuleFederation> {\n  return createInstance({\n    name: 'app',\n    remotes: [\n      {\n        name: 'my_plugin',\n        entry: 'http://localhost:3001/mf-manifest.json',\n      },\n    ],\n    shared: await loadModuleFederationHostShared(),\n  });\n}\n\nexport async function loadRemote(\n  instance: ModuleFederation,\n  name: string,\n): Promise<any> {\n  return await instance.loadRemote<any>(name);\n}\n"})}),"\n",(0,a.jsxs)(n.p,{children:["The ",(0,a.jsx)(n.code,{children:"loadModuleFederationHostShared"})," function loads all shared dependencies in parallel and returns them in the format expected by the Module Federation Runtime. By default it will throw if any shared dependency fails to load. You can pass an ",(0,a.jsx)(n.code,{children:"onError"})," callback to handle errors gracefully instead:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"const shared = await loadModuleFederationHostShared({\n  onError: error => console.error(error.message, error.cause),\n});\n"})}),"\n",(0,a.jsx)(n.h3,{id:"integration-with-feature-loaders",children:"Integration with Feature Loaders"}),"\n",(0,a.jsx)(n.p,{children:"Standard Module Federation runtime API integrates very well with frontend feature loaders,\nas shown in the example below:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",metastring:'title="packages/app/src/loader.tsx"',children:"import { createInstance } from '@module-federation/enhanced/runtime';\nimport { loadModuleFederationHostShared } from '@backstage/module-federation-common';\nimport { createFrontendFeatureLoader } from '@backstage/frontend-plugin-api';\n\nexport const moduleFederationLoader = createFrontendFeatureLoader({\n  async loader() {\n    const moduleFederationInstance = createInstance({\n      name: 'app',\n      remotes: [],\n      shared: await loadModuleFederationHostShared(),\n    });\n    moduleFederationInstance.registerRemotes([\n      {\n        name: 'myFirstRemoteWith2ExposedModules',\n        entry:\n          'https://someCDN.org/myFirstRemoteWith2ExposedModules/mf-manifest.json',\n      },\n      {\n        name: 'mySecondRemote',\n        entry: 'https://someCDN.org/mySecondRemote/mf-manifest.json',\n      },\n    ]);\n    const myFirstRemoteModule1 = await moduleFederationInstance.loadRemote<any>(\n      'myFirstRemoteWith2ExposedModules/module1',\n    );\n    const myFirstRemoteModule2 = await moduleFederationInstance.loadRemote<any>(\n      'myFirstRemoteWith2ExposedModules/module2',\n    );\n    const mySecondRemoteModule = await moduleFederationInstance.loadRemote<any>(\n      'mySecondRemote',\n    );\n    return [\n      myFirstRemoteModule1.default,\n      myFirstRemoteModule2.default,\n      mySecondRemoteModule.default,\n    ];\n  },\n});\n\nconst app = createApp({\n  features: [moduleFederationLoader],\n});\n\nexport default app.createRoot();\n"})}),"\n",(0,a.jsx)(n.p,{children:"Note that, on top of the standard API, we plan to provide a more simplified way to configure module federation remotes."}),"\n",(0,a.jsxs)(n.p,{children:["Additionally, the ",(0,a.jsx)(n.a,{href:"https://github.com/backstage/backstage/blob/master/packages/frontend-dynamic-feature-loader/src/loader.ts",children:(0,a.jsx)(n.code,{children:"dynamicFrontendFeaturesLoader"})})," provided in the ",(0,a.jsx)(n.a,{href:"https://github.com/backstage/backstage/blob/master/packages/frontend-dynamic-feature-loader/README.md",children:(0,a.jsx)(n.code,{children:"@backstage/frontend-dynamic-feature-loader"})})," package, which provides an integrated solution to load module federation remotes as dynamic frontend plugins, is a more complete example of a feature loader based on the module federation support."]}),"\n",(0,a.jsx)(n.h2,{id:"default-shared-dependencies",children:"Default Shared Dependencies"}),"\n",(0,a.jsxs)(n.p,{children:["Default shared dependencies are the same for both the host and remotes, and the list can be found in the ",(0,a.jsx)(n.a,{href:"https://github.com/backstage/backstage/blob/master/packages/module-federation-common/src/defaults.ts",children:(0,a.jsx)(n.code,{children:"@backstage/module-federation-common"})})," package."]})]})}function u(e={}){let{wrapper:n}={...(0,d.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(c,{...e})}):c(e)}},28453(e,n,t){t.d(n,{R:()=>i,x:()=>s});var o=t(296540);let a={},d=o.createContext(a);function i(e){let n=o.useContext(d);return o.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:i(e.components),o.createElement(d.Provider,{value:n},e.children)}},547502(e){e.exports=JSON.parse('{"id":"frontend-system/building-apps/module-federation","title":"Module Federation","description":"Using Module Federation in Backstage","source":"@site/versioned_docs/version-stable/frontend-system/building-apps/07-module-federation.md","sourceDirName":"frontend-system/building-apps","slug":"/frontend-system/building-apps/module-federation","permalink":"/docs/frontend-system/building-apps/module-federation","draft":false,"unlisted":false,"editUrl":"https://github.com/backstage/backstage/edit/master/docs/frontend-system/building-apps/07-module-federation.md","tags":[],"version":"stable","sidebarPosition":7,"frontMatter":{"id":"module-federation","title":"Module Federation","sidebar_label":"Module Federation","description":"Using Module Federation in Backstage"},"sidebar":"docs","previous":{"title":"Converting 3rd-party Plugins","permalink":"/docs/frontend-system/building-apps/plugin-conversion"},"next":{"title":"Migration Guide","permalink":"/docs/frontend-system/building-apps/migrating"}}')}}]);