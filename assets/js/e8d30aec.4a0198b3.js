/*! For license information please see e8d30aec.4a0198b3.js.LICENSE.txt */
"use strict";(self.webpackChunkbackstage_microsite=self.webpackChunkbackstage_microsite||[]).push([[356014],{314607:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>c,contentTitle:()=>r,default:()=>p,frontMatter:()=>s,metadata:()=>a,toc:()=>d});var t=i(474848),o=i(28453);const s={id:"consuming",title:"Consuming Utility APIs",sidebar_label:"Consuming APIs",description:"Consuming utility APIs"},r=void 0,a={id:"frontend-system/utility-apis/consuming",title:"Consuming Utility APIs",description:"Consuming utility APIs",source:"@site/versioned_docs/version-stable/frontend-system/utility-apis/03-consuming.md",sourceDirName:"frontend-system/utility-apis",slug:"/frontend-system/utility-apis/consuming",permalink:"/docs/frontend-system/utility-apis/consuming",draft:!1,unlisted:!1,editUrl:"https://github.com/backstage/backstage/edit/master/docs/frontend-system/utility-apis/03-consuming.md",tags:[],version:"stable",sidebarPosition:3,frontMatter:{id:"consuming",title:"Consuming Utility APIs",sidebar_label:"Consuming APIs",description:"Consuming utility APIs"},sidebar:"docs",previous:{title:"Creating APIs",permalink:"/docs/frontend-system/utility-apis/creating"},next:{title:"Configuring",permalink:"/docs/frontend-system/utility-apis/configuring"}},c={},d=[{value:"Via React hooks",id:"via-react-hooks",level:2},{value:"Via dependencies",id:"via-dependencies",level:2}];function l(e){const n={code:"code",h2:"h2",p:"p",pre:"pre",...(0,o.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.p,{children:"All of the utility API extensions that were passed into your app through installed plugins, get instantiated and configured in the right order by the framework, and are then made available for consumption. You can interact with these instances in the following ways."}),"\n",(0,t.jsx)(n.h2,{id:"via-react-hooks",children:"Via React hooks"}),"\n",(0,t.jsxs)(n.p,{children:["The most common consumption pattern for utility APIs is to call the ",(0,t.jsx)(n.code,{children:"useApi"})," hook inside React components to get an implementation via its API ref. This applies whether it was originally provided from the core framework or from a plugin."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-tsx",children:"import { useApi, configApiRef } from '@backstage/frontend-plugin-api';\n\nconst MyComponent = () => {\n  const configApi = useApi(configApiRef);\n  const title = configApi.getString('app.title');\n  // ...\n};\n"})}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"useApi"})," hook always returns a value, or throws an exception if the API ref could not be resolved to a registered implementation. For advanced use cases, where you explicitly want to optionally request a utility API that may or may not have been provided at runtime, you can use the underlying ",(0,t.jsx)(n.code,{children:"useApiHolder"})," hook instead."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-tsx",children:"import { useApiHolder, configApiRef } from '@backstage/frontend-plugin-api';\n\nconst MyComponent = () => {\n  const apis = useApiHolder();\n  const configApi = apis.get(configApiRef); // may return undefined\n  if (configApi) {\n    const title = configApi.getString('app.title');\n    // ...\n  }\n};\n"})}),"\n",(0,t.jsx)(n.h2,{id:"via-dependencies",children:"Via dependencies"}),"\n",(0,t.jsxs)(n.p,{children:["Your utility APIs can depend on other utility APIs in their factories. You do this by declaring ",(0,t.jsx)(n.code,{children:"deps"})," on your ",(0,t.jsx)(n.code,{children:"createApiFactory"}),", and reading the outcome in your ",(0,t.jsx)(n.code,{children:"factory"}),"."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-tsx",children:"import {\n  configApiRef,\n  ApiBlueprint,\n  discoveryApiRef,\n} from '@backstage/frontend-plugin-api';\nimport { MyApiImpl } from './MyApiImpl';\n\nconst myApi = ApiBlueprint.make({\n  params: defineParams =>\n    defineParams({\n      api: myApiRef,\n      deps: {\n        configApi: configApiRef,\n        discoveryApi: discoveryApiRef,\n      },\n      factory: ({ configApi, discoveryApi }) => {\n        return new MyApiImpl({ configApi, discoveryApi });\n      },\n    }),\n});\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Note how the ",(0,t.jsx)(n.code,{children:"deps"})," section essentially assigns free-form names that you choose, to API refs. Here we for example map ",(0,t.jsx)(n.code,{children:"configApiRef"})," to the name ",(0,t.jsx)(n.code,{children:"configApi"}),", but that's just a convention. The framework will ensure that all of those deps get instantiated and passed into your ",(0,t.jsx)(n.code,{children:"factory"})," function with the same set of names as your ",(0,t.jsx)(n.code,{children:"deps"}),". At that point, ",(0,t.jsx)(n.code,{children:"configApi"})," refers to an actual functioning instance of that API ref."]})]})}function p(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(l,{...e})}):l(e)}},221020:(e,n,i)=>{var t=i(296540),o=Symbol.for("react.element"),s=Symbol.for("react.fragment"),r=Object.prototype.hasOwnProperty,a=t.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner,c={key:!0,ref:!0,__self:!0,__source:!0};function d(e,n,i){var t,s={},d=null,l=null;for(t in void 0!==i&&(d=""+i),void 0!==n.key&&(d=""+n.key),void 0!==n.ref&&(l=n.ref),n)r.call(n,t)&&!c.hasOwnProperty(t)&&(s[t]=n[t]);if(e&&e.defaultProps)for(t in n=e.defaultProps)void 0===s[t]&&(s[t]=n[t]);return{$$typeof:o,type:e,key:d,ref:l,props:s,_owner:a.current}}n.Fragment=s,n.jsx=d,n.jsxs=d},474848:(e,n,i)=>{e.exports=i(221020)},28453:(e,n,i)=>{i.d(n,{R:()=>r,x:()=>a});var t=i(296540);const o={},s=t.createContext(o);function r(e){const n=t.useContext(s);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:r(e.components),t.createElement(s.Provider,{value:n},e.children)}}}]);