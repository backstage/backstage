/*! For license information please see 46cb2ad6.b4eb3ced.js.LICENSE.txt */
"use strict";(self.webpackChunkbackstage_microsite=self.webpackChunkbackstage_microsite||[]).push([[862795],{524956:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>u,frontMatter:()=>o,metadata:()=>r,toc:()=>d});var i=t(474848),s=t(28453);const o={id:"index",title:"Building Backend Plugins and Modules",sidebar_label:"Overview",description:"Building backend plugins and modules using the new backend system"},a=void 0,r={id:"backend-system/building-plugins-and-modules/index",title:"Building Backend Plugins and Modules",description:"Building backend plugins and modules using the new backend system",source:"@site/../docs/backend-system/building-plugins-and-modules/01-index.md",sourceDirName:"backend-system/building-plugins-and-modules",slug:"/backend-system/building-plugins-and-modules/index",permalink:"/docs/next/backend-system/building-plugins-and-modules/index",draft:!1,unlisted:!1,editUrl:"https://github.com/backstage/backstage/edit/master/docs/backend-system/building-plugins-and-modules/01-index.md",tags:[],version:"current",sidebarPosition:1,frontMatter:{id:"index",title:"Building Backend Plugins and Modules",sidebar_label:"Overview",description:"Building backend plugins and modules using the new backend system"},sidebar:"docs",previous:{title:"Migration Guide",permalink:"/docs/next/backend-system/building-backends/migrating"},next:{title:"Testing",permalink:"/docs/next/backend-system/building-plugins-and-modules/testing"}},l={},d=[{value:"Creating a new Plugin",id:"creating-a-new-plugin",level:2},{value:"Plugins",id:"plugins",level:2},{value:"Modules",id:"modules",level:2},{value:"HTTP Handlers",id:"http-handlers",level:3},{value:"Database Access",id:"database-access",level:3},{value:"Customization",id:"customization",level:2},{value:"Extension Points",id:"extension-points",level:3},{value:"Configuration",id:"configuration",level:3}];function c(e){const n={a:"a",admonition:"admonition",code:"code",em:"em",h2:"h2",h3:"h3",p:"p",pre:"pre",...(0,s.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.admonition,{title:"Note",type:"note",children:(0,i.jsxs)(n.p,{children:["If you have an existing backend and/or backend plugins that are not yet\nusing the new backend system, see ",(0,i.jsx)(n.a,{href:"/docs/next/backend-system/building-plugins-and-modules/migrating",children:"migrating"}),"."]})}),"\n",(0,i.jsxs)(n.p,{children:["This section covers how to build your own backend ",(0,i.jsx)(n.a,{href:"/docs/next/backend-system/architecture/plugins",children:"plugins"})," and\n",(0,i.jsx)(n.a,{href:"/docs/next/backend-system/architecture/modules",children:"modules"}),". They are sometimes collectively referred to as\nbackend ",(0,i.jsx)(n.em,{children:"features"}),", and are the building blocks that adopters add to their\n",(0,i.jsx)(n.a,{href:"/docs/next/backend-system/architecture/backends",children:"backends"}),"."]}),"\n",(0,i.jsx)(n.h2,{id:"creating-a-new-plugin",children:"Creating a new Plugin"}),"\n",(0,i.jsxs)(n.p,{children:["This guide assumes that you already have a Backend project set up. Even if you only want to develop a single plugin for publishing, we still recommend that you do so in a standard Backstage monorepo project, as you often end up needing multiple packages. For instructions on how to set up a new project, see our ",(0,i.jsx)(n.a,{href:"/docs/next/getting-started/#prerequisites",children:"getting started"})," documentation."]}),"\n",(0,i.jsxs)(n.p,{children:["To create a Backend plugin, run ",(0,i.jsx)(n.code,{children:"yarn new"}),", select ",(0,i.jsx)(n.code,{children:"backend-plugin"}),", and fill out the rest of the prompts. This will create a new package at ",(0,i.jsx)(n.code,{children:"plugins/<pluginId>-backend"}),", which will be the main entrypoint for your plugin."]}),"\n",(0,i.jsx)(n.h2,{id:"plugins",children:"Plugins"}),"\n",(0,i.jsx)(n.p,{children:"A basic backend plugin might look as follows:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"// src/plugin.ts\nimport {\n  createBackendPlugin,\n  coreServices,\n} from '@backstage/backend-plugin-api';\nimport { createExampleRouter } from './router';\n\nexport const examplePlugin = createBackendPlugin({\n  pluginId: 'example',\n  register(env) {\n    env.registerInit({\n      deps: {\n        // Declare dependencies to services that you want to consume\n        logger: coreServices.logger,\n        httpRouter: coreServices.httpRouter,\n      },\n      async init({\n        // Requested service instances get injected as per above\n        logger,\n        httpRouter,\n      }) {\n        // Perform your initialization and access the services as needed\n        const example = createExampleRouter(logger);\n        logger.info('Hello from example plugin');\n        httpRouter.use(example);\n      },\n    });\n  },\n});\n\n// src/index.ts\nexport { examplePlugin as default } from './plugin';\n"})}),"\n",(0,i.jsxs)(n.p,{children:["When you depend on ",(0,i.jsx)(n.code,{children:"plugin"})," scoped services, you'll receive an instance of them\nthat's specific to your plugin. In the example above, the logger might tag\nmessages with your plugin ID, and the HTTP router might prefix API routes with\nyour plugin ID, depending on the implementation used."]}),"\n",(0,i.jsxs)(n.p,{children:["See ",(0,i.jsx)(n.a,{href:"/docs/next/backend-system/architecture/naming-patterns",children:"the article on naming patterns"})," for\ndetails on how to best choose names/IDs for plugins and related backend system\nitems."]}),"\n",(0,i.jsx)(n.h2,{id:"modules",children:"Modules"}),"\n",(0,i.jsxs)(n.p,{children:["Backend modules are used to extend ",(0,i.jsx)(n.a,{href:"/docs/next/backend-system/architecture/plugins",children:"plugins"})," or other modules with\nadditional features or change existing behavior. They must always be installed\nin the same backend instance as the plugin or module that they extend, and may only extend a single plugin and modules from that plugin at a time.\nModules interact with their target plugin or module using the ",(0,i.jsx)(n.a,{href:"/docs/next/backend-system/architecture/extension-points",children:"extension points"})," registered by the plugin, while also being\nable to depend on the ",(0,i.jsx)(n.a,{href:"/docs/next/backend-system/architecture/services",children:"services"})," of the target plugin.\nThat last point is worth reiterating: injected ",(0,i.jsx)(n.code,{children:"plugin"})," scoped services will be\nthe exact\nsame ones as the target plugin will receive later, i.e. they will be scoped\nusing the target ",(0,i.jsx)(n.code,{children:"pluginId"})," of the module."]}),"\n",(0,i.jsxs)(n.p,{children:["A module depends on the extension points exported by the target plugin's library\npackage, for example ",(0,i.jsx)(n.code,{children:"@backstage/plugin-catalog-node"}),", and does not directly\ndeclare a dependency on the plugin package itself. This is to avoid a direct\ndependency and potentially cause duplicate installations of the plugin package,\nwhile duplicate installations of library packages should always be supported.\nModules with extension points typically export their extension points from the same\npackage however, since the extension points are generally only intended for internal\ncustomizations where package versions can be kept in sync."]}),"\n",(0,i.jsxs)(n.p,{children:["To create a Backend module, run ",(0,i.jsx)(n.code,{children:"yarn new"}),", select ",(0,i.jsx)(n.code,{children:"backend-module"}),", and fill out the rest of the prompts. This will create a new package at ",(0,i.jsx)(n.code,{children:"plugins/<pluginId>-backend-module-<moduleId>"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["The following is an example of how to create a module that adds a new processor\nusing the ",(0,i.jsx)(n.code,{children:"catalogProcessingExtensionPoint"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"// src/module.ts\nimport { createBackendModule } from '@backstage/backend-plugin-api';\nimport { catalogProcessingExtensionPoint } from '@backstage/plugin-catalog-node';\nimport { MyCustomProcessor } from './MyCustomProcessor';\n\nexport const catalogModuleExampleCustomProcessor = createBackendModule({\n  pluginId: 'catalog',\n  moduleId: 'example-custom-processor',\n  register(env) {\n    env.registerInit({\n      deps: {\n        catalog: catalogProcessingExtensionPoint,\n        logger: coreServices.logger,\n      },\n      async init({ catalog }) {\n        catalog.addProcessor(new MyCustomProcessor(logger));\n      },\n    });\n  },\n});\n\n// src/index.ts\nexport { catalogModuleExampleCustomProcessor as default } from './module';\n"})}),"\n",(0,i.jsxs)(n.p,{children:["See ",(0,i.jsx)(n.a,{href:"/docs/next/backend-system/architecture/naming-patterns",children:"the article on naming patterns"})," for\ndetails on how to best choose names/IDs for modules and related backend system\nitems."]}),"\n",(0,i.jsxs)(n.p,{children:["Notice that we're placing the extension point we want to interact with in the\n",(0,i.jsx)(n.code,{children:"deps"})," option, while also depending on the logger service at the same time. When\ninitializing modules we can depend on both extension points and services\ninterchangeably. You can also depend on multiple extension points at once, in\ncase the implementation of the module requires it."]}),"\n",(0,i.jsx)(n.p,{children:"Each module package should only contain a single module, but this module may\nextend multiple extension points. A module may also use configuration to\nconditionally enable or disable certain extensions. This pattern should only be\nused for extensions that are related to each other, otherwise it is best to\ncreate a separate module package with its own module."}),"\n",(0,i.jsx)(n.h3,{id:"http-handlers",children:"HTTP Handlers"}),"\n",(0,i.jsxs)(n.p,{children:["Since modules have access to the same services as the plugin they extend, they\nare also able to register their own HTTP handlers. For more information about\nthe HTTP service, see ",(0,i.jsx)(n.a,{href:"/docs/next/backend-system/core-services/index",children:"core services"}),". When\nregistering HTTP handlers, it is important to try to avoid any future conflict\nwith the plugin itself, or other modules. A recommended naming pattern is to\nregister the handlers under the ",(0,i.jsx)(n.code,{children:"/modules/<module-id>"})," path, where ",(0,i.jsx)(n.code,{children:"<module-id>"}),"\nis the kebab-case ID of the module, for example\n",(0,i.jsx)(n.code,{children:"/modules/example-custom-processor/v1/validators"}),". In a standard backend setup\nthe full path would then be\n",(0,i.jsx)(n.code,{children:"<backendUrl>/api/catalog/modules/example-custom-processor/v1/validators"}),"."]}),"\n",(0,i.jsx)(n.h3,{id:"database-access",children:"Database Access"}),"\n",(0,i.jsxs)(n.p,{children:["The same applies for modules that perform their own migrations and interact with\nthe database. They will run on the same logical database instance as the target\nplugin, so care must be taken to choose table names that do not risk colliding\nwith those of the plugin. A recommended naming pattern is ",(0,i.jsx)(n.code,{children:"<package name>__<table name>"}),", for example the scheduler core service creates tables named ",(0,i.jsx)(n.code,{children:"backstage_backend_tasks__<table>"}),", because it used to be the case that the service lived in a package named ",(0,i.jsx)(n.code,{children:"@backstage/backend-tasks"}),". Things have since moved around a bit, but the effects of the rule are still visible. If you use the default ",(0,i.jsxs)(n.a,{href:"https://knexjs.org/guide/migrations.html",children:[(0,i.jsx)(n.code,{children:"Knex"})," migration facilities"]}),", you will also\nwant to make sure that it uses similarly prefixed migration state tables for its\ninternal bookkeeping needs, so they do not collide with the main ones used by\nthe plugin itself. You can do this as follows:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"await knex.migrate.latest({\n  directory: migrationsDir,\n  tableName: 'backstage_backend_tasks__knex_migrations',\n});\n"})}),"\n",(0,i.jsx)(n.h2,{id:"customization",children:"Customization"}),"\n",(0,i.jsx)(n.p,{children:"There are several ways of configuring and customizing plugins and modules."}),"\n",(0,i.jsx)(n.h3,{id:"extension-points",children:"Extension Points"}),"\n",(0,i.jsxs)(n.p,{children:["Whenever you want to allow modules to configure your plugin dynamically, for\nexample in the way that the catalog backend lets catalog modules inject\nadditional entity providers, you can use the extension points mechanism. This is\ndescribed in detail with code examples in ",(0,i.jsx)(n.a,{href:"/docs/next/backend-system/architecture/extension-points",children:"the extension points architecture article"}),", while the following is a more\nslim example of how to implement an extension point for a plugin:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"import { createExtensionPoint } from '@backstage/backend-plugin-api';\n\n// This is the extension point interface, which is how modules interact with your plugin.\nexport interface ExamplesExtensionPoint {\n  addExample(example: Example): void;\n}\n\n// This is the extension point reference that encapsulates the above interface.\nexport const examplesExtensionPoint =\n  createExtensionPoint<ExamplesExtensionPoint>({\n    id: 'example.examples',\n  });\n\n// The following shows how your plugin would register the extension point\n// and use the features that other modules have registered.\nexport const examplePlugin = createBackendPlugin({\n  pluginId: 'example',\n  register(env) {\n    // We can share data between the extension point implementation and our init method.\n    const examples = new Array<Example>();\n\n    // This registers the implementation of the extension point, which is internal to your plugin.\n    env.registerExtensionPoint(examplesExtensionPoint, {\n      addExample(example) {\n        examples.push(example);\n      },\n    });\n\n    env.registerInit({\n      deps: { logger: coreServices.logger },\n      async init({ logger }) {\n        // We can access `examples` directly\n        logger.info(`The following examples have been registered: ${examples}`);\n      },\n    });\n  },\n});\n"})}),"\n",(0,i.jsx)(n.p,{children:"This is a very common type of extension point, one where modules are given the opportunity to register features to be used by the plugin. In this case modules are able to register examples that are then used by our examples plugin."}),"\n",(0,i.jsx)(n.h3,{id:"configuration",children:"Configuration"}),"\n",(0,i.jsxs)(n.p,{children:["Your plugin or module can leverage the app configuration to configure its own\ninternal behavior. You do this by adding a dependency on ",(0,i.jsx)(n.code,{children:"coreServices.rootConfig"}),"\nand reading from that. This pattern is a good fit especially for customization\nthat needs to be different across environments."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"import { coreServices } from '@backstage/backend-plugin-api';\n\nexport const examplePlugin = createBackendPlugin({\n  pluginId: 'example',\n  register(env) {\n    env.registerInit({\n      deps: { config: coreServices.rootConfig },\n      async init({ config }) {\n        // Here you can read from the current config as you see fit, e.g.:\n        const value = config.getOptionalString('example.value');\n      },\n    });\n  },\n});\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Before adding custom configuration options, make sure to read ",(0,i.jsx)(n.a,{href:"/docs/next/conf/",children:"the configuration docs"}),", in particular the section on ",(0,i.jsx)(n.a,{href:"/docs/next/conf/defining",children:"defining configuration for your own plugins"})," which explains how to establish a\nconfiguration schema for your specific plugin."]})]})}function u(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}},221020:(e,n,t)=>{var i=t(296540),s=Symbol.for("react.element"),o=Symbol.for("react.fragment"),a=Object.prototype.hasOwnProperty,r=i.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner,l={key:!0,ref:!0,__self:!0,__source:!0};function d(e,n,t){var i,o={},d=null,c=null;for(i in void 0!==t&&(d=""+t),void 0!==n.key&&(d=""+n.key),void 0!==n.ref&&(c=n.ref),n)a.call(n,i)&&!l.hasOwnProperty(i)&&(o[i]=n[i]);if(e&&e.defaultProps)for(i in n=e.defaultProps)void 0===o[i]&&(o[i]=n[i]);return{$$typeof:s,type:e,key:d,ref:c,props:o,_owner:r.current}}n.Fragment=o,n.jsx=d,n.jsxs=d},474848:(e,n,t)=>{e.exports=t(221020)},28453:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>r});var i=t(296540);const s={},o=i.createContext(s);function a(e){const n=i.useContext(o);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),i.createElement(o.Provider,{value:n},e.children)}}}]);