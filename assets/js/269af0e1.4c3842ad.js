/*! For license information please see 269af0e1.4c3842ad.js.LICENSE.txt */
"use strict";(self.webpackChunkbackstage_microsite=self.webpackChunkbackstage_microsite||[]).push([[895425],{711494:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>a,default:()=>h,frontMatter:()=>o,metadata:()=>r,toc:()=>c});var s=t(474848),i=t(28453);const o={id:"build-system",title:"Build System",description:"A deep dive into the Backstage build system"},a=void 0,r={id:"tooling/cli/build-system",title:"Build System",description:"A deep dive into the Backstage build system",source:"@site/../docs/tooling/cli/02-build-system.md",sourceDirName:"tooling/cli",slug:"/tooling/cli/build-system",permalink:"/docs/next/tooling/cli/build-system",draft:!1,unlisted:!1,editUrl:"https://github.com/backstage/backstage/edit/master/docs/tooling/cli/02-build-system.md",tags:[],version:"current",sidebarPosition:2,frontMatter:{id:"build-system",title:"Build System",description:"A deep dive into the Backstage build system"},sidebar:"docs",previous:{title:"Overview",permalink:"/docs/next/tooling/cli/overview"},next:{title:"Commands",permalink:"/docs/next/tooling/cli/commands"}},d={},c=[{value:"Design Considerations",id:"design-considerations",level:2},{value:"Structure",id:"structure",level:2},{value:"Package Roles",id:"package-roles",level:2},{value:"Formatting",id:"formatting",level:2},{value:"Linting",id:"linting",level:2},{value:"Type Checking",id:"type-checking",level:2},{value:"Testing",id:"testing",level:2},{value:"Building",id:"building",level:2},{value:"Bundling",id:"bundling",level:2},{value:"Frontend Development",id:"frontend-development",level:3},{value:"Frontend Production",id:"frontend-production",level:3},{value:"Backend Development",id:"backend-development",level:3},{value:"Backend Production",id:"backend-production",level:3},{value:"Transpilation",id:"transpilation",level:2},{value:"Loaders",id:"loaders",level:2},{value:"ECMAScript Modules",id:"ecmascript-modules",level:2},{value:"Jest Configuration",id:"jest-configuration",level:2},{value:"Additional Configuration Options",id:"additional-configuration-options",level:3},{value:"<code>rejectFrontendNetworkRequests</code> <strong>[boolean]</strong>",id:"rejectfrontendnetworkrequests-boolean",level:4},{value:"Caching",id:"caching",level:2},{value:"Debugging Jest Tests",id:"debugging-jest-tests",level:3},{value:"IntelliJ IDEA",id:"intellij-idea",level:4},{value:"VS Code",id:"vs-code",level:4},{value:"Publishing",id:"publishing",level:2},{value:"Subpath Exports",id:"subpath-exports",level:2}];function l(e){const n={a:"a",blockquote:"blockquote",code:"code",h2:"h2",h3:"h3",h4:"h4",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.p,{children:"The Backstage build system is a collection of build and development tools that\nhelp you lint, test, develop and finally release your Backstage projects. The\npurpose of the build system is to provide an out-of-the-box solution that works\nwell with Backstage and lets you focus on building an app rather than having to\nspend time setting up your own tooling."}),"\n",(0,s.jsxs)(n.p,{children:["The build system setup is part of the\n",(0,s.jsx)(n.a,{href:"https://www.npmjs.com/package/@backstage/cli",children:"@backstage/cli"}),", and already\nincluded in any project that you create using\n",(0,s.jsx)(n.a,{href:"https://www.npmjs.com/package/@backstage/create-app",children:"@backstage/create-app"}),". It\nis similar to for example\n",(0,s.jsx)(n.a,{href:"https://www.npmjs.com/package/react-scripts",children:"react-scripts"}),", which is the\ntooling you get with\n",(0,s.jsx)(n.a,{href:"https://github.com/facebook/create-react-app",children:"create-react-app"}),". The Backstage\nbuild system relies heavily on existing open source tools from the JavaScript\nand TypeScript ecosystem, such as ",(0,s.jsx)(n.a,{href:"https://webpack.js.org/",children:"Webpack"}),",\n",(0,s.jsx)(n.a,{href:"https://rollupjs.org/",children:"Rollup"}),", ",(0,s.jsx)(n.a,{href:"https://jestjs.io/",children:"Jest"}),", and\n",(0,s.jsx)(n.a,{href:"https://eslint.org/",children:"ESLint"}),"."]}),"\n",(0,s.jsx)(n.h2,{id:"design-considerations",children:"Design Considerations"}),"\n",(0,s.jsx)(n.p,{children:"There are a couple of core beliefs and constraints that guided the design of the\nBackstage build system. The first and most important is that we put the\ndevelopment experience first. If we need to cut corners or add complexity we do\nso in other areas, but the experience of firing up an editor and iterating on\nsome code should always be as smooth as possible."}),"\n",(0,s.jsx)(n.p,{children:"In addition, there are a number of hard and soft requirements:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Monorepos - The build system should support multi-package workspaces"}),"\n",(0,s.jsx)(n.li,{children:"Publishing - It should be possible to build and publish individual packages"}),"\n",(0,s.jsx)(n.li,{children:"Scale - It should scale to hundreds of large packages without excessive wait\ntimes"}),"\n",(0,s.jsx)(n.li,{children:"Reloads - The development flow should support quick on-save hot reloads"}),"\n",(0,s.jsx)(n.li,{children:"Simple - Usage should be simple and configuration should be kept minimal"}),"\n",(0,s.jsx)(n.li,{children:"Universal - Development towards both web applications, isomorphic packages,\nand Node.js"}),"\n",(0,s.jsx)(n.li,{children:"Modern - The build system targets modern environments"}),"\n",(0,s.jsx)(n.li,{children:"Editors - Type checking and linting should be available within most editors"}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["During the design of the build system this collection of requirements was not\nsomething that was supported by existing tools like for example ",(0,s.jsx)(n.code,{children:"react-scripts"}),".\nThe requirements of scaling in combination of monorepo, publishing, and editor\nsupport led us to adopting our own specialized setup."]}),"\n",(0,s.jsx)(n.h2,{id:"structure",children:"Structure"}),"\n",(0,s.jsx)(n.p,{children:"We can divide the development flow within Backstage into a couple of different\nsteps:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Formatting"})," - Applies a consistent formatting to your source code"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Linting"})," - Analyzes your source code for potential problems"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Type Checking"})," - Verifies that TypeScript types are valid"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Testing"})," - Runs different levels of test suites towards your project"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Building"})," - Compiles the source code in an individual package"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Bundling"})," - Combines a package and all of its dependencies into a\nproduction-ready bundle"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"These steps are generally kept isolated from each other, with each step focusing\non its specific task. For example, we do not do linting or type checking\ntogether with the building or bundling. This is so that we can provide more\nflexibility and avoid duplicate work, improving performance. It is strongly\nrecommended that as a part of developing within Backstage you use a code editor\nor IDE that has support for formatting, linting, and type checking."}),"\n",(0,s.jsx)(n.p,{children:"Let's dive into a detailed look at each of these steps and how they are\nimplemented in a typical Backstage app."}),"\n",(0,s.jsx)(n.h2,{id:"package-roles",children:"Package Roles"}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:["Package roles were introduced in March 2022. To migrate existing projects, see the ",(0,s.jsx)(n.a,{href:"/docs/next/tutorials/package-role-migration",children:"migration guide"}),"."]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["The Backstage build system uses the concept of package roles in order to help keep\nconfiguration lean, provide utility and tooling, and enable optimizations. A package\nrole is a single string that identifies what the purpose of a package is, and it's\ndefined in the ",(0,s.jsx)(n.code,{children:"package.json"})," of each package like this:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-json",children:'{\n  "name": "my-package",\n  "backstage": {\n    "role": "<role>"\n  },\n  ...\n}\n'})}),"\n",(0,s.jsx)(n.p,{children:"These are the available roles that are currently supported by the Backstage build system:"}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Role"}),(0,s.jsx)(n.th,{children:"Description"}),(0,s.jsx)(n.th,{children:"Example"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"frontend"}),(0,s.jsx)(n.td,{children:"Bundled frontend application"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"packages/app"})})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"backend"}),(0,s.jsx)(n.td,{children:"Bundled backend application"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"packages/backend"})})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"cli"}),(0,s.jsx)(n.td,{children:"Package used as a command-line interface"}),(0,s.jsxs)(n.td,{children:[(0,s.jsx)(n.code,{children:"@backstage/cli"}),", ",(0,s.jsx)(n.code,{children:"@backstage/codemods"})]})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"web-library"}),(0,s.jsx)(n.td,{children:"Web library for use by other packages"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"@backstage/plugin-catalog-react"})})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"node-library"}),(0,s.jsx)(n.td,{children:"Node.js library for use by other packages"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"@backstage/plugin-techdocs-node"})})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"common-library"}),(0,s.jsx)(n.td,{children:"Isomorphic library for use by other packages"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"@backstage/plugin-permission-common"})})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"frontend-plugin"}),(0,s.jsx)(n.td,{children:"Backstage frontend plugin"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"@backstage/plugin-scaffolder"})})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"frontend-plugin-module"}),(0,s.jsx)(n.td,{children:"Backstage frontend plugin module"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"@backstage/plugin-analytics-module-ga"})})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"backend-plugin"}),(0,s.jsx)(n.td,{children:"Backstage backend plugin"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"@backstage/plugin-auth-backend"})})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"backend-plugin-module"}),(0,s.jsx)(n.td,{children:"Backstage backend plugin module"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"@backstage/plugin-search-backend-module-pg"})})]})]})]}),"\n",(0,s.jsxs)(n.p,{children:["Most of the steps that we cover below have an accompanying command that is intended to be used as a package script. The commands are all available under the ",(0,s.jsx)(n.code,{children:"backstage-cli package"})," category, and many of the commands will behave differently depending on the role of the package. The commands are intended to be used like this:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-json",children:'{\n  "scripts": {\n    "start": "backstage-cli package start",\n    "build": "backstage-cli package build",\n    "lint": "backstage-cli package lint",\n    ...\n  }\n}\n'})}),"\n",(0,s.jsx)(n.h2,{id:"formatting",children:"Formatting"}),"\n",(0,s.jsxs)(n.p,{children:["The formatting setup lives completely within each Backstage application and is\nnot part of the CLI. In an app created with ",(0,s.jsx)(n.code,{children:"@backstage/create-app"})," the\nformatting is handled by ",(0,s.jsx)(n.a,{href:"https://prettier.io/",children:"prettier"}),", but each application\ncan choose their own formatting rules and switch to a different formatter if\ndesired."]}),"\n",(0,s.jsx)(n.h2,{id:"linting",children:"Linting"}),"\n",(0,s.jsxs)(n.p,{children:["The Backstage CLI includes a ",(0,s.jsx)(n.code,{children:"lint"})," command, which is a thin wrapper around\n",(0,s.jsx)(n.code,{children:"eslint"}),". It adds a few options that can't be set through configuration, such as\nincluding the ",(0,s.jsx)(n.code,{children:".ts"})," and ",(0,s.jsx)(n.code,{children:".tsx"})," extensions in the set of linted files. The ",(0,s.jsx)(n.code,{children:"lint"}),"\ncommand simply provides a sane default and is not intended to be customizable.\nIf you want to supply more advanced options you can invoke ",(0,s.jsx)(n.code,{children:"eslint"})," directly\ninstead."]}),"\n",(0,s.jsxs)(n.p,{children:["In addition to the ",(0,s.jsx)(n.code,{children:"lint"})," command, the Backstage CLI also includes a set of base\nESLint configurations, one for frontend and one for backend packages. These lint\nconfigurations in turn build on top of the lint rules from\n",(0,s.jsx)(n.a,{href:"https://github.com/spotify/web-scripts",children:"@spotify/web-scripts"}),"."]}),"\n",(0,s.jsx)(n.p,{children:"In a standard Backstage setup, each individual package has its own lint\nconfiguration, along with a root configuration that applies to the entire\nproject. The configuration in each package starts out as a standard configuration\nthat is determined based on the package role, but it can be customized to fit the needs of each package."}),"\n",(0,s.jsxs)(n.p,{children:["A minimal ",(0,s.jsx)(n.code,{children:".eslintrc.js"})," configuration now looks like this:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"module.exports = require('@backstage/cli/config/eslint-factory')(__dirname);\n"})}),"\n",(0,s.jsx)(n.p,{children:"But you can provide custom overrides for each package using the optional second argument:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"module.exports = require('@backstage/cli/config/eslint-factory')(__dirname, {\n  ignorePatterns: ['templates/'],\n  rules: {\n    'jest/expect-expect': 'off',\n  },\n});\n"})}),"\n",(0,s.jsxs)(n.p,{children:["The configuration factory also provides utilities for extending the configuration in ways that are otherwise very cumbersome to do with plain ESLint, particularly for rules like ",(0,s.jsx)(n.code,{children:"no-restricted-syntax"}),". These are the extra keys that are available:"]}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Key"}),(0,s.jsx)(n.th,{children:"Description"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"tsRules"})}),(0,s.jsx)(n.td,{children:"Additional rules to apply to TypeScript files"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"testRules"})}),(0,s.jsx)(n.td,{children:"Additional rules to apply to tests files"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"restrictedImports"})}),(0,s.jsxs)(n.td,{children:["Additional paths to add to ",(0,s.jsx)(n.code,{children:"no-restricted-imports"})]})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"restrictedImportPatterns"})}),(0,s.jsxs)(n.td,{children:["Additional patterns to add to ",(0,s.jsx)(n.code,{children:"no-restricted-imports"})]})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"restrictedSrcImports"})}),(0,s.jsxs)(n.td,{children:["Additional paths to add to ",(0,s.jsx)(n.code,{children:"no-restricted-imports"})," in src files"]})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"restrictedTestImports"})}),(0,s.jsxs)(n.td,{children:["Additional paths to add to ",(0,s.jsx)(n.code,{children:"no-restricted-imports"})," in test files"]})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"restrictedSyntax"})}),(0,s.jsxs)(n.td,{children:["Additional patterns to add to ",(0,s.jsx)(n.code,{children:"no-restricted-syntax"})]})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"restrictedSrcSyntax"})}),(0,s.jsxs)(n.td,{children:["Additional patterns to add to ",(0,s.jsx)(n.code,{children:"no-restricted-syntax"})," in src files"]})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"restrictedTestSyntax"})}),(0,s.jsxs)(n.td,{children:["Additional patterns to add to ",(0,s.jsx)(n.code,{children:"no-restricted-syntax"})," in test files"]})]})]})]}),"\n",(0,s.jsx)(n.h2,{id:"type-checking",children:"Type Checking"}),"\n",(0,s.jsx)(n.p,{children:"Just like formatting, the Backstage CLI does not have its own command for type\nchecking. It does however have a base configuration with both recommended\ndefaults as well as some required settings for the build system to work."}),"\n",(0,s.jsxs)(n.p,{children:["Perhaps the most notable part about the TypeScript setup in Backstage projects\nis that the entire project is one big compilation unit. This is due to\nperformance optimization as well as ease of use, since breaking projects down\ninto smaller pieces has proven to both lead to a more complicated setup, as well\nas type checking of the entire project being an order of magnitude slower. In\norder to make this setup work, the entrypoint of each package needs to point to\nthe TypeScript source files, which in turn causes some complications during\npublishing that we'll talk about in ",(0,s.jsx)(n.a,{href:"#publishing",children:"that section"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["The type checking is generally configured to be incremental for local\ndevelopment, with the output stored in the ",(0,s.jsx)(n.code,{children:"dist-types"})," folder in the repo root.\nThis provides a significant speedup when running ",(0,s.jsx)(n.code,{children:"tsc"})," multiple times locally,\nbut it does make the initial run a little bit slower. Because of the slower\ninitial run we disable incremental type checking in the ",(0,s.jsx)(n.code,{children:"tcs:full"})," Yarn script\nthat is included by default in any Backstage app and is intended for use in CI."]}),"\n",(0,s.jsxs)(n.p,{children:["Another optimization that is used by default is to skip the checking of library\ntypes, this means that TypeScript will not verify that types within\n",(0,s.jsx)(n.code,{children:"node_modules"})," are sound. Disabling this check significantly speeds up type\nchecking, but in the end it is still an important check that should not be\ncompletely omitted, it's simply unlikely to catch issues that are introduced\nduring local development. What we opt for instead is to include the check in CI\nthrough the ",(0,s.jsx)(n.code,{children:"tsc:full"})," script, which will run a full type check, including\n",(0,s.jsx)(n.code,{children:"node_modules"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["For the two reasons mentioned above, it is ",(0,s.jsx)(n.strong,{children:"highly"})," recommended to use the\n",(0,s.jsx)(n.code,{children:"tsc:full"})," script to run type checking in CI."]}),"\n",(0,s.jsx)(n.h2,{id:"testing",children:"Testing"}),"\n",(0,s.jsxs)(n.p,{children:["As mentioned above, the Backstage CLI uses ",(0,s.jsx)(n.a,{href:"https://jestjs.io/",children:"Jest"}),", which is\na JavaScript test framework that covers both test execution and assertions. Jest\nexecutes all tests in Node.js, including frontend browser code. The trick it\nuses is to execute the tests in a Node.js VM using various predefined\nenvironments, such as one based on ",(0,s.jsx)(n.a,{href:"https://github.com/jsdom/jsdom",children:(0,s.jsx)(n.code,{children:"jsdom"})}),"\nthat helps mimic browser APIs and behavior."]}),"\n",(0,s.jsxs)(n.p,{children:["The Backstage CLI has its own command that helps execute tests,\n",(0,s.jsx)(n.code,{children:"backstage-cli test"}),", as well as its own configuration at\n",(0,s.jsx)(n.code,{children:"@backstage/cli/config/jest.js"}),". The command is a relatively thin wrapper around\nrunning ",(0,s.jsx)(n.code,{children:"jest"})," directly. Its main responsibility is to make sure the included\nconfiguration is used, as well setting the ",(0,s.jsx)(n.code,{children:"NODE_ENV"})," and ",(0,s.jsx)(n.code,{children:"TZ"})," environment\nvariables, and provided some sane default flags like ",(0,s.jsx)(n.code,{children:"--watch"})," if executed\nwithin a Git repository."]}),"\n",(0,s.jsxs)(n.p,{children:["The by far biggest amount of work is done by the Jest configuration included\nwith the Backstage CLI. It both takes care of providing a default Jest\nconfiguration, as well as allowing for configuration overrides to be defined in\neach ",(0,s.jsx)(n.code,{children:"package.json"}),". How this can be done in practice is discussed in the\n",(0,s.jsx)(n.a,{href:"#jest-configuration",children:"Jest configuration"})," section."]}),"\n",(0,s.jsx)(n.h2,{id:"building",children:"Building"}),"\n",(0,s.jsx)(n.p,{children:"The primary purpose of the build process is to prepare packages for publishing,\nbut it's also used as part of the backend bundling process. Since it's only used\nin these two cases, any Backstage app that does not use the Backend parts of the\nproject may not need to interact with the build process at all. It can\nnevertheless be useful to know how it works, since all of the published\nBackstage packages are built using this process."}),"\n",(0,s.jsxs)(n.p,{children:["The build is currently using ",(0,s.jsx)(n.a,{href:"https://rollupjs.org/",children:"Rollup"})," and executes in\nisolation for each individual package. The build is invoked using the ",(0,s.jsx)(n.code,{children:"package build"}),"\ncommand, and applies to all packages roles except the bundled ones, ",(0,s.jsx)(n.code,{children:"frontend"})," and ",(0,s.jsx)(n.code,{children:"backend"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["There are three different possible outputs of the build process: JavaScript in\nCommonJS module format, JavaScript in ECMAScript module format, and type\ndeclarations. Each invocation of a build command will write one or more of these\noutputs to the ",(0,s.jsx)(n.code,{children:"dist"})," folder in the package, and in addition copy any asset\nfiles like stylesheets or images. For more details on what syntax and file\nformats are supported by the build process, see the ",(0,s.jsx)(n.a,{href:"#loaders",children:"loaders section"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["When building CommonJS or ESM output, the build commands will always use\n",(0,s.jsx)(n.code,{children:"src/index.ts"})," as the entrypoint. All non-relative modules imports are considered\nexternal, meaning the Rollup build will only compile the source code of the package\nitself. All import statements of external dependencies, even within the same\n",(0,s.jsx)(n.a,{href:"/docs/next/references/glossary#monorepo",children:"monorepo"}),", will stay intact."]}),"\n",(0,s.jsxs)(n.p,{children:["The build of the type definitions works quite differently. The entrypoint of the\ntype definition build is the relative location of the package within the\n",(0,s.jsx)(n.code,{children:"dist-types"})," folder in the project root. This means that it is important to run\ntype checking before building any packages with type definitions, and that\nemitting type declarations must be enabled in the TypeScript configuration. The\nreason for the type definition build step is to strip out all types but the ones\nthat are exported from the package, leaving a much cleaner type definition file\nand making sure that the type definitions are in sync with the generated\nJavaScript."]}),"\n",(0,s.jsx)(n.h2,{id:"bundling",children:"Bundling"}),"\n",(0,s.jsx)(n.p,{children:"The goal of the bundling process is to combine multiple packages together into a\nsingle runtime unit. The way this is done varies between frontend and backend,\nas well as local development versus production deployment. Because of that we\ncover each combination of these cases separately."}),"\n",(0,s.jsx)(n.h3,{id:"frontend-development",children:"Frontend Development"}),"\n",(0,s.jsxs)(n.p,{children:["The frontend development setup is used for all packages with a frontend role, and\nis invoked using the ",(0,s.jsx)(n.code,{children:"package start"})," command.\nThe only difference between the different roles is that packages with the ",(0,s.jsx)(n.code,{children:"'frontend'"}),"\nrole use ",(0,s.jsx)(n.code,{children:"src/index"})," as the entrypoint, while other roles instead use ",(0,s.jsx)(n.code,{children:"dev/index"}),".\nWhen running the start command, a development server\nwill be set up that listens to the protocol, host and port set by ",(0,s.jsx)(n.code,{children:"app.baseUrl"}),"\nin the configuration. If needed it is also possible to override the listening\noptions through the ",(0,s.jsx)(n.code,{children:"app.listen"})," configuration."]}),"\n",(0,s.jsxs)(n.p,{children:["The frontend development bundling is currently based on\n",(0,s.jsx)(n.a,{href:"https://webpack.js.org/",children:"Webpack"})," and\n",(0,s.jsx)(n.a,{href:"https://webpack.js.org/configuration/dev-server/",children:"Webpack Dev Server"}),". The\nWebpack configuration itself varies very little between the frontend development\nand production bundling, so we'll dive more into the configuration in the\nproduction section below. The main differences are that ",(0,s.jsx)(n.code,{children:"process.env.NODE_ENV"}),"\nis set to ",(0,s.jsx)(n.code,{children:"'development'"}),", minification is disabled, cheap source maps are used,\nand ",(0,s.jsx)(n.a,{href:"https://github.com/pmmmwh/react-refresh-webpack-plugin#readme",children:"React Refresh"}),"\nis enabled."]}),"\n",(0,s.jsxs)(n.p,{children:["If you prefer to run type checking and linting as part of the Webpack process,\nyou can enable usage of the\n",(0,s.jsx)(n.a,{href:"https://www.npmjs.com/package/fork-ts-checker-webpack-plugin",children:(0,s.jsx)(n.code,{children:"ForkTsCheckerWebpackPlugin"})}),"\nby passing the ",(0,s.jsx)(n.code,{children:"--check"})," flag. Although as mentioned above, the recommended way\nto handle these checks during development is to use an editor that has built-in\nsupport for them instead."]}),"\n",(0,s.jsx)(n.h3,{id:"frontend-production",children:"Frontend Production"}),"\n",(0,s.jsxs)(n.p,{children:["The frontend production bundling creates your typical web content\n",(0,s.jsx)(n.a,{href:"/docs/next/references/glossary#bundle",children:"bundle"}),", all contained within a single\nfolder, ready for static serving. It is used when building packages with the\n",(0,s.jsx)(n.code,{children:"'frontend'"})," role, and unlike the development bundling there is no way to\nbuild a production bundle of an individual plugin.\nThe output of the bundling process is written to the ",(0,s.jsx)(n.code,{children:"dist"})," folder in the package."]}),"\n",(0,s.jsxs)(n.p,{children:["Just like the development bundling, the production bundling is based on\n",(0,s.jsx)(n.a,{href:"https://webpack.js.org/",children:"Webpack"}),". It uses the\n",(0,s.jsx)(n.a,{href:"https://webpack.js.org/plugins/html-webpack-plugin/",children:(0,s.jsx)(n.code,{children:"HtmlWebpackPlugin"})})," to\ngenerate the ",(0,s.jsx)(n.code,{children:"index.html"})," entry point, and includes a default template that's\nincluded with the CLI. You can replace the bundled template by adding\n",(0,s.jsx)(n.code,{children:"public/index.html"})," to your app package. The template has access to two global\nconstants, ",(0,s.jsx)(n.code,{children:"publicPath"})," which is the public base path that the bundle is\nintended to be served at, as well as ",(0,s.jsx)(n.code,{children:"config"})," which is your regular frontend\nscoped configuration from ",(0,s.jsx)(n.code,{children:"@backstage/config"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["The Webpack configuration also includes a custom plugin for resolving packages\ncorrectly from linked in packages, the ",(0,s.jsx)(n.code,{children:"ModuleScopePlugin"})," from\n",(0,s.jsx)(n.a,{href:"https://www.npmjs.com/package/react-dev-utils",children:(0,s.jsx)(n.code,{children:"react-dev-utils"})})," which makes\nsure that imports don't reach outside the package, a few fallbacks for some\nNode.js modules like ",(0,s.jsx)(n.code,{children:"'buffer'"})," and ",(0,s.jsx)(n.code,{children:"'events'"}),", a plugin that writes the\nfrontend configuration to the bundle as ",(0,s.jsx)(n.code,{children:"process.env.APP_CONFIG"}),", and lastly minification handled by\n",(0,s.jsx)(n.a,{href:"https://esbuild.github.io/",children:"esbuild"})," using the\n",(0,s.jsx)(n.a,{href:"https://npm.im/esbuild-loader",children:(0,s.jsx)(n.code,{children:"esbuild-loader"})}),". There are of course also a\nset of loaders configured, which you can read more about in the\n",(0,s.jsx)(n.a,{href:"#loaders",children:"loaders"})," and ",(0,s.jsx)(n.a,{href:"#transpilation",children:"transpilation"})," sections."]}),"\n",(0,s.jsx)(n.p,{children:"During the build, the following constants are also set:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:"process.env.NODE_ENV = 'production';\nprocess.env.BUILD_INFO = {\n  cliVersion: '0.4.0', // The version of the CLI package\n  gitVersion: 'v0.4.0-86-ge54815618', // output of `git describe --always`\n  packageVersion: '1.0.5', // The version of the app package itself\n  timestamp: 1678900000000, // Date.now() when the build started\n  commit: 'e548156182a973ed4b459e18533afc22c85ffff8', // output of `git rev-parse HEAD`\n};\n"})}),"\n",(0,s.jsxs)(n.p,{children:["The output of the bundling process is split into two categories of files with\nseparate caching strategies. The first is a set of generic assets with plain\nnames in the root of the ",(0,s.jsx)(n.code,{children:"dist/"})," folder. You will want to serve these with\nshort-lived caching or no caching at all. The second is a set of hashed static\nassets in the ",(0,s.jsx)(n.code,{children:"dist/static/"})," folder, which you can configure to be cached for a\nmuch longer time."]}),"\n",(0,s.jsx)(n.p,{children:"The configuration of static assets is optimized for frequent changes and serving\nover HTTP 2.0. The assets are aggressively split into small chunks, which means\nthe browser has to make a lot of small requests to load them. The upside is that\nchanges to individual plugins and packages will invalidate a smaller number of\nfiles, thereby allowing for rapid development without much impact on the page\nload performance."}),"\n",(0,s.jsx)(n.h3,{id:"backend-development",children:"Backend Development"}),"\n",(0,s.jsxs)(n.p,{children:["The backend development setup does not use any bundling process. It runs a\nNode.js process directly, with on-the-fly transpilation from TypeScript to\nJavaScript. The transpilation is done with a custom transform based on\n",(0,s.jsx)(n.a,{href:"https://swc.rs/",children:"SWC"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["During development the backend Node.js process will restart whenever there is a\nchange to the source code. This means that any in-memory data will be lost. In\norder to store data between restarts, the backend process has an IPC channel\navailable to store and restore data from the parent CLI process. The primary\npurpose of this, which is already built-in, is to restore the contents of\ndatabases when using SQLite for development. You can also use it for your own\npurposes, with the ",(0,s.jsx)(n.code,{children:"DevDataStore"})," utility exported from the\n",(0,s.jsx)(n.code,{children:"@backstage/backend-dev-utils"})," package."]}),"\n",(0,s.jsxs)(n.p,{children:["If you want to inspect the running Node.js process, the ",(0,s.jsx)(n.code,{children:"--inspect"})," and\n",(0,s.jsx)(n.code,{children:"--inspect-brk"})," flags can be used, as they will be passed through as options to\n",(0,s.jsx)(n.code,{children:"node"})," execution."]}),"\n",(0,s.jsx)(n.h3,{id:"backend-production",children:"Backend Production"}),"\n",(0,s.jsxs)(n.p,{children:["The backend production bundling uses a completely different setup than the other\nbundling options. Rather than using Webpack, the backend production bundling\ninstead collects the backend packages and all of their local dependencies into a\ndeployment archive. The archive is written to ",(0,s.jsx)(n.code,{children:"dist/bundle.tar.gz"}),", and contains\nthe packaged version of each of these packages. The layout of the packages in\nthe archive is the same as the directory layout in the monorepo, and the bundle\nalso contains the root ",(0,s.jsx)(n.code,{children:"package.json"})," and ",(0,s.jsx)(n.code,{children:"yarn.lock"})," files."]}),"\n",(0,s.jsxs)(n.p,{children:["Note that before creating a production bundle you must first build all of the\nbackend packages. This can be done automatically when executing the\n",(0,s.jsx)(n.code,{children:"backend:bundle"})," command by passing the ",(0,s.jsx)(n.code,{children:"--build-dependencies"})," flag. It is an\noptional flag since it is quite common that the packages are already built\nearlier on in your build process, and building them again would result in\nduplicate work."]}),"\n",(0,s.jsxs)(n.p,{children:["In order to use the bundle, you extract it into a directory, run\n",(0,s.jsx)(n.code,{children:"yarn install --production"}),", and then start the backend using your backend\npackage as the Node.js entry point, for example ",(0,s.jsx)(n.code,{children:"node packages/backend"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"dist/bundle.tar.gz"})," is accompanied by a ",(0,s.jsx)(n.code,{children:"dist/skeleton.tar.gz"}),", which has\nthe same layout, but only contains ",(0,s.jsx)(n.code,{children:"package.json"})," files. This skeleton archive\ncan be used to run a ",(0,s.jsx)(n.code,{children:"yarn install"})," in environments that will benefit from the\ncaching that this enables, such as Docker image builds. To use the skeleton\narchive you copy it over to the target directory along with the root\n",(0,s.jsx)(n.code,{children:"package.json"})," and ",(0,s.jsx)(n.code,{children:"yarn.lock"}),", extract the archive, and then run\n",(0,s.jsx)(n.code,{children:"yarn install --production"}),". Your target directory will then have all\ndependencies installed, and as soon as you copy over and extract the contents of\nthe ",(0,s.jsx)(n.code,{children:"bundle.tar.gz"})," archive on top of it, the backend will be ready to run."]}),"\n",(0,s.jsxs)(n.p,{children:["The following is an example of a ",(0,s.jsx)(n.code,{children:"Dockerfile"})," that can be used to package the\noutput of building a package with role ",(0,s.jsx)(n.code,{children:"'backend'"})," into an image:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-Dockerfile",children:'FROM node:20-bookworm-slim\nWORKDIR /app\n\nCOPY yarn.lock package.json packages/backend/dist/skeleton.tar.gz ./\nRUN tar xzf skeleton.tar.gz && rm skeleton.tar.gz\n\n# install sqlite3 dependencies\nRUN apt-get update && \\\n    apt-get install -y libsqlite3-dev python3 cmake g++ && \\\n    rm -rf /var/lib/apt/lists/* && \\\n    yarn config set python /usr/bin/python3\n\nRUN yarn install --frozen-lockfile --production --network-timeout 300000 && rm -rf "$(yarn cache dir)"\n\nCOPY packages/backend/dist/bundle.tar.gz app-config.yaml ./\nRUN tar xzf bundle.tar.gz && rm bundle.tar.gz\n\nCMD ["node", "packages/backend"]\n'})}),"\n",(0,s.jsx)(n.h2,{id:"transpilation",children:"Transpilation"}),"\n",(0,s.jsx)(n.p,{children:"The transpilers used by the Backstage CLI have been chosen according to the same\ndesign considerations that were mentioned above. A few specific requirements are\nof course support for TypeScript and JSX, but also React hot reloads or refresh,\nand hoisting of Jest mocks. The Backstage CLI also only targets up to date and\nmodern browsers, so we actually want to keep the transpilation process as\nlightweight as possible, and leave most syntax intact."}),"\n",(0,s.jsx)(n.p,{children:"Apart from these requirements, the deciding factor for which transpiler to use\nis their speed. The build process keeps the integration with the transpilers\nlightweight, without additional plugins or such. This enables us to switch out\ntranspilers as new options and optimizations become available, and keep on using\nthe best options that are available."}),"\n",(0,s.jsxs)(n.p,{children:["Our current selection of transpilers are ",(0,s.jsx)(n.a,{href:"https://esbuild.github.io/",children:"esbuild"}),"\nand ",(0,s.jsx)(n.a,{href:"https://github.com/alangpierce/sucrase",children:"Sucrase"}),". The reason we choose to\nuse two transpilers is that esbuild is faster than Sucrase and produces slightly\nnicer output, but it does not have the same set of features, for example it does\nnot support React hot reloading."]}),"\n",(0,s.jsxs)(n.p,{children:["The benchmarking of the various options was done in\n",(0,s.jsx)(n.a,{href:"https://github.com/Rugvip/ts-build-bench",children:"ts-build-bench"}),". This benchmarking\nproject allows for setups of different shapes and sizes of monorepos, but the\nsetup we consider the most important in our case is a large monorepo with lots\nof medium to large packages that are being bundled with Webpack. Some rough\nfindings have been that esbuild is the fastest option right now, with Sucrase\nfollowing closely after and then ",(0,s.jsx)(n.a,{href:"https://swc.rs/",children:"SWC"})," closely after that.\nAfter those there's a pretty big gap up to the TypeScript compiler run in\ntranspilation only mode, and lastly another jump up to Babel, being by far the\nslowest out of the transpilers we tested."]}),"\n",(0,s.jsx)(n.p,{children:"Something to note about these benchmarks is that they take the full Webpack\nbundling time into account. This means that even though some transpilation\noptions may be orders of magnitude faster than others, the total time is not\nimpacted in the same way as there are lots of other things that go into the\nbundling process. Still, switching from for example Babel to Sucrase is able to\nmake the bundling anywhere from two to five times faster."}),"\n",(0,s.jsx)(n.h2,{id:"loaders",children:"Loaders"}),"\n",(0,s.jsx)(n.p,{children:"The Backstage CLI is configured to support a set of loaders throughout all parts\nof the build system, including the bundling, tests, builds, and type checking.\nLoaders are always selected based on the file extension. The following is a list\nof all supported file extensions:"}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Extension"}),(0,s.jsx)(n.th,{children:"Exports"}),(0,s.jsx)(n.th,{children:"Purpose"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:".ts"})}),(0,s.jsx)(n.td,{children:"Script Module"}),(0,s.jsx)(n.td,{children:"TypeScript"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:".tsx"})}),(0,s.jsx)(n.td,{children:"Script Module"}),(0,s.jsx)(n.td,{children:"TypeScript and XML"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:".mts"})}),(0,s.jsx)(n.td,{children:"Script Module"}),(0,s.jsx)(n.td,{children:"ECMAScript Module TypeScript"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:".cts"})}),(0,s.jsx)(n.td,{children:"Script Module"}),(0,s.jsx)(n.td,{children:"CommonJS TypeScript"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:".js"})}),(0,s.jsx)(n.td,{children:"Script Module"}),(0,s.jsx)(n.td,{children:"JavaScript"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:".jsx"})}),(0,s.jsx)(n.td,{children:"Script Module"}),(0,s.jsx)(n.td,{children:"JavaScript and XML"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:".mjs"})}),(0,s.jsx)(n.td,{children:"Script Module"}),(0,s.jsx)(n.td,{children:"ECMAScript Module"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:".cjs"})}),(0,s.jsx)(n.td,{children:"Script Module"}),(0,s.jsx)(n.td,{children:"CommonJS Module"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:".json"})}),(0,s.jsx)(n.td,{children:"JSON Data"}),(0,s.jsx)(n.td,{children:"JSON Data"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:".yml"})}),(0,s.jsx)(n.td,{children:"JSON Data"}),(0,s.jsx)(n.td,{children:"YAML Data"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:".yaml"})}),(0,s.jsx)(n.td,{children:"JSON Data"}),(0,s.jsx)(n.td,{children:"YAML Data"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:".css"})}),(0,s.jsx)(n.td,{children:"classes"}),(0,s.jsx)(n.td,{children:"Style sheet"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:".eot"})}),(0,s.jsx)(n.td,{children:"URL Path"}),(0,s.jsx)(n.td,{children:"Font"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:".ttf"})}),(0,s.jsx)(n.td,{children:"URL Path"}),(0,s.jsx)(n.td,{children:"Font"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:".woff2"})}),(0,s.jsx)(n.td,{children:"URL Path"}),(0,s.jsx)(n.td,{children:"Font"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:".woff"})}),(0,s.jsx)(n.td,{children:"URL Path"}),(0,s.jsx)(n.td,{children:"Font"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:".bmp"})}),(0,s.jsx)(n.td,{children:"URL Path"}),(0,s.jsx)(n.td,{children:"Image"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:".gif"})}),(0,s.jsx)(n.td,{children:"URL Path"}),(0,s.jsx)(n.td,{children:"Image"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:".jpeg"})}),(0,s.jsx)(n.td,{children:"URL Path"}),(0,s.jsx)(n.td,{children:"Image"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:".jpg"})}),(0,s.jsx)(n.td,{children:"URL Path"}),(0,s.jsx)(n.td,{children:"Image"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:".png"})}),(0,s.jsx)(n.td,{children:"URL Path"}),(0,s.jsx)(n.td,{children:"Image"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:".svg"})}),(0,s.jsx)(n.td,{children:"URL Path"}),(0,s.jsx)(n.td,{children:"Image"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:".md"})}),(0,s.jsx)(n.td,{children:"URL Path"}),(0,s.jsx)(n.td,{children:"Markdown File"})]})]})]}),"\n",(0,s.jsx)(n.h2,{id:"ecmascript-modules",children:"ECMAScript Modules"}),"\n",(0,s.jsxs)(n.p,{children:["The Backstage tooling supports ",(0,s.jsx)(n.a,{href:"https://nodejs.org/docs/latest-v22.x/api/esm.html",children:"ECMAScript modules (ESM)"})," in Node.js packages. This includes support for all the script module file extensions listed above during local development, in built packages, in tests, and during type checking. ",(0,s.jsx)(n.a,{href:"https://nodejs.org/docs/latest-v22.x/api/esm.html#import-expressions",children:"Dynamic imports"})," can be used to load ESM-only packages from CommonJS and vice versa. There are however a couple of limitations to be aware of:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["To enable support for native ESM in tests, you need to run the tests with the ",(0,s.jsx)(n.code,{children:"--experimental-vm-modules"})," flag enabled, typically via ",(0,s.jsx)(n.code,{children:"NODE_OPTIONS='--experimental-vm-modules'"}),"."]}),"\n",(0,s.jsxs)(n.li,{children:["Declaring a package as ",(0,s.jsx)(n.code,{children:'"type": "module"'})," in ",(0,s.jsx)(n.code,{children:"package.json"})," is supported, but in tests it will cause all local transitive dependencies to also be treated as ESM, regardless of whether they declare ",(0,s.jsx)(n.code,{children:'"type": "module"'})," or not."]}),"\n",(0,s.jsxs)(n.li,{children:["When running tests with coverage enabled the default ",(0,s.jsx)(n.code,{children:"babel"})," coverage provider can mess with the hoisting of named exports. This can be worked around by using the ",(0,s.jsx)(n.code,{children:"v8"})," provider instead by setting ",(0,s.jsx)(n.code,{children:'"coverageProvider": "v8"'})," in the Jest configuration, although note that the ",(0,s.jsx)(n.code,{children:"v8"})," provider is a fair bit slower than the ",(0,s.jsx)(n.code,{children:"babel"})," one."]}),"\n",(0,s.jsxs)(n.li,{children:["Node.js has an ",(0,s.jsx)(n.a,{href:"https://nodejs.org/docs/latest-v22.x/api/esm.html#interoperability-with-commonjs",children:"ESM interoperability layer with CommonJS"})," that allows for imports from ESM to identify named exports in CommonJS packages. This interoperability layer is ",(0,s.jsx)(n.strong,{children:"only"})," enabled when importing packages with a ",(0,s.jsx)(n.code,{children:".cts"})," or ",(0,s.jsx)(n.code,{children:".cjs"})," extension. This is because the interoperability layer is not fully compatible with the NPM ecosystem, and would break package if it was enabled for ",(0,s.jsx)(n.code,{children:".js"})," files."]}),"\n",(0,s.jsxs)(n.li,{children:["Dynamic imports of CommonJS packages will vary in shape depending on the runtime, i.e. test vs local development, etc. It is therefore recommended to avoid dynamic imports of CommonJS packages and instead use ",(0,s.jsx)(n.code,{children:"require"}),", or to use the explicit CommonJS extensions as mentioned above. If you do need to dynamically import CommonJS packages, avoid using ",(0,s.jsx)(n.code,{children:"default"})," exports, as the shape of them vary across different environments and you would otherwise need to manually unwrap the import based on the shape of the module object."]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"jest-configuration",children:"Jest Configuration"}),"\n",(0,s.jsxs)(n.p,{children:["The Backstage CLI bundles its own Jest configuration file, which is used\nautomatically when running ",(0,s.jsx)(n.code,{children:"backstage-cli test"}),". It's available at\n",(0,s.jsx)(n.code,{children:"@backstage/cli/config/jest.js"})," and can be inspected\n",(0,s.jsx)(n.a,{href:"https://github.com/backstage/backstage/blob/master/packages/cli/config/jest.js",children:"here"}),".\nUsage of this configuration can be overridden either by passing a\n",(0,s.jsx)(n.code,{children:"--config <path>"})," flag to ",(0,s.jsx)(n.code,{children:"backstage-cli test"}),", or placing a ",(0,s.jsx)(n.code,{children:"jest.config.js"})," or\n",(0,s.jsx)(n.code,{children:"jest.config.ts"})," file in your package."]}),"\n",(0,s.jsxs)(n.p,{children:["The built-in configuration brings a couple of benefits and features. The most\nimportant one being a baseline transformer and module configuration that enables\nsupport for the listed ",(0,s.jsx)(n.a,{href:"#loaders",children:"loaders"})," within tests. It will also\nautomatically detect and use ",(0,s.jsx)(n.code,{children:"src/setupTests.ts"})," if it exists, and provides a\ncoverage configuration that works well with our selected transpilers. The configuration\nwill also detect the appropriate Jest environment for each package role, running\n",(0,s.jsx)(n.code,{children:"web-libraries"})," with the ",(0,s.jsx)(n.code,{children:'"jsdom"'})," environment, ",(0,s.jsx)(n.code,{children:"node-libraries"})," with ",(0,s.jsx)(n.code,{children:'"node"'}),", and so on."]}),"\n",(0,s.jsxs)(n.p,{children:["The configuration also takes a project-wide approach, with the expectation most\nif not all packages within a monorepo will use the same base configuration. This\nallows for optimizations such as sharing the Jest transform cache across all\npackages in a monorepo, avoiding unnecessary transpilation. It also makes it\npossible to load in all Jest configurations at once, and with that run\n",(0,s.jsx)(n.code,{children:"yarn test <pattern>"})," from the root of a monorepo without having to set the\nworking directory to the package that the test is in."]}),"\n",(0,s.jsxs)(n.p,{children:["Where small customizations are needed, such as setting coverage thresholds or\nsupport for specific transforms, it is possible to override the Jest\nconfiguration through the ",(0,s.jsx)(n.code,{children:'"jest"'})," field in ",(0,s.jsx)(n.code,{children:"package.json"}),". For a full list of\noptions, see the ",(0,s.jsx)(n.a,{href:"https://jestjs.io/docs/en/configuration",children:"Jest documentation"}),".\nThese overrides will be loaded in from all ",(0,s.jsx)(n.code,{children:"package.json"})," files in the directory ancestry, meaning\nthat you can place common configuration in the ",(0,s.jsx)(n.code,{children:"package.json"})," at the root of a\nmonorepo. If multiple overrides are found, they will be merged together with\nconfiguration further down in the directory tree taking precedence."]}),"\n",(0,s.jsxs)(n.p,{children:["The overrides in a single ",(0,s.jsx)(n.code,{children:"package.json"})," may for example look like this:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-json",children:'  "jest": {\n    "coverageThreshold": {\n      "global": {\n        "functions": 100,\n        "lines": 100,\n        "statements": 100\n      }\n    }\n  },\n'})}),"\n",(0,s.jsx)(n.h3,{id:"additional-configuration-options",children:"Additional Configuration Options"}),"\n",(0,s.jsxs)(n.p,{children:["When using the built-in ",(0,s.jsx)(n.code,{children:"@backstage/cli/config/jest"})," configuration the following options are available in addition to the standard Jest options."]}),"\n",(0,s.jsxs)(n.h4,{id:"rejectfrontendnetworkrequests-boolean",children:[(0,s.jsx)(n.code,{children:"rejectFrontendNetworkRequests"})," ",(0,s.jsx)(n.strong,{children:"[boolean]"})]}),"\n",(0,s.jsxs)(n.p,{children:["Default: ",(0,s.jsx)(n.code,{children:"false"})]}),"\n",(0,s.jsxs)(n.p,{children:["If set to ",(0,s.jsx)(n.code,{children:"true"}),", any attempt to make a network request in frontend package tests will result in an error. This option can only be set in the root ",(0,s.jsx)(n.code,{children:"package.json"})," and will apply to all frontend packages in the monorepo."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-json",metastring:'title="Example - in your root package.json"',children:'  "jest": {\n    "rejectFrontendNetworkRequests": true\n  },\n'})}),"\n",(0,s.jsx)(n.h2,{id:"caching",children:"Caching"}),"\n",(0,s.jsx)(n.p,{children:"Caching is used sparingly throughout the Backstage build system. It is always used as a way to squeeze out a little bit of extra performance, rather than requirement to keep things fast. The following is a list of places where optional caching is available:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"TypeScript"})," - The default ",(0,s.jsx)(n.code,{children:"tsconfig.json"})," used by Backstage projects has ",(0,s.jsx)(n.code,{children:"incremental"})," set to ",(0,s.jsx)(n.code,{children:"true"}),", which enables local caching of type checking results. It is however generally not recommended in CI, where ",(0,s.jsx)(n.code,{children:"yarn tsc:full"})," is preferred, which sets ",(0,s.jsx)(n.code,{children:"--incremental false"}),"."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Testing"})," - The ",(0,s.jsx)(n.code,{children:"backstage-cli repo test"})," command has a ",(0,s.jsx)(n.code,{children:"--successCache"})," flag that enables caching of successful test results. This is done at the package level, meaning that if a package has not been changed since the last test run and it was successful, the testing will be skipped. This is recommended to be used in CI, but not during local development."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Linting"})," - The ",(0,s.jsx)(n.code,{children:"backstage-cli repo lint"})," command has a ",(0,s.jsx)(n.code,{children:"--successCache"})," flag that enables caching of successful linting results. This is done at the package level, meaning that if a package has not been changed since the last lint run and it was successful, the linting will be skipped. This is recommended to be used in CI, but not during local development."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Webpack"})," - It is possible to enable experimental caching of frontend package builds using the ",(0,s.jsx)(n.code,{children:"BACKSTAGE_CLI_EXPERIMENTAL_BUILD_CACHE"})," environment variable. This will enable the Webpack filesystem cache."]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"debugging-jest-tests",children:"Debugging Jest Tests"}),"\n",(0,s.jsx)(n.p,{children:"For your productivity working with unit tests it's quite essential to have your debugging configured in IDE. It will help you to identify the root cause of the issue faster."}),"\n",(0,s.jsxs)(n.p,{children:["We cannot execute tests with just raw ",(0,s.jsx)(n.code,{children:"jest"}),", because there are a few concerns such as module transforms that need to be in place for the ",(0,s.jsx)(n.code,{children:"jest"})," runtime to be happy.\nTherefore, we delegate to the Backstage CLI to wrap the jest run for us, since it knows how to put those things in place.\nThis aligns things so that your in-IDE test runs work the same way as your CI and manual command line test runs do."]}),"\n",(0,s.jsxs)(n.p,{children:["With that in mind, here are some IDEs configurations to run backstage components' ",(0,s.jsx)(n.code,{children:"jest"})," tests with ",(0,s.jsx)(n.code,{children:"backstage-cli"})," in the role of ",(0,s.jsx)(n.code,{children:"jest"}),"."]}),"\n",(0,s.jsx)(n.h4,{id:"intellij-idea",children:"IntelliJ IDEA"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"Update Jest configuration template by:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:'Click on "Edit Configurations" on top panel'}),"\n",(0,s.jsx)(n.li,{children:'In the modal dialog click on link "Edit configuration templates..." located in the bottom left corner.'}),"\n",(0,s.jsxs)(n.li,{children:['"Configuration file": leave empty (',(0,s.jsx)(n.code,{children:"backstage-cli"})," adds the config)"]}),"\n",(0,s.jsxs)(n.li,{children:['"Node options": ',(0,s.jsx)(n.code,{children:"--no-node-snapshot --experimental-vm-modules"})]}),"\n",(0,s.jsxs)(n.li,{children:['"Jest package": ',(0,s.jsx)(n.code,{children:"~/workspace/backstage/node_modules/@backstage/cli"})," - the location of the backstage cli package."]}),"\n",(0,s.jsxs)(n.li,{children:['"Working directory": ',(0,s.jsx)(n.code,{children:"~/workspace/backstage"})]}),"\n",(0,s.jsxs)(n.li,{children:['"Jest Options": ',(0,s.jsx)(n.code,{children:"repo test --runInBand --watch=false"})]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:['Currently, intellij has an issue that if you right-click on a jest test and press "run", intellij will create a playwright run configuration instead of jest configuration, see ',(0,s.jsx)(n.a,{href:"https://youtrack.jetbrains.com/issue/WEB-67720/Jest-test-runs-as-playwright-test",children:"WEB-67720"}),"."]}),"\n",(0,s.jsx)(n.p,{children:"Until intellij maintainers resolve the issue, create a jest configuration manually. Happily, intellij will pre-fill the configuration from the template. The only thing you need to do is provide a path to the test file. Note, that after intellij runs test in the file you can click on the individual tests from the run panel and re-run them, this time intellij will create a correct jest run configuration."}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"vs-code",children:"VS Code"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-jsonc",children:'{\n  "jest.jestCommandLine": "yarn test",\n  // In a large repo like the Backstage main repo you likely want to disable\n  // watch mode and the initial test run too, leaving just manual and perhaps\n  // on-save test runs in place.\n  "jest.autoRun": {\n    "watch": false,\n    "onSave": "test-src-file"\n  }\n}\n'})}),"\n",(0,s.jsx)(n.p,{children:"A complete launch configuration for VS Code debugging may look like this:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-jsonc",children:'{\n  "type": "node",\n  "name": "vscode-jest-tests.v2",\n  "request": "launch",\n  "args": [\n    "repo",\n    "test",\n    "--runInBand",\n    "--watchAll=false",\n    "--testNamePattern",\n    "${jest.testNamePattern}",\n    "--runTestsByPath",\n    "${jest.testFile}"\n  ],\n  "console": "integratedTerminal",\n  "internalConsoleOptions": "neverOpen",\n  "disableOptimisticBPs": true,\n  "program": "${workspaceFolder}/node_modules/.bin/backstage-cli"\n}\n'})}),"\n",(0,s.jsx)(n.h2,{id:"publishing",children:"Publishing"}),"\n",(0,s.jsxs)(n.p,{children:["Package publishing is an optional part of the Backstage build system and not\nsomething you will need to worry about unless you are publishing packages to a\nregistry. In addition to the documentation in the section, be sure to also read\nthe section on ",(0,s.jsx)(n.a,{href:"/docs/next/tooling/package-metadata#metadata-for-published-packages",children:"metadata for published packages"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["In order to publish a package, you first need to build it, which will\npopulate the ",(0,s.jsx)(n.code,{children:"dist"})," folder. Because the Backstage build system is optimized for\nlocal development along with our particular TypeScript and bundling setup, it is\nnot possible to publish the package immediately at this point. This is because\nthe entry points of the package will still be pointing to ",(0,s.jsx)(n.code,{children:"src/index.ts"}),", but we\nwant them to point to ",(0,s.jsx)(n.code,{children:"dist/"})," in the published package."]}),"\n",(0,s.jsxs)(n.p,{children:["In order to work around this, the Backstage CLI provides ",(0,s.jsx)(n.code,{children:"prepack"})," and\n",(0,s.jsx)(n.code,{children:"postpack"})," commands that help prepare the package for publishing. These scripts\nare automatically run by Yarn before publishing a package."]}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"prepack"})," command will take entry point fields in ",(0,s.jsx)(n.code,{children:'"publishConfig"'}),", such as\n",(0,s.jsx)(n.code,{children:'"main"'})," and ",(0,s.jsx)(n.code,{children:'"module"'}),", and move them to the top level of the ",(0,s.jsx)(n.code,{children:"package.json"}),".\nThis lets you point at the desired files in the ",(0,s.jsx)(n.code,{children:"dist"})," folder during publishing.\nThe ",(0,s.jsx)(n.code,{children:"postpack"})," command will simply revert this change in order to leave your\nproject clean."]}),"\n",(0,s.jsx)(n.p,{children:"The following is an excerpt of a typical setup of an isomorphic library package:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-json",children:'  "main": "src/index.ts",\n  "types": "src/index.ts",\n  "publishConfig": {\n    "access": "public",\n    "main": "dist/index.cjs.js",\n    "module": "dist/index.esm.js",\n    "types": "dist/index.d.ts"\n  },\n  "scripts": {\n    "build": "backstage-cli package build",\n    "lint": "backstage-cli package lint",\n    "test": "backstage-cli package test",\n    "clean": "backstage-cli package clean",\n    "prepack": "backstage-cli package prepack",\n    "postpack": "backstage-cli package postpack"\n  },\n  "files": ["dist"],\n'})}),"\n",(0,s.jsx)(n.h2,{id:"subpath-exports",children:"Subpath Exports"}),"\n",(0,s.jsxs)(n.p,{children:["The Backstage CLI supports implementation of subpath exports through the ",(0,s.jsx)(n.code,{children:'"exports"'})," field in ",(0,s.jsx)(n.code,{children:"package.json"}),". It might for example look like this:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-json",children:'  "name": "@backstage/plugin-foo",\n  "exports": {\n    ".": "./src/index.ts",\n    "./components": "./src/components.ts",\n  },\n'})}),"\n",(0,s.jsxs)(n.p,{children:["This in turn would allow you to import anything exported in ",(0,s.jsx)(n.code,{children:"src/index.ts"})," via ",(0,s.jsx)(n.code,{children:"@backstage/plugins-foo"}),", and ",(0,s.jsx)(n.code,{children:"src/components.ts"})," via ",(0,s.jsx)(n.code,{children:"@backstage/plugins-foo/components"}),". Note that patterns are not supported, meaning the exports may not contain ",(0,s.jsx)(n.code,{children:"*"})," wildcards."]}),"\n",(0,s.jsxs)(n.p,{children:["As with the rest of the Backstage CLI build system, the setup is optimized for local development, which is why the ",(0,s.jsx)(n.code,{children:'"exports"'})," targets point directly to source files. The ",(0,s.jsx)(n.code,{children:"package build"})," command will detect the ",(0,s.jsx)(n.code,{children:'"exports"'})," field and automatically generate the corresponding ",(0,s.jsx)(n.code,{children:"dist"})," files, and the ",(0,s.jsx)(n.code,{children:"prepublish"})," command will rewrite the ",(0,s.jsx)(n.code,{children:'"exports"'})," field to point to the ",(0,s.jsx)(n.code,{children:"dist"})," files, as well as generating folder-based entry points for backwards compatibility."]}),"\n",(0,s.jsxs)(n.p,{children:["TypeScript support is currently handled though the ",(0,s.jsx)(n.code,{children:"typesVersions"})," field, as there is not yet a module resolution mode that works well with ",(0,s.jsx)(n.code,{children:'"exports"'}),". You can craft the ",(0,s.jsx)(n.code,{children:"typesVersions"})," yourself, but it will also be automatically generated by the ",(0,s.jsx)(n.code,{children:"migrate package-exports"})," command."]}),"\n",(0,s.jsxs)(n.p,{children:["To add subpath exports to an existing package, simply add the desired ",(0,s.jsx)(n.code,{children:'"exports"'})," fields and then run the following command:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"yarn backstage-cli migrate package-exports\n"})})]})}function h(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(l,{...e})}):l(e)}},221020:(e,n,t)=>{var s=t(296540),i=Symbol.for("react.element"),o=Symbol.for("react.fragment"),a=Object.prototype.hasOwnProperty,r=s.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner,d={key:!0,ref:!0,__self:!0,__source:!0};function c(e,n,t){var s,o={},c=null,l=null;for(s in void 0!==t&&(c=""+t),void 0!==n.key&&(c=""+n.key),void 0!==n.ref&&(l=n.ref),n)a.call(n,s)&&!d.hasOwnProperty(s)&&(o[s]=n[s]);if(e&&e.defaultProps)for(s in n=e.defaultProps)void 0===o[s]&&(o[s]=n[s]);return{$$typeof:i,type:e,key:c,ref:l,props:o,_owner:r.current}}n.Fragment=o,n.jsx=c,n.jsxs=c},474848:(e,n,t)=>{e.exports=t(221020)},28453:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>r});var s=t(296540);const i={},o=s.createContext(i);function a(e){const n=s.useContext(o);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),s.createElement(o.Provider,{value:n},e.children)}}}]);