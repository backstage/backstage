"use strict";(self.webpackChunkbackstage_microsite=self.webpackChunkbackstage_microsite||[]).push([["39288"],{24909(e,n,t){t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>p,frontMatter:()=>r,metadata:()=>s,toc:()=>d});var s=t(234380),i=t(474848),o=t(28453);let r={id:"testing",title:"Frontend System Testing Plugins",sidebar_label:"Testing",description:"Testing plugins in the frontend system"},a="Testing Frontend Plugins",c={},d=[{value:"Testing React components",id:"testing-react-components",level:2},{value:"Testing extensions",id:"testing-extensions",level:2},{value:"Single extension",id:"single-extension",level:3},{value:"Multiple extensions",id:"multiple-extensions",level:3},{value:"Setting configuration",id:"setting-configuration",level:3},{value:"Missing something?",id:"missing-something",level:2}];function l(e){let n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",p:"p",pre:"pre",...(0,o.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"testing-frontend-plugins",children:"Testing Frontend Plugins"})}),"\n",(0,i.jsxs)(n.p,{children:["Utilities for testing frontend features and components are available in ",(0,i.jsx)(n.code,{children:"@backstage/frontend-test-utils"}),"."]}),"\n",(0,i.jsx)(n.h2,{id:"testing-react-components",children:"Testing React components"}),"\n",(0,i.jsx)(n.p,{children:"A component can be used for more than one extension, and it should be tested independently of an extension environment."}),"\n",(0,i.jsxs)(n.p,{children:["Use the ",(0,i.jsx)(n.code,{children:"renderInTestApp"})," helper to render a given component inside a Backstage test app:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-tsx",children:"import { screen } from '@testing-library/react';\nimport { renderInTestApp } from '@backstage/frontend-test-utils';\nimport { EntityDetails } from './plugin';\n\ndescribe('Entity details component', () => {\n  it('should render the entity name and owner', async () => {\n    await renderInTestApp(<EntityDetails owner=\"tools\" name=\"test\" />);\n\n    await expect(\n      screen.findByText('The entity \"test\" is owned by \"tools\"'),\n    ).resolves.toBeInTheDocument();\n  });\n});\n"})}),"\n",(0,i.jsxs)(n.p,{children:["To mock ",(0,i.jsx)(n.a,{href:"/docs/next/frontend-system/architecture/utility-apis",children:"Utility APIs"})," that are used by your component you can use the ",(0,i.jsx)(n.code,{children:"TestApiProvider"})," to override individual API implementations. In the snippet below, we wrap the component within a ",(0,i.jsx)(n.code,{children:"TestApiProvider"})," in order to mock the catalog client API:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-tsx",children:"import { screen } from '@testing-library/react';\nimport {\n  renderInTestApp,\n  TestApiProvider,\n} from '@backstage/frontend-test-utils';\nimport { stringifyEntityRef } from '@backstage/catalog-model';\nimport { CatalogApi, catalogApiRef } from '@backstage/plugin-catalog-react';\nimport { EntityDetails } from './plugin';\n\ndescribe('Entity details component', () => {\n  it('should render the entity name and owner', async () => {\n    const catalogApiMock = {\n      async getEntityFacets() {\n        return {\n          facets: {\n            'relations.ownedBy': [{ count: 1, value: 'group:default/tools' }],\n          },\n        },\n      }\n    } satisfies Partial<typeof catalogApiRef.T>;\n\n    const entityRef = stringifyEntityRef({\n      kind: 'Component',\n      namespace: 'default',\n      name: 'test',\n    });\n\n    await renderInTestApp(\n      <TestApiProvider apis={[[catalogApiRef, catalogApiMock]]}>\n        <EntityDetails entityRef={entityRef} />\n      </TestApiProvider>,\n    );\n\n    await expect(\n      screen.findByText('The entity \"test\" is owned by \"tools\"'),\n    ).resolves.toBeInTheDocument();\n  });\n});\n"})}),"\n",(0,i.jsxs)(n.p,{children:["This pattern also works for many other context providers. An important example is the ",(0,i.jsx)(n.code,{children:"EntityProvider"})," from the ",(0,i.jsx)(n.code,{children:"@backstage/plugin-catalog-react"})," package, which you can use to provide a mocked entity context to the component."]}),"\n",(0,i.jsx)(n.h2,{id:"testing-extensions",children:"Testing extensions"}),"\n",(0,i.jsxs)(n.p,{children:["To facilitate testing of frontend extensions, the ",(0,i.jsx)(n.code,{children:"@backstage/frontend-test-utils"})," package provides a tester class which starts up an entire frontend harness, complete with a number of default features. You can then provide overrides for extensions whose behavior you need to adjust for the test run."]}),"\n",(0,i.jsx)(n.p,{children:"A number of features (frontend extensions and overrides) are also accepted by the tester. Here are some examples of how these facilities can be useful:"}),"\n",(0,i.jsx)(n.h3,{id:"single-extension",children:"Single extension"}),"\n",(0,i.jsxs)(n.p,{children:["In order to test an extension in isolation, you can use ",(0,i.jsx)(n.code,{children:"createExtensionTester"})," to create a tester instance and access the element that the extension outputs. This element can then be rendered as usual with ",(0,i.jsx)(n.code,{children:"renderInTestApp"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-tsx",children:"import { screen } from '@testing-library/react';\nimport { createExtensionTester } from '@backstage/frontend-test-utils';\nimport { indexPageExtension } from './plugin';\n\ndescribe('Index page', () => {\n  it('should render the index page', async () => {\n    await renderInTestApp(\n      createExtensionTester(indexPageExtension).reactElement(),\n    );\n\n    expect(screen.getByText('Index Page')).toBeInTheDocument();\n  });\n});\n"})}),"\n",(0,i.jsxs)(n.p,{children:["This pattern also allows you to wrap the extension with context providers, such as the ",(0,i.jsx)(n.code,{children:"TestApiProvider"})," that was introduced ",(0,i.jsx)(n.a,{href:"#testing-react-components",children:"above"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["Note that the ",(0,i.jsx)(n.code,{children:".reactElement()"})," method will look for the ",(0,i.jsx)(n.code,{children:"coreExtensionData.reactElement"})," data in the extension outputs. If that doesn't exist and the extension outputs something else that you want to test, you can access the output data using the ",(0,i.jsx)(n.code,{children:".get(dataRef)"})," method instead."]}),"\n",(0,i.jsx)(n.h3,{id:"multiple-extensions",children:"Multiple extensions"}),"\n",(0,i.jsxs)(n.p,{children:["In some cases you might need to test multiple extensions together, in particular when testing inputs. In this case, you can add more extensions to the tester instance using the ",(0,i.jsx)(n.code,{children:".add(...)"})," method. It also accepts an optional options object as the second argument, which you can use to provide configuration for the extension instance."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-tsx",children:"import { screen } from '@testing-library/react';\nimport userEvent from '@testing-library/user-event';\nimport { createExtensionTester } from '@backstage/frontend-test-utils';\nimport { indexPageExtension, indexPageHeader } from './plugin';\n\ndescribe('Index page', async () => {\n  it('should link to the index page with header', async () => {\n    const tester = createExtensionTester(indexPageExtension)\n      // Adding the header to be rendered on the index page\n      .add(indexPageHeader);\n\n    await renderInTestApp(tester.reactElement());\n\n    await expect(screen.findByText('Index page')).toBeInTheDocument();\n    await expect(screen.findByText('Index page header')).toBeInTheDocument();\n\n    expect(\n      tester.query(indexPageHeader).get(headerDataRef),\n    ).toMatchObject(/* ... */);\n  });\n});\n"})}),"\n",(0,i.jsxs)(n.p,{children:["When testing multiple extensions you may sometimes want to access the output of other extensions than the main test subject. You can use the ",(0,i.jsx)(n.code,{children:".query(ext)"})," method to query a different extension that has been added to the tester, by passing the extension used with the ",(0,i.jsx)(n.code,{children:"createExtensionTester(...).add(ext)"})]}),"\n",(0,i.jsx)(n.h3,{id:"setting-configuration",children:"Setting configuration"}),"\n",(0,i.jsx)(n.p,{children:"In the case that your extension can be configured, you can test this capability by passing configuration values as follows:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-tsx",children:"import { screen } from '@testing-library/react';\nimport userEvent from '@testing-library/user-event';\nimport { createExtensionTester } from '@backstage/frontend-test-utils';\nimport { indexPageExtension, detailsPageExtension } from './plugin';\n\ndescribe('Index page', () => {\n  it('should accept a custom title via config', async () => {\n    const tester = createExtensionTester(indexPageExtension, {\n      // Extension configuration for the index page\n      config: { title: 'Custom page' },\n    }).add(indexPageHeader, {\n      // Extension configuration for the index page header\n      config: { title: 'Custom page header' },\n    });\n\n    await renderInTestApp(tester.reactElement(), {\n      // Global configuration for the app\n      config: {\n        app: {\n          title: 'Custom app',\n        },\n      },\n    });\n\n    await expect(screen.findByText('Custom app')).toBeInTheDocument();\n    await expect(screen.findByText('Custom page')).toBeInTheDocument();\n    await expect(screen.findByText('Custom page header')).toBeInTheDocument();\n  });\n});\n"})}),"\n",(0,i.jsx)(n.p,{children:"That's all for testing features!"}),"\n",(0,i.jsx)(n.h2,{id:"missing-something",children:"Missing something?"}),"\n",(0,i.jsx)(n.p,{children:"If there's anything else you think needs to be covered in the docs or that you think isn't covered by the test utilities, please create an issue in the Backstage repository. You are always welcome to contribute as well!"})]})}function p(e={}){let{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(l,{...e})}):l(e)}},28453(e,n,t){t.d(n,{R:()=>r,x:()=>a});var s=t(296540);let i={},o=s.createContext(i);function r(e){let n=s.useContext(o);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),s.createElement(o.Provider,{value:n},e.children)}},234380(e){e.exports=JSON.parse('{"id":"frontend-system/building-plugins/testing","title":"Frontend System Testing Plugins","description":"Testing plugins in the frontend system","source":"@site/../docs/frontend-system/building-plugins/02-testing.md","sourceDirName":"frontend-system/building-plugins","slug":"/frontend-system/building-plugins/testing","permalink":"/docs/next/frontend-system/building-plugins/testing","draft":false,"unlisted":false,"editUrl":"https://github.com/backstage/backstage/edit/master/docs/frontend-system/building-plugins/02-testing.md","tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"id":"testing","title":"Frontend System Testing Plugins","sidebar_label":"Testing","description":"Testing plugins in the frontend system"},"sidebar":"docs","previous":{"title":"Overview","permalink":"/docs/next/frontend-system/building-plugins/index"},"next":{"title":"Common Extension Blueprints","permalink":"/docs/next/frontend-system/building-plugins/common-extension-blueprints"}}')}}]);